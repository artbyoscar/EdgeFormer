{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EdgeFormer Documentation Generated on: 2025-03-23 19:30:24 Modules src.model.edgeformer src.model.multi_head_latent_attention src.model.sparse_mlp src.model.transformer_block src.model.config src.utils.device src.utils.rdna3_optimizations src.utils.weight_quantization src.utils.training_utils src.utils.data_augmentation src.utils.kv_cache_offload","title":"EdgeFormer Documentation"},{"location":"#edgeformer-documentation","text":"Generated on: 2025-03-23 19:30:24","title":"EdgeFormer Documentation"},{"location":"#modules","text":"src.model.edgeformer src.model.multi_head_latent_attention src.model.sparse_mlp src.model.transformer_block src.model.config src.utils.device src.utils.rdna3_optimizations src.utils.weight_quantization src.utils.training_utils src.utils.data_augmentation src.utils.kv_cache_offload","title":"Modules"},{"location":"src_model_config/","text":"src.model.config Classes EdgeFormerConfig Methods __init__ __init__(self, vocab_size=32000, hidden_size=768, num_hidden_layers=12, num_attention_heads=12, intermediate_size=3072, hidden_act='gelu', hidden_dropout_prob=0.1, attention_probs_dropout_prob=0.1, max_position_embeddings=2048, type_vocab_size=2, initializer_range=0.02, layer_norm_eps=1e-12, pad_token_id=0, bos_token_id=1, eos_token_id=2, latent_size_factor=8, num_kv_groups=4, use_sliding_window=True, sliding_window_size=512, use_flash_attention=True, use_sparse_mlp=True, mlp_sparsity=0.8, quantization='int8', optimize_for_rdna3=True, debug_mode=False)","title":"src.model.config"},{"location":"src_model_config/#srcmodelconfig","text":"","title":"src.model.config"},{"location":"src_model_config/#classes","text":"","title":"Classes"},{"location":"src_model_config/#edgeformerconfig","text":"","title":"EdgeFormerConfig"},{"location":"src_model_config/#methods","text":"","title":"Methods"},{"location":"src_model_config/#__init__","text":"__init__(self, vocab_size=32000, hidden_size=768, num_hidden_layers=12, num_attention_heads=12, intermediate_size=3072, hidden_act='gelu', hidden_dropout_prob=0.1, attention_probs_dropout_prob=0.1, max_position_embeddings=2048, type_vocab_size=2, initializer_range=0.02, layer_norm_eps=1e-12, pad_token_id=0, bos_token_id=1, eos_token_id=2, latent_size_factor=8, num_kv_groups=4, use_sliding_window=True, sliding_window_size=512, use_flash_attention=True, use_sparse_mlp=True, mlp_sparsity=0.8, quantization='int8', optimize_for_rdna3=True, debug_mode=False)","title":"__init__"},{"location":"src_model_edgeformer/","text":"src.model.edgeformer Classes EdgeFormer Methods __init__ __init__(self, config) add_module Add a child module to the current module. The module can be accessed as an attribute using the given name. Args: name (str): name of the child module. The child module can be accessed from this module using the given name module (Module): child module to be added to the module. add_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None apply Apply fn recursively to every submodule (as returned by .children() ) as well as self. Typical use includes initializing the parameters of a model (see also :ref: nn-init-doc ). Args: fn (:class: Module -> None): function to be applied to each submodule Returns: Module: self Example:: >>> @torch.no_grad() >>> def init_weights(m): >>> print(m) >>> if type(m) == nn.Linear: >>> m.weight.fill_(1.0) >>> print(m.weight) >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2)) >>> net.apply(init_weights) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) apply(self: ~T, fn: Callable[[ForwardRef('Module')], NoneType]) -> ~T bfloat16 Casts all floating point parameters and buffers to bfloat16 datatype. .. note:: This method modifies the module in-place. Returns: Module: self bfloat16(self: ~T) -> ~T buffers Return an iterator over module buffers. Args: recurse (bool): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Yields: torch.Tensor: module buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for buf in model.buffers(): >>> print(type(buf), buf.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) buffers(self, recurse: bool = True) -> Iterator[torch.Tensor] children Return an iterator over immediate children modules. Yields: Module: a child module children(self) -> Iterator[ForwardRef('Module')] compile Compile this Module's forward using :func: torch.compile . This Module's __call__ method is compiled and all arguments are passed as-is to :func: torch.compile . See :func: torch.compile for details on the arguments for this function. compile(self, *args, **kwargs) continue_generation Helper method to continue generation with KV cache. Args: new_tokens: New token IDs to generate from (tensor of shape [batch_size, new_seq_length]) past_key_values: Past key-values from previous generation step (can be a string ID or tensor tuple) Returns: Dictionary with generated outputs continue_generation(self, new_tokens, past_key_values) cpu Move all model parameters and buffers to the CPU. .. note:: This method modifies the module in-place. Returns: Module: self cpu(self: ~T) -> ~T cuda Move all model parameters and buffers to the GPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on GPU while being optimized. .. note:: This method modifies the module in-place. Args: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self cuda(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T double Casts all floating point parameters and buffers to double datatype. .. note:: This method modifies the module in-place. Returns: Module: self double(self: ~T) -> ~T eval Set the module in evaluation mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e. whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. This is equivalent with :meth: self.train(False) <torch.nn.Module.train> . See :ref: locally-disable-grad-doc for a comparison between .eval() and several similar mechanisms that may be confused with it. Returns: Module: self eval(self: ~T) -> ~T extra_repr Return the extra representation of the module. To print customized extra information, you should re-implement this method in your own modules. Both single-line and multi-line strings are acceptable. extra_repr(self) -> str float Casts all floating point parameters and buffers to float datatype. .. note:: This method modifies the module in-place. Returns: Module: self float(self: ~T) -> ~T forward forward(self, input_ids=None, attention_mask=None, position_ids=None, inputs_embeds=None, past_key_values=None, labels=None, use_cache=None, output_attentions=None, output_hidden_states=None, return_dict=None, sliding_window_size=None) generate Generate text using the model. generate(self, input_ids, attention_mask=None, max_length=100, temperature=1.0, top_k=50, top_p=0.9, repetition_penalty=1.0, do_sample=True, num_return_sequences=1, pad_token_id=None, eos_token_id=None) get_buffer Return the buffer given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the buffer to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.Tensor: The buffer referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not a buffer get_buffer(self, target: str) -> 'Tensor' get_extra_state Return any extra state to include in the module's state_dict. Implement this and a corresponding :func: set_extra_state for your module if you need to store extra state. This function is called when building the module's state_dict() . Note that extra state should be picklable to ensure working serialization of the state_dict. We only provide backwards compatibility guarantees for serializing Tensors; other objects may break backwards compatibility if their serialized pickled form changes. Returns: object: Any extra state to store in the module's state_dict get_extra_state(self) -> Any get_input_embeddings get_input_embeddings(self) get_parameter Return the parameter given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the Parameter to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.nn.Parameter: The Parameter referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Parameter get_parameter(self, target: str) -> 'Parameter' get_submodule Return the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A which has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To check whether or not we have the linear submodule, we would call get_submodule(\"net_b.linear\") . To check whether we have the conv submodule, we would call get_submodule(\"net_b.net_c.conv\") . The runtime of get_submodule is bounded by the degree of module nesting in target . A query against named_modules achieves the same result, but it is O(N) in the number of transitive modules. So, for a simple check to see if some submodule exists, get_submodule should always be used. Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) Returns: torch.nn.Module: The submodule referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module get_submodule(self, target: str) -> 'Module' half Casts all floating point parameters and buffers to half datatype. .. note:: This method modifies the module in-place. Returns: Module: self half(self: ~T) -> ~T ipu Move all model parameters and buffers to the IPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on IPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self ipu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T load_state_dict Copy parameters and buffers from :attr: state_dict into this module and its descendants. If :attr: strict is True , then the keys of :attr: state_dict must exactly match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. .. warning:: If :attr: assign is True the optimizer must be created after the call to :attr: load_state_dict unless :func: ~torch.__future__.get_swap_module_params_on_conversion is True . Args: state_dict (dict): a dict containing parameters and persistent buffers. strict (bool, optional): whether to strictly enforce that the keys in :attr: state_dict match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. Default: True assign (bool, optional): When set to False , the properties of the tensors in the current module are preserved whereas setting it to True preserves properties of the Tensors in the state dict. The only exception is the requires_grad field of :class: ~torch.nn.Parameter s for which the value from the module is preserved. Default: False Returns: NamedTuple with missing_keys and unexpected_keys fields: * missing_keys is a list of str containing any keys that are expected by this module but missing from the provided state_dict . * unexpected_keys is a list of str containing the keys that are not expected by this module but present in the provided state_dict . Note: If a parameter or buffer is registered as None and its corresponding key exists in :attr: state_dict , :meth: load_state_dict will raise a RuntimeError . load_state_dict(self, state_dict: Mapping[str, Any], strict: bool = True, assign: bool = False) modules Return an iterator over all modules in the network. Yields: Module: a module in the network Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.modules()): ... print(idx, '->', m) 0 -> Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) 1 -> Linear(in_features=2, out_features=2, bias=True) modules(self) -> Iterator[ForwardRef('Module')] mtia Move all model parameters and buffers to the MTIA. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on MTIA while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self mtia(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T named_buffers Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself. Args: prefix (str): prefix to prepend to all buffer names. recurse (bool, optional): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Defaults to True. remove_duplicate (bool, optional): whether to remove the duplicated buffers in the result. Defaults to True. Yields: (str, torch.Tensor): Tuple containing the name and buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, buf in self.named_buffers(): >>> if name in ['running_var']: >>> print(buf.size()) named_buffers(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.Tensor]] named_children Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself. Yields: (str, Module): Tuple containing a name and child module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, module in model.named_children(): >>> if name in ['conv4', 'conv5']: >>> print(module) named_children(self) -> Iterator[Tuple[str, ForwardRef('Module')]] named_modules Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself. Args: memo: a memo to store the set of modules already added to the result prefix: a prefix that will be added to the name of the module remove_duplicate: whether to remove the duplicated module instances in the result or not Yields: (str, Module): Tuple of name and module Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.named_modules()): ... print(idx, '->', m) 0 -> ('', Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) )) 1 -> ('0', Linear(in_features=2, out_features=2, bias=True)) named_modules(self, memo: Optional[Set[ForwardRef('Module')]] = None, prefix: str = '', remove_duplicate: bool = True) named_parameters Return an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself. Args: prefix (str): prefix to prepend to all parameter names. recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. remove_duplicate (bool, optional): whether to remove the duplicated parameters in the result. Defaults to True. Yields: (str, Parameter): Tuple containing the name and parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, param in self.named_parameters(): >>> if name in ['bias']: >>> print(param.size()) named_parameters(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.nn.parameter.Parameter]] parameters Return an iterator over module parameters. This is typically passed to an optimizer. Args: recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. Yields: Parameter: module parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for param in model.parameters(): >>> print(type(param), param.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) parameters(self, recurse: bool = True) -> Iterator[torch.nn.parameter.Parameter] prepare_inputs_for_generation Prepare inputs for generation tasks. prepare_inputs_for_generation(self, input_ids, past_key_values=None, **kwargs) register_backward_hook Register a backward hook on the module. This function is deprecated in favor of :meth: ~torch.nn.Module.register_full_backward_hook and the behavior of this function will change in future versions. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]]) -> torch.utils.hooks.RemovableHandle register_buffer Add a buffer to the module. This is typically used to register a buffer that should not to be considered a model parameter. For example, BatchNorm's running_mean is not a parameter, but is part of the module's state. Buffers, by default, are persistent and will be saved alongside parameters. This behavior can be changed by setting :attr: persistent to False . The only difference between a persistent buffer and a non-persistent buffer is that the latter will not be a part of this module's :attr: state_dict . Buffers can be accessed as attributes using given names. Args: name (str): name of the buffer. The buffer can be accessed from this module using the given name tensor (Tensor or None): buffer to be registered. If None , then operations that run on buffers, such as :attr: cuda , are ignored. If None , the buffer is not included in the module's :attr: state_dict . persistent (bool): whether the buffer is part of this module's :attr: state_dict . Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> self.register_buffer('running_mean', torch.zeros(num_features)) register_buffer(self, name: str, tensor: Optional[torch.Tensor], persistent: bool = True) -> None register_forward_hook Register a forward hook on the module. The hook will be called every time after :func: forward has computed an output. If with_kwargs is False or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the output. It can modify the input inplace but it will not have effect on forward since this is called after :func: forward is called. The hook should have the following signature:: hook(module, args, output) -> None or modified output If with_kwargs is True , the forward hook will be passed the kwargs given to the forward function and be expected to return the output possibly modified. The hook should have the following signature:: hook(module, args, kwargs, output) -> None or modified output Args: hook (Callable): The user defined hook to be registered. prepend (bool): If True , the provided hook will be fired before all existing forward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward hooks on this :class: torch.nn.modules.Module . Note that global forward hooks registered with :func: register_module_forward_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If True , the hook will be passed the kwargs given to the forward function. Default: False always_call (bool): If True the hook will be run regardless of whether an exception is raised while calling the Module. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...], Any], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any], Any], Optional[Any]]], *, prepend: bool = False, with_kwargs: bool = False, always_call: bool = False) -> torch.utils.hooks.RemovableHandle register_forward_pre_hook Register a forward pre-hook on the module. The hook will be called every time before :func: forward is invoked. If with_kwargs is false or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the input. User can either return a tuple or a single modified value in the hook. We will wrap the value into a tuple if a single value is returned (unless that value is already a tuple). The hook should have the following signature:: hook(module, args) -> None or modified input If with_kwargs is true, the forward pre-hook will be passed the kwargs given to the forward function. And if the hook modifies the input, both the args and kwargs should be returned. The hook should have the following signature:: hook(module, args, kwargs) -> None or a tuple of modified input and kwargs Args: hook (Callable): The user defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing forward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward_pre hooks on this :class: torch.nn.modules.Module . Note that global forward_pre hooks registered with :func: register_module_forward_pre_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If true, the hook will be passed the kwargs given to the forward function. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_pre_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...]], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any]], Optional[Tuple[Any, Dict[str, Any]]]]], *, prepend: bool = False, with_kwargs: bool = False) -> torch.utils.hooks.RemovableHandle register_full_backward_hook Register a backward hook on the module. The hook will be called every time the gradients with respect to a module are computed, i.e. the hook will execute if and only if the gradients with respect to module outputs are computed. The hook should have the following signature:: hook(module, grad_input, grad_output) -> tuple(Tensor) or None The :attr: grad_input and :attr: grad_output are tuples that contain the gradients with respect to the inputs and outputs respectively. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the input that will be used in place of :attr: grad_input in subsequent computations. :attr: grad_input will only correspond to the inputs given as positional arguments and all kwarg arguments are ignored. Entries in :attr: grad_input and :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs or outputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward hooks on this :class: torch.nn.modules.Module . Note that global backward hooks registered with :func: register_module_full_backward_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle register_full_backward_pre_hook Register a backward pre-hook on the module. The hook will be called every time the gradients for the module are computed. The hook should have the following signature:: hook(module, grad_output) -> tuple[Tensor] or None The :attr: grad_output is a tuple. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the output that will be used in place of :attr: grad_output in subsequent computations. Entries in :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward_pre hooks on this :class: torch.nn.modules.Module . Note that global backward_pre hooks registered with :func: register_module_full_backward_pre_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_pre_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle register_load_state_dict_post_hook Register a post-hook to be run after module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, incompatible_keys) -> None The module argument is the current module that this hook is registered on, and the incompatible_keys argument is a NamedTuple consisting of attributes missing_keys and unexpected_keys . missing_keys is a list of str containing the missing keys and unexpected_keys is a list of str containing the unexpected keys. The given incompatible_keys can be modified inplace if needed. Note that the checks performed when calling :func: load_state_dict with strict=True are affected by modifications the hook makes to missing_keys or unexpected_keys , as expected. Additions to either set of keys will result in an error being thrown when strict=True , and clearing out both missing and unexpected keys will avoid an error. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_load_state_dict_post_hook(self, hook) register_load_state_dict_pre_hook Register a pre-hook to be run before module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs) -> None # noqa: B950 Arguments: hook (Callable): Callable hook that will be invoked before loading the state dict. register_load_state_dict_pre_hook(self, hook) register_module Alias for :func: add_module . register_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None register_parameter Add a parameter to the module. The parameter can be accessed as an attribute using given name. Args: name (str): name of the parameter. The parameter can be accessed from this module using the given name param (Parameter or None): parameter to be added to the module. If None , then operations that run on parameters, such as :attr: cuda , are ignored. If None , the parameter is not included in the module's :attr: state_dict . register_parameter(self, name: str, param: Optional[torch.nn.parameter.Parameter]) -> None register_state_dict_post_hook Register a post-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, state_dict, prefix, local_metadata) -> None The registered hooks can modify the state_dict inplace. register_state_dict_post_hook(self, hook) register_state_dict_pre_hook Register a pre-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, prefix, keep_vars) -> None The registered hooks can be used to perform pre-processing before the state_dict call is made. register_state_dict_pre_hook(self, hook) requires_grad_ Change if autograd should record operations on parameters in this module. This method sets the parameters' :attr: requires_grad attributes in-place. This method is helpful for freezing part of the module for finetuning or training parts of a model individually (e.g., GAN training). See :ref: locally-disable-grad-doc for a comparison between .requires_grad_() and several similar mechanisms that may be confused with it. Args: requires_grad (bool): whether autograd should record operations on parameters in this module. Default: True . Returns: Module: self requires_grad_(self: ~T, requires_grad: bool = True) -> ~T set_extra_state Set extra state contained in the loaded state_dict . This function is called from :func: load_state_dict to handle any extra state found within the state_dict . Implement this function and a corresponding :func: get_extra_state for your module if you need to store extra state within its state_dict . Args: state (dict): Extra state from the state_dict set_extra_state(self, state: Any) -> None set_input_embeddings set_input_embeddings(self, value) set_submodule Set the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To overide the Conv2d with a new submodule Linear , you would call set_submodule(\"net_b.net_c.conv\", nn.Linear(33, 16)) . Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) module: The module to set the submodule to. Raises: ValueError: If the target string is empty AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module set_submodule(self, target: str, module: 'Module') -> None share_memory See :meth: torch.Tensor.share_memory_ . share_memory(self: ~T) -> ~T state_dict Return a dictionary containing references to the whole state of the module. Both parameters and persistent buffers (e.g. running averages) are included. Keys are corresponding parameter and buffer names. Parameters and buffers set to None are not included. .. note:: The returned object is a shallow copy. It contains references to the module's parameters and buffers. .. warning:: Currently state_dict() also accepts positional arguments for destination , prefix and keep_vars in order. However, this is being deprecated and keyword arguments will be enforced in future releases. .. warning:: Please avoid the use of argument destination as it is not designed for end-users. Args: destination (dict, optional): If provided, the state of module will be updated into the dict and the same object is returned. Otherwise, an OrderedDict will be created and returned. Default: None . prefix (str, optional): a prefix added to parameter and buffer names to compose the keys in state_dict. Default: '' . keep_vars (bool, optional): by default the :class: ~torch.Tensor s returned in the state dict are detached from autograd. If it's set to True , detaching will not be performed. Default: False . Returns: dict: a dictionary containing a whole state of the module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> module.state_dict().keys() ['bias', 'weight'] state_dict(self, *args, destination=None, prefix='', keep_vars=False) to Move and/or cast the parameters and buffers. This can be called as .. function:: to(device=None, dtype=None, non_blocking=False) :noindex: .. function:: to(dtype, non_blocking=False) :noindex: .. function:: to(tensor, non_blocking=False) :noindex: .. function:: to(memory_format=torch.channels_last) :noindex: Its signature is similar to :meth: torch.Tensor.to , but only accepts floating point or complex :attr: dtype \\ s. In addition, this method will only cast the floating point or complex parameters and buffers to :attr: dtype (if given). The integral parameters and buffers will be moved :attr: device , if that is given, but with dtypes unchanged. When :attr: non_blocking is set, it tries to convert/move asynchronously with respect to the host if possible, e.g., moving CPU Tensors with pinned memory to CUDA devices. See below for examples. .. note:: This method modifies the module in-place. Args: device (:class: torch.device ): the desired device of the parameters and buffers in this module dtype (:class: torch.dtype ): the desired floating point or complex dtype of the parameters and buffers in this module tensor (torch.Tensor): Tensor whose dtype and device are the desired dtype and device for all parameters and buffers in this module memory_format (:class: torch.memory_format ): the desired memory format for 4D parameters and buffers in this module (keyword only argument) Returns: Module: self Examples:: >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\") >>> linear = nn.Linear(2, 2) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]]) >>> linear.to(torch.double) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]], dtype=torch.float64) >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA1) >>> gpu1 = torch.device(\"cuda:1\") >>> linear.to(gpu1, dtype=torch.half, non_blocking=True) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1') >>> cpu = torch.device(\"cpu\") >>> linear.to(cpu) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16) >>> linear = nn.Linear(2, 2, bias=None).to(torch.cdouble) >>> linear.weight Parameter containing: tensor([[ 0.3741+0.j, 0.2382+0.j], [ 0.5593+0.j, -0.4443+0.j]], dtype=torch.complex128) >>> linear(torch.ones(3, 2, dtype=torch.cdouble)) tensor([[0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j]], dtype=torch.complex128) to(self, *args, **kwargs) to_empty Move the parameters and buffers to the specified device without copying storage. Args: device (:class: torch.device ): The desired device of the parameters and buffers in this module. recurse (bool): Whether parameters and buffers of submodules should be recursively moved to the specified device. Returns: Module: self to_empty(self: ~T, *, device: Union[int, str, torch.device, NoneType], recurse: bool = True) -> ~T train Set the module in training mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e., whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. Args: mode (bool): whether to set training mode ( True ) or evaluation mode ( False ). Default: True . Returns: Module: self train(self: ~T, mode: bool = True) -> ~T type Casts all parameters and buffers to :attr: dst_type . .. note:: This method modifies the module in-place. Args: dst_type (type or string): the desired type Returns: Module: self type(self: ~T, dst_type: Union[torch.dtype, str]) -> ~T xpu Move all model parameters and buffers to the XPU. This also makes associated parameters and buffers different objects. So it should be called before constructing optimizer if the module will live on XPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self xpu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T zero_grad Reset gradients of all model parameters. See similar function under :class: torch.optim.Optimizer for more context. Args: set_to_none (bool): instead of setting to zero, set the grads to None. See :meth: torch.optim.Optimizer.zero_grad for details. zero_grad(self, set_to_none: bool = True) -> None EdgeFormerEmbeddings Methods __init__ __init__(self, config) add_module Add a child module to the current module. The module can be accessed as an attribute using the given name. Args: name (str): name of the child module. The child module can be accessed from this module using the given name module (Module): child module to be added to the module. add_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None apply Apply fn recursively to every submodule (as returned by .children() ) as well as self. Typical use includes initializing the parameters of a model (see also :ref: nn-init-doc ). Args: fn (:class: Module -> None): function to be applied to each submodule Returns: Module: self Example:: >>> @torch.no_grad() >>> def init_weights(m): >>> print(m) >>> if type(m) == nn.Linear: >>> m.weight.fill_(1.0) >>> print(m.weight) >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2)) >>> net.apply(init_weights) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) apply(self: ~T, fn: Callable[[ForwardRef('Module')], NoneType]) -> ~T bfloat16 Casts all floating point parameters and buffers to bfloat16 datatype. .. note:: This method modifies the module in-place. Returns: Module: self bfloat16(self: ~T) -> ~T buffers Return an iterator over module buffers. Args: recurse (bool): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Yields: torch.Tensor: module buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for buf in model.buffers(): >>> print(type(buf), buf.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) buffers(self, recurse: bool = True) -> Iterator[torch.Tensor] children Return an iterator over immediate children modules. Yields: Module: a child module children(self) -> Iterator[ForwardRef('Module')] compile Compile this Module's forward using :func: torch.compile . This Module's __call__ method is compiled and all arguments are passed as-is to :func: torch.compile . See :func: torch.compile for details on the arguments for this function. compile(self, *args, **kwargs) cpu Move all model parameters and buffers to the CPU. .. note:: This method modifies the module in-place. Returns: Module: self cpu(self: ~T) -> ~T cuda Move all model parameters and buffers to the GPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on GPU while being optimized. .. note:: This method modifies the module in-place. Args: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self cuda(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T double Casts all floating point parameters and buffers to double datatype. .. note:: This method modifies the module in-place. Returns: Module: self double(self: ~T) -> ~T eval Set the module in evaluation mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e. whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. This is equivalent with :meth: self.train(False) <torch.nn.Module.train> . See :ref: locally-disable-grad-doc for a comparison between .eval() and several similar mechanisms that may be confused with it. Returns: Module: self eval(self: ~T) -> ~T extra_repr Return the extra representation of the module. To print customized extra information, you should re-implement this method in your own modules. Both single-line and multi-line strings are acceptable. extra_repr(self) -> str float Casts all floating point parameters and buffers to float datatype. .. note:: This method modifies the module in-place. Returns: Module: self float(self: ~T) -> ~T forward forward(self, input_ids=None, position_ids=None, inputs_embeds=None) get_buffer Return the buffer given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the buffer to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.Tensor: The buffer referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not a buffer get_buffer(self, target: str) -> 'Tensor' get_extra_state Return any extra state to include in the module's state_dict. Implement this and a corresponding :func: set_extra_state for your module if you need to store extra state. This function is called when building the module's state_dict() . Note that extra state should be picklable to ensure working serialization of the state_dict. We only provide backwards compatibility guarantees for serializing Tensors; other objects may break backwards compatibility if their serialized pickled form changes. Returns: object: Any extra state to store in the module's state_dict get_extra_state(self) -> Any get_parameter Return the parameter given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the Parameter to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.nn.Parameter: The Parameter referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Parameter get_parameter(self, target: str) -> 'Parameter' get_submodule Return the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A which has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To check whether or not we have the linear submodule, we would call get_submodule(\"net_b.linear\") . To check whether we have the conv submodule, we would call get_submodule(\"net_b.net_c.conv\") . The runtime of get_submodule is bounded by the degree of module nesting in target . A query against named_modules achieves the same result, but it is O(N) in the number of transitive modules. So, for a simple check to see if some submodule exists, get_submodule should always be used. Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) Returns: torch.nn.Module: The submodule referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module get_submodule(self, target: str) -> 'Module' half Casts all floating point parameters and buffers to half datatype. .. note:: This method modifies the module in-place. Returns: Module: self half(self: ~T) -> ~T ipu Move all model parameters and buffers to the IPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on IPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self ipu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T load_state_dict Copy parameters and buffers from :attr: state_dict into this module and its descendants. If :attr: strict is True , then the keys of :attr: state_dict must exactly match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. .. warning:: If :attr: assign is True the optimizer must be created after the call to :attr: load_state_dict unless :func: ~torch.__future__.get_swap_module_params_on_conversion is True . Args: state_dict (dict): a dict containing parameters and persistent buffers. strict (bool, optional): whether to strictly enforce that the keys in :attr: state_dict match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. Default: True assign (bool, optional): When set to False , the properties of the tensors in the current module are preserved whereas setting it to True preserves properties of the Tensors in the state dict. The only exception is the requires_grad field of :class: ~torch.nn.Parameter s for which the value from the module is preserved. Default: False Returns: NamedTuple with missing_keys and unexpected_keys fields: * missing_keys is a list of str containing any keys that are expected by this module but missing from the provided state_dict . * unexpected_keys is a list of str containing the keys that are not expected by this module but present in the provided state_dict . Note: If a parameter or buffer is registered as None and its corresponding key exists in :attr: state_dict , :meth: load_state_dict will raise a RuntimeError . load_state_dict(self, state_dict: Mapping[str, Any], strict: bool = True, assign: bool = False) modules Return an iterator over all modules in the network. Yields: Module: a module in the network Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.modules()): ... print(idx, '->', m) 0 -> Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) 1 -> Linear(in_features=2, out_features=2, bias=True) modules(self) -> Iterator[ForwardRef('Module')] mtia Move all model parameters and buffers to the MTIA. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on MTIA while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self mtia(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T named_buffers Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself. Args: prefix (str): prefix to prepend to all buffer names. recurse (bool, optional): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Defaults to True. remove_duplicate (bool, optional): whether to remove the duplicated buffers in the result. Defaults to True. Yields: (str, torch.Tensor): Tuple containing the name and buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, buf in self.named_buffers(): >>> if name in ['running_var']: >>> print(buf.size()) named_buffers(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.Tensor]] named_children Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself. Yields: (str, Module): Tuple containing a name and child module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, module in model.named_children(): >>> if name in ['conv4', 'conv5']: >>> print(module) named_children(self) -> Iterator[Tuple[str, ForwardRef('Module')]] named_modules Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself. Args: memo: a memo to store the set of modules already added to the result prefix: a prefix that will be added to the name of the module remove_duplicate: whether to remove the duplicated module instances in the result or not Yields: (str, Module): Tuple of name and module Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.named_modules()): ... print(idx, '->', m) 0 -> ('', Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) )) 1 -> ('0', Linear(in_features=2, out_features=2, bias=True)) named_modules(self, memo: Optional[Set[ForwardRef('Module')]] = None, prefix: str = '', remove_duplicate: bool = True) named_parameters Return an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself. Args: prefix (str): prefix to prepend to all parameter names. recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. remove_duplicate (bool, optional): whether to remove the duplicated parameters in the result. Defaults to True. Yields: (str, Parameter): Tuple containing the name and parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, param in self.named_parameters(): >>> if name in ['bias']: >>> print(param.size()) named_parameters(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.nn.parameter.Parameter]] parameters Return an iterator over module parameters. This is typically passed to an optimizer. Args: recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. Yields: Parameter: module parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for param in model.parameters(): >>> print(type(param), param.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) parameters(self, recurse: bool = True) -> Iterator[torch.nn.parameter.Parameter] register_backward_hook Register a backward hook on the module. This function is deprecated in favor of :meth: ~torch.nn.Module.register_full_backward_hook and the behavior of this function will change in future versions. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]]) -> torch.utils.hooks.RemovableHandle register_buffer Add a buffer to the module. This is typically used to register a buffer that should not to be considered a model parameter. For example, BatchNorm's running_mean is not a parameter, but is part of the module's state. Buffers, by default, are persistent and will be saved alongside parameters. This behavior can be changed by setting :attr: persistent to False . The only difference between a persistent buffer and a non-persistent buffer is that the latter will not be a part of this module's :attr: state_dict . Buffers can be accessed as attributes using given names. Args: name (str): name of the buffer. The buffer can be accessed from this module using the given name tensor (Tensor or None): buffer to be registered. If None , then operations that run on buffers, such as :attr: cuda , are ignored. If None , the buffer is not included in the module's :attr: state_dict . persistent (bool): whether the buffer is part of this module's :attr: state_dict . Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> self.register_buffer('running_mean', torch.zeros(num_features)) register_buffer(self, name: str, tensor: Optional[torch.Tensor], persistent: bool = True) -> None register_forward_hook Register a forward hook on the module. The hook will be called every time after :func: forward has computed an output. If with_kwargs is False or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the output. It can modify the input inplace but it will not have effect on forward since this is called after :func: forward is called. The hook should have the following signature:: hook(module, args, output) -> None or modified output If with_kwargs is True , the forward hook will be passed the kwargs given to the forward function and be expected to return the output possibly modified. The hook should have the following signature:: hook(module, args, kwargs, output) -> None or modified output Args: hook (Callable): The user defined hook to be registered. prepend (bool): If True , the provided hook will be fired before all existing forward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward hooks on this :class: torch.nn.modules.Module . Note that global forward hooks registered with :func: register_module_forward_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If True , the hook will be passed the kwargs given to the forward function. Default: False always_call (bool): If True the hook will be run regardless of whether an exception is raised while calling the Module. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...], Any], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any], Any], Optional[Any]]], *, prepend: bool = False, with_kwargs: bool = False, always_call: bool = False) -> torch.utils.hooks.RemovableHandle register_forward_pre_hook Register a forward pre-hook on the module. The hook will be called every time before :func: forward is invoked. If with_kwargs is false or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the input. User can either return a tuple or a single modified value in the hook. We will wrap the value into a tuple if a single value is returned (unless that value is already a tuple). The hook should have the following signature:: hook(module, args) -> None or modified input If with_kwargs is true, the forward pre-hook will be passed the kwargs given to the forward function. And if the hook modifies the input, both the args and kwargs should be returned. The hook should have the following signature:: hook(module, args, kwargs) -> None or a tuple of modified input and kwargs Args: hook (Callable): The user defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing forward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward_pre hooks on this :class: torch.nn.modules.Module . Note that global forward_pre hooks registered with :func: register_module_forward_pre_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If true, the hook will be passed the kwargs given to the forward function. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_pre_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...]], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any]], Optional[Tuple[Any, Dict[str, Any]]]]], *, prepend: bool = False, with_kwargs: bool = False) -> torch.utils.hooks.RemovableHandle register_full_backward_hook Register a backward hook on the module. The hook will be called every time the gradients with respect to a module are computed, i.e. the hook will execute if and only if the gradients with respect to module outputs are computed. The hook should have the following signature:: hook(module, grad_input, grad_output) -> tuple(Tensor) or None The :attr: grad_input and :attr: grad_output are tuples that contain the gradients with respect to the inputs and outputs respectively. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the input that will be used in place of :attr: grad_input in subsequent computations. :attr: grad_input will only correspond to the inputs given as positional arguments and all kwarg arguments are ignored. Entries in :attr: grad_input and :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs or outputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward hooks on this :class: torch.nn.modules.Module . Note that global backward hooks registered with :func: register_module_full_backward_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle register_full_backward_pre_hook Register a backward pre-hook on the module. The hook will be called every time the gradients for the module are computed. The hook should have the following signature:: hook(module, grad_output) -> tuple[Tensor] or None The :attr: grad_output is a tuple. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the output that will be used in place of :attr: grad_output in subsequent computations. Entries in :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward_pre hooks on this :class: torch.nn.modules.Module . Note that global backward_pre hooks registered with :func: register_module_full_backward_pre_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_pre_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle register_load_state_dict_post_hook Register a post-hook to be run after module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, incompatible_keys) -> None The module argument is the current module that this hook is registered on, and the incompatible_keys argument is a NamedTuple consisting of attributes missing_keys and unexpected_keys . missing_keys is a list of str containing the missing keys and unexpected_keys is a list of str containing the unexpected keys. The given incompatible_keys can be modified inplace if needed. Note that the checks performed when calling :func: load_state_dict with strict=True are affected by modifications the hook makes to missing_keys or unexpected_keys , as expected. Additions to either set of keys will result in an error being thrown when strict=True , and clearing out both missing and unexpected keys will avoid an error. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_load_state_dict_post_hook(self, hook) register_load_state_dict_pre_hook Register a pre-hook to be run before module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs) -> None # noqa: B950 Arguments: hook (Callable): Callable hook that will be invoked before loading the state dict. register_load_state_dict_pre_hook(self, hook) register_module Alias for :func: add_module . register_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None register_parameter Add a parameter to the module. The parameter can be accessed as an attribute using given name. Args: name (str): name of the parameter. The parameter can be accessed from this module using the given name param (Parameter or None): parameter to be added to the module. If None , then operations that run on parameters, such as :attr: cuda , are ignored. If None , the parameter is not included in the module's :attr: state_dict . register_parameter(self, name: str, param: Optional[torch.nn.parameter.Parameter]) -> None register_state_dict_post_hook Register a post-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, state_dict, prefix, local_metadata) -> None The registered hooks can modify the state_dict inplace. register_state_dict_post_hook(self, hook) register_state_dict_pre_hook Register a pre-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, prefix, keep_vars) -> None The registered hooks can be used to perform pre-processing before the state_dict call is made. register_state_dict_pre_hook(self, hook) requires_grad_ Change if autograd should record operations on parameters in this module. This method sets the parameters' :attr: requires_grad attributes in-place. This method is helpful for freezing part of the module for finetuning or training parts of a model individually (e.g., GAN training). See :ref: locally-disable-grad-doc for a comparison between .requires_grad_() and several similar mechanisms that may be confused with it. Args: requires_grad (bool): whether autograd should record operations on parameters in this module. Default: True . Returns: Module: self requires_grad_(self: ~T, requires_grad: bool = True) -> ~T set_extra_state Set extra state contained in the loaded state_dict . This function is called from :func: load_state_dict to handle any extra state found within the state_dict . Implement this function and a corresponding :func: get_extra_state for your module if you need to store extra state within its state_dict . Args: state (dict): Extra state from the state_dict set_extra_state(self, state: Any) -> None set_submodule Set the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To overide the Conv2d with a new submodule Linear , you would call set_submodule(\"net_b.net_c.conv\", nn.Linear(33, 16)) . Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) module: The module to set the submodule to. Raises: ValueError: If the target string is empty AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module set_submodule(self, target: str, module: 'Module') -> None share_memory See :meth: torch.Tensor.share_memory_ . share_memory(self: ~T) -> ~T state_dict Return a dictionary containing references to the whole state of the module. Both parameters and persistent buffers (e.g. running averages) are included. Keys are corresponding parameter and buffer names. Parameters and buffers set to None are not included. .. note:: The returned object is a shallow copy. It contains references to the module's parameters and buffers. .. warning:: Currently state_dict() also accepts positional arguments for destination , prefix and keep_vars in order. However, this is being deprecated and keyword arguments will be enforced in future releases. .. warning:: Please avoid the use of argument destination as it is not designed for end-users. Args: destination (dict, optional): If provided, the state of module will be updated into the dict and the same object is returned. Otherwise, an OrderedDict will be created and returned. Default: None . prefix (str, optional): a prefix added to parameter and buffer names to compose the keys in state_dict. Default: '' . keep_vars (bool, optional): by default the :class: ~torch.Tensor s returned in the state dict are detached from autograd. If it's set to True , detaching will not be performed. Default: False . Returns: dict: a dictionary containing a whole state of the module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> module.state_dict().keys() ['bias', 'weight'] state_dict(self, *args, destination=None, prefix='', keep_vars=False) to Move and/or cast the parameters and buffers. This can be called as .. function:: to(device=None, dtype=None, non_blocking=False) :noindex: .. function:: to(dtype, non_blocking=False) :noindex: .. function:: to(tensor, non_blocking=False) :noindex: .. function:: to(memory_format=torch.channels_last) :noindex: Its signature is similar to :meth: torch.Tensor.to , but only accepts floating point or complex :attr: dtype \\ s. In addition, this method will only cast the floating point or complex parameters and buffers to :attr: dtype (if given). The integral parameters and buffers will be moved :attr: device , if that is given, but with dtypes unchanged. When :attr: non_blocking is set, it tries to convert/move asynchronously with respect to the host if possible, e.g., moving CPU Tensors with pinned memory to CUDA devices. See below for examples. .. note:: This method modifies the module in-place. Args: device (:class: torch.device ): the desired device of the parameters and buffers in this module dtype (:class: torch.dtype ): the desired floating point or complex dtype of the parameters and buffers in this module tensor (torch.Tensor): Tensor whose dtype and device are the desired dtype and device for all parameters and buffers in this module memory_format (:class: torch.memory_format ): the desired memory format for 4D parameters and buffers in this module (keyword only argument) Returns: Module: self Examples:: >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\") >>> linear = nn.Linear(2, 2) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]]) >>> linear.to(torch.double) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]], dtype=torch.float64) >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA1) >>> gpu1 = torch.device(\"cuda:1\") >>> linear.to(gpu1, dtype=torch.half, non_blocking=True) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1') >>> cpu = torch.device(\"cpu\") >>> linear.to(cpu) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16) >>> linear = nn.Linear(2, 2, bias=None).to(torch.cdouble) >>> linear.weight Parameter containing: tensor([[ 0.3741+0.j, 0.2382+0.j], [ 0.5593+0.j, -0.4443+0.j]], dtype=torch.complex128) >>> linear(torch.ones(3, 2, dtype=torch.cdouble)) tensor([[0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j]], dtype=torch.complex128) to(self, *args, **kwargs) to_empty Move the parameters and buffers to the specified device without copying storage. Args: device (:class: torch.device ): The desired device of the parameters and buffers in this module. recurse (bool): Whether parameters and buffers of submodules should be recursively moved to the specified device. Returns: Module: self to_empty(self: ~T, *, device: Union[int, str, torch.device, NoneType], recurse: bool = True) -> ~T train Set the module in training mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e., whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. Args: mode (bool): whether to set training mode ( True ) or evaluation mode ( False ). Default: True . Returns: Module: self train(self: ~T, mode: bool = True) -> ~T type Casts all parameters and buffers to :attr: dst_type . .. note:: This method modifies the module in-place. Args: dst_type (type or string): the desired type Returns: Module: self type(self: ~T, dst_type: Union[torch.dtype, str]) -> ~T xpu Move all model parameters and buffers to the XPU. This also makes associated parameters and buffers different objects. So it should be called before constructing optimizer if the module will live on XPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self xpu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T zero_grad Reset gradients of all model parameters. See similar function under :class: torch.optim.Optimizer for more context. Args: set_to_none (bool): instead of setting to zero, set the grads to None. See :meth: torch.optim.Optimizer.zero_grad for details. zero_grad(self, set_to_none: bool = True) -> None EdgeFormerLMHead Methods __init__ __init__(self, config) add_module Add a child module to the current module. The module can be accessed as an attribute using the given name. Args: name (str): name of the child module. The child module can be accessed from this module using the given name module (Module): child module to be added to the module. add_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None apply Apply fn recursively to every submodule (as returned by .children() ) as well as self. Typical use includes initializing the parameters of a model (see also :ref: nn-init-doc ). Args: fn (:class: Module -> None): function to be applied to each submodule Returns: Module: self Example:: >>> @torch.no_grad() >>> def init_weights(m): >>> print(m) >>> if type(m) == nn.Linear: >>> m.weight.fill_(1.0) >>> print(m.weight) >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2)) >>> net.apply(init_weights) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) apply(self: ~T, fn: Callable[[ForwardRef('Module')], NoneType]) -> ~T bfloat16 Casts all floating point parameters and buffers to bfloat16 datatype. .. note:: This method modifies the module in-place. Returns: Module: self bfloat16(self: ~T) -> ~T buffers Return an iterator over module buffers. Args: recurse (bool): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Yields: torch.Tensor: module buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for buf in model.buffers(): >>> print(type(buf), buf.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) buffers(self, recurse: bool = True) -> Iterator[torch.Tensor] children Return an iterator over immediate children modules. Yields: Module: a child module children(self) -> Iterator[ForwardRef('Module')] compile Compile this Module's forward using :func: torch.compile . This Module's __call__ method is compiled and all arguments are passed as-is to :func: torch.compile . See :func: torch.compile for details on the arguments for this function. compile(self, *args, **kwargs) cpu Move all model parameters and buffers to the CPU. .. note:: This method modifies the module in-place. Returns: Module: self cpu(self: ~T) -> ~T cuda Move all model parameters and buffers to the GPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on GPU while being optimized. .. note:: This method modifies the module in-place. Args: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self cuda(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T double Casts all floating point parameters and buffers to double datatype. .. note:: This method modifies the module in-place. Returns: Module: self double(self: ~T) -> ~T eval Set the module in evaluation mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e. whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. This is equivalent with :meth: self.train(False) <torch.nn.Module.train> . See :ref: locally-disable-grad-doc for a comparison between .eval() and several similar mechanisms that may be confused with it. Returns: Module: self eval(self: ~T) -> ~T extra_repr Return the extra representation of the module. To print customized extra information, you should re-implement this method in your own modules. Both single-line and multi-line strings are acceptable. extra_repr(self) -> str float Casts all floating point parameters and buffers to float datatype. .. note:: This method modifies the module in-place. Returns: Module: self float(self: ~T) -> ~T forward forward(self, hidden_states) get_buffer Return the buffer given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the buffer to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.Tensor: The buffer referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not a buffer get_buffer(self, target: str) -> 'Tensor' get_extra_state Return any extra state to include in the module's state_dict. Implement this and a corresponding :func: set_extra_state for your module if you need to store extra state. This function is called when building the module's state_dict() . Note that extra state should be picklable to ensure working serialization of the state_dict. We only provide backwards compatibility guarantees for serializing Tensors; other objects may break backwards compatibility if their serialized pickled form changes. Returns: object: Any extra state to store in the module's state_dict get_extra_state(self) -> Any get_parameter Return the parameter given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the Parameter to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.nn.Parameter: The Parameter referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Parameter get_parameter(self, target: str) -> 'Parameter' get_submodule Return the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A which has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To check whether or not we have the linear submodule, we would call get_submodule(\"net_b.linear\") . To check whether we have the conv submodule, we would call get_submodule(\"net_b.net_c.conv\") . The runtime of get_submodule is bounded by the degree of module nesting in target . A query against named_modules achieves the same result, but it is O(N) in the number of transitive modules. So, for a simple check to see if some submodule exists, get_submodule should always be used. Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) Returns: torch.nn.Module: The submodule referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module get_submodule(self, target: str) -> 'Module' half Casts all floating point parameters and buffers to half datatype. .. note:: This method modifies the module in-place. Returns: Module: self half(self: ~T) -> ~T ipu Move all model parameters and buffers to the IPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on IPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self ipu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T load_state_dict Copy parameters and buffers from :attr: state_dict into this module and its descendants. If :attr: strict is True , then the keys of :attr: state_dict must exactly match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. .. warning:: If :attr: assign is True the optimizer must be created after the call to :attr: load_state_dict unless :func: ~torch.__future__.get_swap_module_params_on_conversion is True . Args: state_dict (dict): a dict containing parameters and persistent buffers. strict (bool, optional): whether to strictly enforce that the keys in :attr: state_dict match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. Default: True assign (bool, optional): When set to False , the properties of the tensors in the current module are preserved whereas setting it to True preserves properties of the Tensors in the state dict. The only exception is the requires_grad field of :class: ~torch.nn.Parameter s for which the value from the module is preserved. Default: False Returns: NamedTuple with missing_keys and unexpected_keys fields: * missing_keys is a list of str containing any keys that are expected by this module but missing from the provided state_dict . * unexpected_keys is a list of str containing the keys that are not expected by this module but present in the provided state_dict . Note: If a parameter or buffer is registered as None and its corresponding key exists in :attr: state_dict , :meth: load_state_dict will raise a RuntimeError . load_state_dict(self, state_dict: Mapping[str, Any], strict: bool = True, assign: bool = False) modules Return an iterator over all modules in the network. Yields: Module: a module in the network Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.modules()): ... print(idx, '->', m) 0 -> Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) 1 -> Linear(in_features=2, out_features=2, bias=True) modules(self) -> Iterator[ForwardRef('Module')] mtia Move all model parameters and buffers to the MTIA. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on MTIA while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self mtia(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T named_buffers Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself. Args: prefix (str): prefix to prepend to all buffer names. recurse (bool, optional): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Defaults to True. remove_duplicate (bool, optional): whether to remove the duplicated buffers in the result. Defaults to True. Yields: (str, torch.Tensor): Tuple containing the name and buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, buf in self.named_buffers(): >>> if name in ['running_var']: >>> print(buf.size()) named_buffers(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.Tensor]] named_children Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself. Yields: (str, Module): Tuple containing a name and child module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, module in model.named_children(): >>> if name in ['conv4', 'conv5']: >>> print(module) named_children(self) -> Iterator[Tuple[str, ForwardRef('Module')]] named_modules Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself. Args: memo: a memo to store the set of modules already added to the result prefix: a prefix that will be added to the name of the module remove_duplicate: whether to remove the duplicated module instances in the result or not Yields: (str, Module): Tuple of name and module Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.named_modules()): ... print(idx, '->', m) 0 -> ('', Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) )) 1 -> ('0', Linear(in_features=2, out_features=2, bias=True)) named_modules(self, memo: Optional[Set[ForwardRef('Module')]] = None, prefix: str = '', remove_duplicate: bool = True) named_parameters Return an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself. Args: prefix (str): prefix to prepend to all parameter names. recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. remove_duplicate (bool, optional): whether to remove the duplicated parameters in the result. Defaults to True. Yields: (str, Parameter): Tuple containing the name and parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, param in self.named_parameters(): >>> if name in ['bias']: >>> print(param.size()) named_parameters(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.nn.parameter.Parameter]] parameters Return an iterator over module parameters. This is typically passed to an optimizer. Args: recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. Yields: Parameter: module parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for param in model.parameters(): >>> print(type(param), param.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) parameters(self, recurse: bool = True) -> Iterator[torch.nn.parameter.Parameter] register_backward_hook Register a backward hook on the module. This function is deprecated in favor of :meth: ~torch.nn.Module.register_full_backward_hook and the behavior of this function will change in future versions. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]]) -> torch.utils.hooks.RemovableHandle register_buffer Add a buffer to the module. This is typically used to register a buffer that should not to be considered a model parameter. For example, BatchNorm's running_mean is not a parameter, but is part of the module's state. Buffers, by default, are persistent and will be saved alongside parameters. This behavior can be changed by setting :attr: persistent to False . The only difference between a persistent buffer and a non-persistent buffer is that the latter will not be a part of this module's :attr: state_dict . Buffers can be accessed as attributes using given names. Args: name (str): name of the buffer. The buffer can be accessed from this module using the given name tensor (Tensor or None): buffer to be registered. If None , then operations that run on buffers, such as :attr: cuda , are ignored. If None , the buffer is not included in the module's :attr: state_dict . persistent (bool): whether the buffer is part of this module's :attr: state_dict . Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> self.register_buffer('running_mean', torch.zeros(num_features)) register_buffer(self, name: str, tensor: Optional[torch.Tensor], persistent: bool = True) -> None register_forward_hook Register a forward hook on the module. The hook will be called every time after :func: forward has computed an output. If with_kwargs is False or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the output. It can modify the input inplace but it will not have effect on forward since this is called after :func: forward is called. The hook should have the following signature:: hook(module, args, output) -> None or modified output If with_kwargs is True , the forward hook will be passed the kwargs given to the forward function and be expected to return the output possibly modified. The hook should have the following signature:: hook(module, args, kwargs, output) -> None or modified output Args: hook (Callable): The user defined hook to be registered. prepend (bool): If True , the provided hook will be fired before all existing forward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward hooks on this :class: torch.nn.modules.Module . Note that global forward hooks registered with :func: register_module_forward_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If True , the hook will be passed the kwargs given to the forward function. Default: False always_call (bool): If True the hook will be run regardless of whether an exception is raised while calling the Module. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...], Any], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any], Any], Optional[Any]]], *, prepend: bool = False, with_kwargs: bool = False, always_call: bool = False) -> torch.utils.hooks.RemovableHandle register_forward_pre_hook Register a forward pre-hook on the module. The hook will be called every time before :func: forward is invoked. If with_kwargs is false or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the input. User can either return a tuple or a single modified value in the hook. We will wrap the value into a tuple if a single value is returned (unless that value is already a tuple). The hook should have the following signature:: hook(module, args) -> None or modified input If with_kwargs is true, the forward pre-hook will be passed the kwargs given to the forward function. And if the hook modifies the input, both the args and kwargs should be returned. The hook should have the following signature:: hook(module, args, kwargs) -> None or a tuple of modified input and kwargs Args: hook (Callable): The user defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing forward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward_pre hooks on this :class: torch.nn.modules.Module . Note that global forward_pre hooks registered with :func: register_module_forward_pre_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If true, the hook will be passed the kwargs given to the forward function. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_pre_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...]], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any]], Optional[Tuple[Any, Dict[str, Any]]]]], *, prepend: bool = False, with_kwargs: bool = False) -> torch.utils.hooks.RemovableHandle register_full_backward_hook Register a backward hook on the module. The hook will be called every time the gradients with respect to a module are computed, i.e. the hook will execute if and only if the gradients with respect to module outputs are computed. The hook should have the following signature:: hook(module, grad_input, grad_output) -> tuple(Tensor) or None The :attr: grad_input and :attr: grad_output are tuples that contain the gradients with respect to the inputs and outputs respectively. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the input that will be used in place of :attr: grad_input in subsequent computations. :attr: grad_input will only correspond to the inputs given as positional arguments and all kwarg arguments are ignored. Entries in :attr: grad_input and :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs or outputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward hooks on this :class: torch.nn.modules.Module . Note that global backward hooks registered with :func: register_module_full_backward_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle register_full_backward_pre_hook Register a backward pre-hook on the module. The hook will be called every time the gradients for the module are computed. The hook should have the following signature:: hook(module, grad_output) -> tuple[Tensor] or None The :attr: grad_output is a tuple. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the output that will be used in place of :attr: grad_output in subsequent computations. Entries in :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward_pre hooks on this :class: torch.nn.modules.Module . Note that global backward_pre hooks registered with :func: register_module_full_backward_pre_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_pre_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle register_load_state_dict_post_hook Register a post-hook to be run after module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, incompatible_keys) -> None The module argument is the current module that this hook is registered on, and the incompatible_keys argument is a NamedTuple consisting of attributes missing_keys and unexpected_keys . missing_keys is a list of str containing the missing keys and unexpected_keys is a list of str containing the unexpected keys. The given incompatible_keys can be modified inplace if needed. Note that the checks performed when calling :func: load_state_dict with strict=True are affected by modifications the hook makes to missing_keys or unexpected_keys , as expected. Additions to either set of keys will result in an error being thrown when strict=True , and clearing out both missing and unexpected keys will avoid an error. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_load_state_dict_post_hook(self, hook) register_load_state_dict_pre_hook Register a pre-hook to be run before module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs) -> None # noqa: B950 Arguments: hook (Callable): Callable hook that will be invoked before loading the state dict. register_load_state_dict_pre_hook(self, hook) register_module Alias for :func: add_module . register_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None register_parameter Add a parameter to the module. The parameter can be accessed as an attribute using given name. Args: name (str): name of the parameter. The parameter can be accessed from this module using the given name param (Parameter or None): parameter to be added to the module. If None , then operations that run on parameters, such as :attr: cuda , are ignored. If None , the parameter is not included in the module's :attr: state_dict . register_parameter(self, name: str, param: Optional[torch.nn.parameter.Parameter]) -> None register_state_dict_post_hook Register a post-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, state_dict, prefix, local_metadata) -> None The registered hooks can modify the state_dict inplace. register_state_dict_post_hook(self, hook) register_state_dict_pre_hook Register a pre-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, prefix, keep_vars) -> None The registered hooks can be used to perform pre-processing before the state_dict call is made. register_state_dict_pre_hook(self, hook) requires_grad_ Change if autograd should record operations on parameters in this module. This method sets the parameters' :attr: requires_grad attributes in-place. This method is helpful for freezing part of the module for finetuning or training parts of a model individually (e.g., GAN training). See :ref: locally-disable-grad-doc for a comparison between .requires_grad_() and several similar mechanisms that may be confused with it. Args: requires_grad (bool): whether autograd should record operations on parameters in this module. Default: True . Returns: Module: self requires_grad_(self: ~T, requires_grad: bool = True) -> ~T set_extra_state Set extra state contained in the loaded state_dict . This function is called from :func: load_state_dict to handle any extra state found within the state_dict . Implement this function and a corresponding :func: get_extra_state for your module if you need to store extra state within its state_dict . Args: state (dict): Extra state from the state_dict set_extra_state(self, state: Any) -> None set_submodule Set the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To overide the Conv2d with a new submodule Linear , you would call set_submodule(\"net_b.net_c.conv\", nn.Linear(33, 16)) . Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) module: The module to set the submodule to. Raises: ValueError: If the target string is empty AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module set_submodule(self, target: str, module: 'Module') -> None share_memory See :meth: torch.Tensor.share_memory_ . share_memory(self: ~T) -> ~T state_dict Return a dictionary containing references to the whole state of the module. Both parameters and persistent buffers (e.g. running averages) are included. Keys are corresponding parameter and buffer names. Parameters and buffers set to None are not included. .. note:: The returned object is a shallow copy. It contains references to the module's parameters and buffers. .. warning:: Currently state_dict() also accepts positional arguments for destination , prefix and keep_vars in order. However, this is being deprecated and keyword arguments will be enforced in future releases. .. warning:: Please avoid the use of argument destination as it is not designed for end-users. Args: destination (dict, optional): If provided, the state of module will be updated into the dict and the same object is returned. Otherwise, an OrderedDict will be created and returned. Default: None . prefix (str, optional): a prefix added to parameter and buffer names to compose the keys in state_dict. Default: '' . keep_vars (bool, optional): by default the :class: ~torch.Tensor s returned in the state dict are detached from autograd. If it's set to True , detaching will not be performed. Default: False . Returns: dict: a dictionary containing a whole state of the module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> module.state_dict().keys() ['bias', 'weight'] state_dict(self, *args, destination=None, prefix='', keep_vars=False) to Move and/or cast the parameters and buffers. This can be called as .. function:: to(device=None, dtype=None, non_blocking=False) :noindex: .. function:: to(dtype, non_blocking=False) :noindex: .. function:: to(tensor, non_blocking=False) :noindex: .. function:: to(memory_format=torch.channels_last) :noindex: Its signature is similar to :meth: torch.Tensor.to , but only accepts floating point or complex :attr: dtype \\ s. In addition, this method will only cast the floating point or complex parameters and buffers to :attr: dtype (if given). The integral parameters and buffers will be moved :attr: device , if that is given, but with dtypes unchanged. When :attr: non_blocking is set, it tries to convert/move asynchronously with respect to the host if possible, e.g., moving CPU Tensors with pinned memory to CUDA devices. See below for examples. .. note:: This method modifies the module in-place. Args: device (:class: torch.device ): the desired device of the parameters and buffers in this module dtype (:class: torch.dtype ): the desired floating point or complex dtype of the parameters and buffers in this module tensor (torch.Tensor): Tensor whose dtype and device are the desired dtype and device for all parameters and buffers in this module memory_format (:class: torch.memory_format ): the desired memory format for 4D parameters and buffers in this module (keyword only argument) Returns: Module: self Examples:: >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\") >>> linear = nn.Linear(2, 2) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]]) >>> linear.to(torch.double) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]], dtype=torch.float64) >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA1) >>> gpu1 = torch.device(\"cuda:1\") >>> linear.to(gpu1, dtype=torch.half, non_blocking=True) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1') >>> cpu = torch.device(\"cpu\") >>> linear.to(cpu) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16) >>> linear = nn.Linear(2, 2, bias=None).to(torch.cdouble) >>> linear.weight Parameter containing: tensor([[ 0.3741+0.j, 0.2382+0.j], [ 0.5593+0.j, -0.4443+0.j]], dtype=torch.complex128) >>> linear(torch.ones(3, 2, dtype=torch.cdouble)) tensor([[0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j]], dtype=torch.complex128) to(self, *args, **kwargs) to_empty Move the parameters and buffers to the specified device without copying storage. Args: device (:class: torch.device ): The desired device of the parameters and buffers in this module. recurse (bool): Whether parameters and buffers of submodules should be recursively moved to the specified device. Returns: Module: self to_empty(self: ~T, *, device: Union[int, str, torch.device, NoneType], recurse: bool = True) -> ~T train Set the module in training mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e., whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. Args: mode (bool): whether to set training mode ( True ) or evaluation mode ( False ). Default: True . Returns: Module: self train(self: ~T, mode: bool = True) -> ~T type Casts all parameters and buffers to :attr: dst_type . .. note:: This method modifies the module in-place. Args: dst_type (type or string): the desired type Returns: Module: self type(self: ~T, dst_type: Union[torch.dtype, str]) -> ~T xpu Move all model parameters and buffers to the XPU. This also makes associated parameters and buffers different objects. So it should be called before constructing optimizer if the module will live on XPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self xpu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T zero_grad Reset gradients of all model parameters. See similar function under :class: torch.optim.Optimizer for more context. Args: set_to_none (bool): instead of setting to zero, set the grads to None. See :meth: torch.optim.Optimizer.zero_grad for details. zero_grad(self, set_to_none: bool = True) -> None","title":"src.model.edgeformer"},{"location":"src_model_edgeformer/#srcmodeledgeformer","text":"","title":"src.model.edgeformer"},{"location":"src_model_edgeformer/#classes","text":"","title":"Classes"},{"location":"src_model_edgeformer/#edgeformer","text":"","title":"EdgeFormer"},{"location":"src_model_edgeformer/#methods","text":"","title":"Methods"},{"location":"src_model_edgeformer/#__init__","text":"__init__(self, config)","title":"__init__"},{"location":"src_model_edgeformer/#add_module","text":"Add a child module to the current module. The module can be accessed as an attribute using the given name. Args: name (str): name of the child module. The child module can be accessed from this module using the given name module (Module): child module to be added to the module. add_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None","title":"add_module"},{"location":"src_model_edgeformer/#apply","text":"Apply fn recursively to every submodule (as returned by .children() ) as well as self. Typical use includes initializing the parameters of a model (see also :ref: nn-init-doc ). Args: fn (:class: Module -> None): function to be applied to each submodule Returns: Module: self Example:: >>> @torch.no_grad() >>> def init_weights(m): >>> print(m) >>> if type(m) == nn.Linear: >>> m.weight.fill_(1.0) >>> print(m.weight) >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2)) >>> net.apply(init_weights) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) apply(self: ~T, fn: Callable[[ForwardRef('Module')], NoneType]) -> ~T","title":"apply"},{"location":"src_model_edgeformer/#bfloat16","text":"Casts all floating point parameters and buffers to bfloat16 datatype. .. note:: This method modifies the module in-place. Returns: Module: self bfloat16(self: ~T) -> ~T","title":"bfloat16"},{"location":"src_model_edgeformer/#buffers","text":"Return an iterator over module buffers. Args: recurse (bool): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Yields: torch.Tensor: module buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for buf in model.buffers(): >>> print(type(buf), buf.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) buffers(self, recurse: bool = True) -> Iterator[torch.Tensor]","title":"buffers"},{"location":"src_model_edgeformer/#children","text":"Return an iterator over immediate children modules. Yields: Module: a child module children(self) -> Iterator[ForwardRef('Module')]","title":"children"},{"location":"src_model_edgeformer/#compile","text":"Compile this Module's forward using :func: torch.compile . This Module's __call__ method is compiled and all arguments are passed as-is to :func: torch.compile . See :func: torch.compile for details on the arguments for this function. compile(self, *args, **kwargs)","title":"compile"},{"location":"src_model_edgeformer/#continue_generation","text":"Helper method to continue generation with KV cache. Args: new_tokens: New token IDs to generate from (tensor of shape [batch_size, new_seq_length]) past_key_values: Past key-values from previous generation step (can be a string ID or tensor tuple) Returns: Dictionary with generated outputs continue_generation(self, new_tokens, past_key_values)","title":"continue_generation"},{"location":"src_model_edgeformer/#cpu","text":"Move all model parameters and buffers to the CPU. .. note:: This method modifies the module in-place. Returns: Module: self cpu(self: ~T) -> ~T","title":"cpu"},{"location":"src_model_edgeformer/#cuda","text":"Move all model parameters and buffers to the GPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on GPU while being optimized. .. note:: This method modifies the module in-place. Args: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self cuda(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"cuda"},{"location":"src_model_edgeformer/#double","text":"Casts all floating point parameters and buffers to double datatype. .. note:: This method modifies the module in-place. Returns: Module: self double(self: ~T) -> ~T","title":"double"},{"location":"src_model_edgeformer/#eval","text":"Set the module in evaluation mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e. whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. This is equivalent with :meth: self.train(False) <torch.nn.Module.train> . See :ref: locally-disable-grad-doc for a comparison between .eval() and several similar mechanisms that may be confused with it. Returns: Module: self eval(self: ~T) -> ~T","title":"eval"},{"location":"src_model_edgeformer/#extra_repr","text":"Return the extra representation of the module. To print customized extra information, you should re-implement this method in your own modules. Both single-line and multi-line strings are acceptable. extra_repr(self) -> str","title":"extra_repr"},{"location":"src_model_edgeformer/#float","text":"Casts all floating point parameters and buffers to float datatype. .. note:: This method modifies the module in-place. Returns: Module: self float(self: ~T) -> ~T","title":"float"},{"location":"src_model_edgeformer/#forward","text":"forward(self, input_ids=None, attention_mask=None, position_ids=None, inputs_embeds=None, past_key_values=None, labels=None, use_cache=None, output_attentions=None, output_hidden_states=None, return_dict=None, sliding_window_size=None)","title":"forward"},{"location":"src_model_edgeformer/#generate","text":"Generate text using the model. generate(self, input_ids, attention_mask=None, max_length=100, temperature=1.0, top_k=50, top_p=0.9, repetition_penalty=1.0, do_sample=True, num_return_sequences=1, pad_token_id=None, eos_token_id=None)","title":"generate"},{"location":"src_model_edgeformer/#get_buffer","text":"Return the buffer given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the buffer to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.Tensor: The buffer referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not a buffer get_buffer(self, target: str) -> 'Tensor'","title":"get_buffer"},{"location":"src_model_edgeformer/#get_extra_state","text":"Return any extra state to include in the module's state_dict. Implement this and a corresponding :func: set_extra_state for your module if you need to store extra state. This function is called when building the module's state_dict() . Note that extra state should be picklable to ensure working serialization of the state_dict. We only provide backwards compatibility guarantees for serializing Tensors; other objects may break backwards compatibility if their serialized pickled form changes. Returns: object: Any extra state to store in the module's state_dict get_extra_state(self) -> Any","title":"get_extra_state"},{"location":"src_model_edgeformer/#get_input_embeddings","text":"get_input_embeddings(self)","title":"get_input_embeddings"},{"location":"src_model_edgeformer/#get_parameter","text":"Return the parameter given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the Parameter to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.nn.Parameter: The Parameter referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Parameter get_parameter(self, target: str) -> 'Parameter'","title":"get_parameter"},{"location":"src_model_edgeformer/#get_submodule","text":"Return the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A which has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To check whether or not we have the linear submodule, we would call get_submodule(\"net_b.linear\") . To check whether we have the conv submodule, we would call get_submodule(\"net_b.net_c.conv\") . The runtime of get_submodule is bounded by the degree of module nesting in target . A query against named_modules achieves the same result, but it is O(N) in the number of transitive modules. So, for a simple check to see if some submodule exists, get_submodule should always be used. Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) Returns: torch.nn.Module: The submodule referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module get_submodule(self, target: str) -> 'Module'","title":"get_submodule"},{"location":"src_model_edgeformer/#half","text":"Casts all floating point parameters and buffers to half datatype. .. note:: This method modifies the module in-place. Returns: Module: self half(self: ~T) -> ~T","title":"half"},{"location":"src_model_edgeformer/#ipu","text":"Move all model parameters and buffers to the IPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on IPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self ipu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"ipu"},{"location":"src_model_edgeformer/#load_state_dict","text":"Copy parameters and buffers from :attr: state_dict into this module and its descendants. If :attr: strict is True , then the keys of :attr: state_dict must exactly match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. .. warning:: If :attr: assign is True the optimizer must be created after the call to :attr: load_state_dict unless :func: ~torch.__future__.get_swap_module_params_on_conversion is True . Args: state_dict (dict): a dict containing parameters and persistent buffers. strict (bool, optional): whether to strictly enforce that the keys in :attr: state_dict match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. Default: True assign (bool, optional): When set to False , the properties of the tensors in the current module are preserved whereas setting it to True preserves properties of the Tensors in the state dict. The only exception is the requires_grad field of :class: ~torch.nn.Parameter s for which the value from the module is preserved. Default: False Returns: NamedTuple with missing_keys and unexpected_keys fields: * missing_keys is a list of str containing any keys that are expected by this module but missing from the provided state_dict . * unexpected_keys is a list of str containing the keys that are not expected by this module but present in the provided state_dict . Note: If a parameter or buffer is registered as None and its corresponding key exists in :attr: state_dict , :meth: load_state_dict will raise a RuntimeError . load_state_dict(self, state_dict: Mapping[str, Any], strict: bool = True, assign: bool = False)","title":"load_state_dict"},{"location":"src_model_edgeformer/#modules","text":"Return an iterator over all modules in the network. Yields: Module: a module in the network Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.modules()): ... print(idx, '->', m) 0 -> Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) 1 -> Linear(in_features=2, out_features=2, bias=True) modules(self) -> Iterator[ForwardRef('Module')]","title":"modules"},{"location":"src_model_edgeformer/#mtia","text":"Move all model parameters and buffers to the MTIA. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on MTIA while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self mtia(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"mtia"},{"location":"src_model_edgeformer/#named_buffers","text":"Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself. Args: prefix (str): prefix to prepend to all buffer names. recurse (bool, optional): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Defaults to True. remove_duplicate (bool, optional): whether to remove the duplicated buffers in the result. Defaults to True. Yields: (str, torch.Tensor): Tuple containing the name and buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, buf in self.named_buffers(): >>> if name in ['running_var']: >>> print(buf.size()) named_buffers(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.Tensor]]","title":"named_buffers"},{"location":"src_model_edgeformer/#named_children","text":"Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself. Yields: (str, Module): Tuple containing a name and child module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, module in model.named_children(): >>> if name in ['conv4', 'conv5']: >>> print(module) named_children(self) -> Iterator[Tuple[str, ForwardRef('Module')]]","title":"named_children"},{"location":"src_model_edgeformer/#named_modules","text":"Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself. Args: memo: a memo to store the set of modules already added to the result prefix: a prefix that will be added to the name of the module remove_duplicate: whether to remove the duplicated module instances in the result or not Yields: (str, Module): Tuple of name and module Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.named_modules()): ... print(idx, '->', m) 0 -> ('', Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) )) 1 -> ('0', Linear(in_features=2, out_features=2, bias=True)) named_modules(self, memo: Optional[Set[ForwardRef('Module')]] = None, prefix: str = '', remove_duplicate: bool = True)","title":"named_modules"},{"location":"src_model_edgeformer/#named_parameters","text":"Return an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself. Args: prefix (str): prefix to prepend to all parameter names. recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. remove_duplicate (bool, optional): whether to remove the duplicated parameters in the result. Defaults to True. Yields: (str, Parameter): Tuple containing the name and parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, param in self.named_parameters(): >>> if name in ['bias']: >>> print(param.size()) named_parameters(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.nn.parameter.Parameter]]","title":"named_parameters"},{"location":"src_model_edgeformer/#parameters","text":"Return an iterator over module parameters. This is typically passed to an optimizer. Args: recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. Yields: Parameter: module parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for param in model.parameters(): >>> print(type(param), param.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) parameters(self, recurse: bool = True) -> Iterator[torch.nn.parameter.Parameter]","title":"parameters"},{"location":"src_model_edgeformer/#prepare_inputs_for_generation","text":"Prepare inputs for generation tasks. prepare_inputs_for_generation(self, input_ids, past_key_values=None, **kwargs)","title":"prepare_inputs_for_generation"},{"location":"src_model_edgeformer/#register_backward_hook","text":"Register a backward hook on the module. This function is deprecated in favor of :meth: ~torch.nn.Module.register_full_backward_hook and the behavior of this function will change in future versions. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]]) -> torch.utils.hooks.RemovableHandle","title":"register_backward_hook"},{"location":"src_model_edgeformer/#register_buffer","text":"Add a buffer to the module. This is typically used to register a buffer that should not to be considered a model parameter. For example, BatchNorm's running_mean is not a parameter, but is part of the module's state. Buffers, by default, are persistent and will be saved alongside parameters. This behavior can be changed by setting :attr: persistent to False . The only difference between a persistent buffer and a non-persistent buffer is that the latter will not be a part of this module's :attr: state_dict . Buffers can be accessed as attributes using given names. Args: name (str): name of the buffer. The buffer can be accessed from this module using the given name tensor (Tensor or None): buffer to be registered. If None , then operations that run on buffers, such as :attr: cuda , are ignored. If None , the buffer is not included in the module's :attr: state_dict . persistent (bool): whether the buffer is part of this module's :attr: state_dict . Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> self.register_buffer('running_mean', torch.zeros(num_features)) register_buffer(self, name: str, tensor: Optional[torch.Tensor], persistent: bool = True) -> None","title":"register_buffer"},{"location":"src_model_edgeformer/#register_forward_hook","text":"Register a forward hook on the module. The hook will be called every time after :func: forward has computed an output. If with_kwargs is False or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the output. It can modify the input inplace but it will not have effect on forward since this is called after :func: forward is called. The hook should have the following signature:: hook(module, args, output) -> None or modified output If with_kwargs is True , the forward hook will be passed the kwargs given to the forward function and be expected to return the output possibly modified. The hook should have the following signature:: hook(module, args, kwargs, output) -> None or modified output Args: hook (Callable): The user defined hook to be registered. prepend (bool): If True , the provided hook will be fired before all existing forward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward hooks on this :class: torch.nn.modules.Module . Note that global forward hooks registered with :func: register_module_forward_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If True , the hook will be passed the kwargs given to the forward function. Default: False always_call (bool): If True the hook will be run regardless of whether an exception is raised while calling the Module. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...], Any], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any], Any], Optional[Any]]], *, prepend: bool = False, with_kwargs: bool = False, always_call: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_forward_hook"},{"location":"src_model_edgeformer/#register_forward_pre_hook","text":"Register a forward pre-hook on the module. The hook will be called every time before :func: forward is invoked. If with_kwargs is false or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the input. User can either return a tuple or a single modified value in the hook. We will wrap the value into a tuple if a single value is returned (unless that value is already a tuple). The hook should have the following signature:: hook(module, args) -> None or modified input If with_kwargs is true, the forward pre-hook will be passed the kwargs given to the forward function. And if the hook modifies the input, both the args and kwargs should be returned. The hook should have the following signature:: hook(module, args, kwargs) -> None or a tuple of modified input and kwargs Args: hook (Callable): The user defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing forward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward_pre hooks on this :class: torch.nn.modules.Module . Note that global forward_pre hooks registered with :func: register_module_forward_pre_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If true, the hook will be passed the kwargs given to the forward function. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_pre_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...]], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any]], Optional[Tuple[Any, Dict[str, Any]]]]], *, prepend: bool = False, with_kwargs: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_forward_pre_hook"},{"location":"src_model_edgeformer/#register_full_backward_hook","text":"Register a backward hook on the module. The hook will be called every time the gradients with respect to a module are computed, i.e. the hook will execute if and only if the gradients with respect to module outputs are computed. The hook should have the following signature:: hook(module, grad_input, grad_output) -> tuple(Tensor) or None The :attr: grad_input and :attr: grad_output are tuples that contain the gradients with respect to the inputs and outputs respectively. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the input that will be used in place of :attr: grad_input in subsequent computations. :attr: grad_input will only correspond to the inputs given as positional arguments and all kwarg arguments are ignored. Entries in :attr: grad_input and :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs or outputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward hooks on this :class: torch.nn.modules.Module . Note that global backward hooks registered with :func: register_module_full_backward_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_full_backward_hook"},{"location":"src_model_edgeformer/#register_full_backward_pre_hook","text":"Register a backward pre-hook on the module. The hook will be called every time the gradients for the module are computed. The hook should have the following signature:: hook(module, grad_output) -> tuple[Tensor] or None The :attr: grad_output is a tuple. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the output that will be used in place of :attr: grad_output in subsequent computations. Entries in :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward_pre hooks on this :class: torch.nn.modules.Module . Note that global backward_pre hooks registered with :func: register_module_full_backward_pre_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_pre_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_full_backward_pre_hook"},{"location":"src_model_edgeformer/#register_load_state_dict_post_hook","text":"Register a post-hook to be run after module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, incompatible_keys) -> None The module argument is the current module that this hook is registered on, and the incompatible_keys argument is a NamedTuple consisting of attributes missing_keys and unexpected_keys . missing_keys is a list of str containing the missing keys and unexpected_keys is a list of str containing the unexpected keys. The given incompatible_keys can be modified inplace if needed. Note that the checks performed when calling :func: load_state_dict with strict=True are affected by modifications the hook makes to missing_keys or unexpected_keys , as expected. Additions to either set of keys will result in an error being thrown when strict=True , and clearing out both missing and unexpected keys will avoid an error. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_load_state_dict_post_hook(self, hook)","title":"register_load_state_dict_post_hook"},{"location":"src_model_edgeformer/#register_load_state_dict_pre_hook","text":"Register a pre-hook to be run before module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs) -> None # noqa: B950 Arguments: hook (Callable): Callable hook that will be invoked before loading the state dict. register_load_state_dict_pre_hook(self, hook)","title":"register_load_state_dict_pre_hook"},{"location":"src_model_edgeformer/#register_module","text":"Alias for :func: add_module . register_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None","title":"register_module"},{"location":"src_model_edgeformer/#register_parameter","text":"Add a parameter to the module. The parameter can be accessed as an attribute using given name. Args: name (str): name of the parameter. The parameter can be accessed from this module using the given name param (Parameter or None): parameter to be added to the module. If None , then operations that run on parameters, such as :attr: cuda , are ignored. If None , the parameter is not included in the module's :attr: state_dict . register_parameter(self, name: str, param: Optional[torch.nn.parameter.Parameter]) -> None","title":"register_parameter"},{"location":"src_model_edgeformer/#register_state_dict_post_hook","text":"Register a post-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, state_dict, prefix, local_metadata) -> None The registered hooks can modify the state_dict inplace. register_state_dict_post_hook(self, hook)","title":"register_state_dict_post_hook"},{"location":"src_model_edgeformer/#register_state_dict_pre_hook","text":"Register a pre-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, prefix, keep_vars) -> None The registered hooks can be used to perform pre-processing before the state_dict call is made. register_state_dict_pre_hook(self, hook)","title":"register_state_dict_pre_hook"},{"location":"src_model_edgeformer/#requires_grad_","text":"Change if autograd should record operations on parameters in this module. This method sets the parameters' :attr: requires_grad attributes in-place. This method is helpful for freezing part of the module for finetuning or training parts of a model individually (e.g., GAN training). See :ref: locally-disable-grad-doc for a comparison between .requires_grad_() and several similar mechanisms that may be confused with it. Args: requires_grad (bool): whether autograd should record operations on parameters in this module. Default: True . Returns: Module: self requires_grad_(self: ~T, requires_grad: bool = True) -> ~T","title":"requires_grad_"},{"location":"src_model_edgeformer/#set_extra_state","text":"Set extra state contained in the loaded state_dict . This function is called from :func: load_state_dict to handle any extra state found within the state_dict . Implement this function and a corresponding :func: get_extra_state for your module if you need to store extra state within its state_dict . Args: state (dict): Extra state from the state_dict set_extra_state(self, state: Any) -> None","title":"set_extra_state"},{"location":"src_model_edgeformer/#set_input_embeddings","text":"set_input_embeddings(self, value)","title":"set_input_embeddings"},{"location":"src_model_edgeformer/#set_submodule","text":"Set the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To overide the Conv2d with a new submodule Linear , you would call set_submodule(\"net_b.net_c.conv\", nn.Linear(33, 16)) . Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) module: The module to set the submodule to. Raises: ValueError: If the target string is empty AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module set_submodule(self, target: str, module: 'Module') -> None","title":"set_submodule"},{"location":"src_model_edgeformer/#share_memory","text":"See :meth: torch.Tensor.share_memory_ . share_memory(self: ~T) -> ~T","title":"share_memory"},{"location":"src_model_edgeformer/#state_dict","text":"Return a dictionary containing references to the whole state of the module. Both parameters and persistent buffers (e.g. running averages) are included. Keys are corresponding parameter and buffer names. Parameters and buffers set to None are not included. .. note:: The returned object is a shallow copy. It contains references to the module's parameters and buffers. .. warning:: Currently state_dict() also accepts positional arguments for destination , prefix and keep_vars in order. However, this is being deprecated and keyword arguments will be enforced in future releases. .. warning:: Please avoid the use of argument destination as it is not designed for end-users. Args: destination (dict, optional): If provided, the state of module will be updated into the dict and the same object is returned. Otherwise, an OrderedDict will be created and returned. Default: None . prefix (str, optional): a prefix added to parameter and buffer names to compose the keys in state_dict. Default: '' . keep_vars (bool, optional): by default the :class: ~torch.Tensor s returned in the state dict are detached from autograd. If it's set to True , detaching will not be performed. Default: False . Returns: dict: a dictionary containing a whole state of the module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> module.state_dict().keys() ['bias', 'weight'] state_dict(self, *args, destination=None, prefix='', keep_vars=False)","title":"state_dict"},{"location":"src_model_edgeformer/#to","text":"Move and/or cast the parameters and buffers. This can be called as .. function:: to(device=None, dtype=None, non_blocking=False) :noindex: .. function:: to(dtype, non_blocking=False) :noindex: .. function:: to(tensor, non_blocking=False) :noindex: .. function:: to(memory_format=torch.channels_last) :noindex: Its signature is similar to :meth: torch.Tensor.to , but only accepts floating point or complex :attr: dtype \\ s. In addition, this method will only cast the floating point or complex parameters and buffers to :attr: dtype (if given). The integral parameters and buffers will be moved :attr: device , if that is given, but with dtypes unchanged. When :attr: non_blocking is set, it tries to convert/move asynchronously with respect to the host if possible, e.g., moving CPU Tensors with pinned memory to CUDA devices. See below for examples. .. note:: This method modifies the module in-place. Args: device (:class: torch.device ): the desired device of the parameters and buffers in this module dtype (:class: torch.dtype ): the desired floating point or complex dtype of the parameters and buffers in this module tensor (torch.Tensor): Tensor whose dtype and device are the desired dtype and device for all parameters and buffers in this module memory_format (:class: torch.memory_format ): the desired memory format for 4D parameters and buffers in this module (keyword only argument) Returns: Module: self Examples:: >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\") >>> linear = nn.Linear(2, 2) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]]) >>> linear.to(torch.double) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]], dtype=torch.float64) >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA1) >>> gpu1 = torch.device(\"cuda:1\") >>> linear.to(gpu1, dtype=torch.half, non_blocking=True) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1') >>> cpu = torch.device(\"cpu\") >>> linear.to(cpu) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16) >>> linear = nn.Linear(2, 2, bias=None).to(torch.cdouble) >>> linear.weight Parameter containing: tensor([[ 0.3741+0.j, 0.2382+0.j], [ 0.5593+0.j, -0.4443+0.j]], dtype=torch.complex128) >>> linear(torch.ones(3, 2, dtype=torch.cdouble)) tensor([[0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j]], dtype=torch.complex128) to(self, *args, **kwargs)","title":"to"},{"location":"src_model_edgeformer/#to_empty","text":"Move the parameters and buffers to the specified device without copying storage. Args: device (:class: torch.device ): The desired device of the parameters and buffers in this module. recurse (bool): Whether parameters and buffers of submodules should be recursively moved to the specified device. Returns: Module: self to_empty(self: ~T, *, device: Union[int, str, torch.device, NoneType], recurse: bool = True) -> ~T","title":"to_empty"},{"location":"src_model_edgeformer/#train","text":"Set the module in training mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e., whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. Args: mode (bool): whether to set training mode ( True ) or evaluation mode ( False ). Default: True . Returns: Module: self train(self: ~T, mode: bool = True) -> ~T","title":"train"},{"location":"src_model_edgeformer/#type","text":"Casts all parameters and buffers to :attr: dst_type . .. note:: This method modifies the module in-place. Args: dst_type (type or string): the desired type Returns: Module: self type(self: ~T, dst_type: Union[torch.dtype, str]) -> ~T","title":"type"},{"location":"src_model_edgeformer/#xpu","text":"Move all model parameters and buffers to the XPU. This also makes associated parameters and buffers different objects. So it should be called before constructing optimizer if the module will live on XPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self xpu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"xpu"},{"location":"src_model_edgeformer/#zero_grad","text":"Reset gradients of all model parameters. See similar function under :class: torch.optim.Optimizer for more context. Args: set_to_none (bool): instead of setting to zero, set the grads to None. See :meth: torch.optim.Optimizer.zero_grad for details. zero_grad(self, set_to_none: bool = True) -> None","title":"zero_grad"},{"location":"src_model_edgeformer/#edgeformerembeddings","text":"","title":"EdgeFormerEmbeddings"},{"location":"src_model_edgeformer/#methods_1","text":"","title":"Methods"},{"location":"src_model_edgeformer/#__init___1","text":"__init__(self, config)","title":"__init__"},{"location":"src_model_edgeformer/#add_module_1","text":"Add a child module to the current module. The module can be accessed as an attribute using the given name. Args: name (str): name of the child module. The child module can be accessed from this module using the given name module (Module): child module to be added to the module. add_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None","title":"add_module"},{"location":"src_model_edgeformer/#apply_1","text":"Apply fn recursively to every submodule (as returned by .children() ) as well as self. Typical use includes initializing the parameters of a model (see also :ref: nn-init-doc ). Args: fn (:class: Module -> None): function to be applied to each submodule Returns: Module: self Example:: >>> @torch.no_grad() >>> def init_weights(m): >>> print(m) >>> if type(m) == nn.Linear: >>> m.weight.fill_(1.0) >>> print(m.weight) >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2)) >>> net.apply(init_weights) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) apply(self: ~T, fn: Callable[[ForwardRef('Module')], NoneType]) -> ~T","title":"apply"},{"location":"src_model_edgeformer/#bfloat16_1","text":"Casts all floating point parameters and buffers to bfloat16 datatype. .. note:: This method modifies the module in-place. Returns: Module: self bfloat16(self: ~T) -> ~T","title":"bfloat16"},{"location":"src_model_edgeformer/#buffers_1","text":"Return an iterator over module buffers. Args: recurse (bool): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Yields: torch.Tensor: module buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for buf in model.buffers(): >>> print(type(buf), buf.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) buffers(self, recurse: bool = True) -> Iterator[torch.Tensor]","title":"buffers"},{"location":"src_model_edgeformer/#children_1","text":"Return an iterator over immediate children modules. Yields: Module: a child module children(self) -> Iterator[ForwardRef('Module')]","title":"children"},{"location":"src_model_edgeformer/#compile_1","text":"Compile this Module's forward using :func: torch.compile . This Module's __call__ method is compiled and all arguments are passed as-is to :func: torch.compile . See :func: torch.compile for details on the arguments for this function. compile(self, *args, **kwargs)","title":"compile"},{"location":"src_model_edgeformer/#cpu_1","text":"Move all model parameters and buffers to the CPU. .. note:: This method modifies the module in-place. Returns: Module: self cpu(self: ~T) -> ~T","title":"cpu"},{"location":"src_model_edgeformer/#cuda_1","text":"Move all model parameters and buffers to the GPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on GPU while being optimized. .. note:: This method modifies the module in-place. Args: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self cuda(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"cuda"},{"location":"src_model_edgeformer/#double_1","text":"Casts all floating point parameters and buffers to double datatype. .. note:: This method modifies the module in-place. Returns: Module: self double(self: ~T) -> ~T","title":"double"},{"location":"src_model_edgeformer/#eval_1","text":"Set the module in evaluation mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e. whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. This is equivalent with :meth: self.train(False) <torch.nn.Module.train> . See :ref: locally-disable-grad-doc for a comparison between .eval() and several similar mechanisms that may be confused with it. Returns: Module: self eval(self: ~T) -> ~T","title":"eval"},{"location":"src_model_edgeformer/#extra_repr_1","text":"Return the extra representation of the module. To print customized extra information, you should re-implement this method in your own modules. Both single-line and multi-line strings are acceptable. extra_repr(self) -> str","title":"extra_repr"},{"location":"src_model_edgeformer/#float_1","text":"Casts all floating point parameters and buffers to float datatype. .. note:: This method modifies the module in-place. Returns: Module: self float(self: ~T) -> ~T","title":"float"},{"location":"src_model_edgeformer/#forward_1","text":"forward(self, input_ids=None, position_ids=None, inputs_embeds=None)","title":"forward"},{"location":"src_model_edgeformer/#get_buffer_1","text":"Return the buffer given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the buffer to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.Tensor: The buffer referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not a buffer get_buffer(self, target: str) -> 'Tensor'","title":"get_buffer"},{"location":"src_model_edgeformer/#get_extra_state_1","text":"Return any extra state to include in the module's state_dict. Implement this and a corresponding :func: set_extra_state for your module if you need to store extra state. This function is called when building the module's state_dict() . Note that extra state should be picklable to ensure working serialization of the state_dict. We only provide backwards compatibility guarantees for serializing Tensors; other objects may break backwards compatibility if their serialized pickled form changes. Returns: object: Any extra state to store in the module's state_dict get_extra_state(self) -> Any","title":"get_extra_state"},{"location":"src_model_edgeformer/#get_parameter_1","text":"Return the parameter given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the Parameter to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.nn.Parameter: The Parameter referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Parameter get_parameter(self, target: str) -> 'Parameter'","title":"get_parameter"},{"location":"src_model_edgeformer/#get_submodule_1","text":"Return the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A which has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To check whether or not we have the linear submodule, we would call get_submodule(\"net_b.linear\") . To check whether we have the conv submodule, we would call get_submodule(\"net_b.net_c.conv\") . The runtime of get_submodule is bounded by the degree of module nesting in target . A query against named_modules achieves the same result, but it is O(N) in the number of transitive modules. So, for a simple check to see if some submodule exists, get_submodule should always be used. Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) Returns: torch.nn.Module: The submodule referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module get_submodule(self, target: str) -> 'Module'","title":"get_submodule"},{"location":"src_model_edgeformer/#half_1","text":"Casts all floating point parameters and buffers to half datatype. .. note:: This method modifies the module in-place. Returns: Module: self half(self: ~T) -> ~T","title":"half"},{"location":"src_model_edgeformer/#ipu_1","text":"Move all model parameters and buffers to the IPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on IPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self ipu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"ipu"},{"location":"src_model_edgeformer/#load_state_dict_1","text":"Copy parameters and buffers from :attr: state_dict into this module and its descendants. If :attr: strict is True , then the keys of :attr: state_dict must exactly match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. .. warning:: If :attr: assign is True the optimizer must be created after the call to :attr: load_state_dict unless :func: ~torch.__future__.get_swap_module_params_on_conversion is True . Args: state_dict (dict): a dict containing parameters and persistent buffers. strict (bool, optional): whether to strictly enforce that the keys in :attr: state_dict match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. Default: True assign (bool, optional): When set to False , the properties of the tensors in the current module are preserved whereas setting it to True preserves properties of the Tensors in the state dict. The only exception is the requires_grad field of :class: ~torch.nn.Parameter s for which the value from the module is preserved. Default: False Returns: NamedTuple with missing_keys and unexpected_keys fields: * missing_keys is a list of str containing any keys that are expected by this module but missing from the provided state_dict . * unexpected_keys is a list of str containing the keys that are not expected by this module but present in the provided state_dict . Note: If a parameter or buffer is registered as None and its corresponding key exists in :attr: state_dict , :meth: load_state_dict will raise a RuntimeError . load_state_dict(self, state_dict: Mapping[str, Any], strict: bool = True, assign: bool = False)","title":"load_state_dict"},{"location":"src_model_edgeformer/#modules_1","text":"Return an iterator over all modules in the network. Yields: Module: a module in the network Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.modules()): ... print(idx, '->', m) 0 -> Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) 1 -> Linear(in_features=2, out_features=2, bias=True) modules(self) -> Iterator[ForwardRef('Module')]","title":"modules"},{"location":"src_model_edgeformer/#mtia_1","text":"Move all model parameters and buffers to the MTIA. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on MTIA while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self mtia(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"mtia"},{"location":"src_model_edgeformer/#named_buffers_1","text":"Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself. Args: prefix (str): prefix to prepend to all buffer names. recurse (bool, optional): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Defaults to True. remove_duplicate (bool, optional): whether to remove the duplicated buffers in the result. Defaults to True. Yields: (str, torch.Tensor): Tuple containing the name and buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, buf in self.named_buffers(): >>> if name in ['running_var']: >>> print(buf.size()) named_buffers(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.Tensor]]","title":"named_buffers"},{"location":"src_model_edgeformer/#named_children_1","text":"Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself. Yields: (str, Module): Tuple containing a name and child module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, module in model.named_children(): >>> if name in ['conv4', 'conv5']: >>> print(module) named_children(self) -> Iterator[Tuple[str, ForwardRef('Module')]]","title":"named_children"},{"location":"src_model_edgeformer/#named_modules_1","text":"Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself. Args: memo: a memo to store the set of modules already added to the result prefix: a prefix that will be added to the name of the module remove_duplicate: whether to remove the duplicated module instances in the result or not Yields: (str, Module): Tuple of name and module Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.named_modules()): ... print(idx, '->', m) 0 -> ('', Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) )) 1 -> ('0', Linear(in_features=2, out_features=2, bias=True)) named_modules(self, memo: Optional[Set[ForwardRef('Module')]] = None, prefix: str = '', remove_duplicate: bool = True)","title":"named_modules"},{"location":"src_model_edgeformer/#named_parameters_1","text":"Return an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself. Args: prefix (str): prefix to prepend to all parameter names. recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. remove_duplicate (bool, optional): whether to remove the duplicated parameters in the result. Defaults to True. Yields: (str, Parameter): Tuple containing the name and parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, param in self.named_parameters(): >>> if name in ['bias']: >>> print(param.size()) named_parameters(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.nn.parameter.Parameter]]","title":"named_parameters"},{"location":"src_model_edgeformer/#parameters_1","text":"Return an iterator over module parameters. This is typically passed to an optimizer. Args: recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. Yields: Parameter: module parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for param in model.parameters(): >>> print(type(param), param.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) parameters(self, recurse: bool = True) -> Iterator[torch.nn.parameter.Parameter]","title":"parameters"},{"location":"src_model_edgeformer/#register_backward_hook_1","text":"Register a backward hook on the module. This function is deprecated in favor of :meth: ~torch.nn.Module.register_full_backward_hook and the behavior of this function will change in future versions. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]]) -> torch.utils.hooks.RemovableHandle","title":"register_backward_hook"},{"location":"src_model_edgeformer/#register_buffer_1","text":"Add a buffer to the module. This is typically used to register a buffer that should not to be considered a model parameter. For example, BatchNorm's running_mean is not a parameter, but is part of the module's state. Buffers, by default, are persistent and will be saved alongside parameters. This behavior can be changed by setting :attr: persistent to False . The only difference between a persistent buffer and a non-persistent buffer is that the latter will not be a part of this module's :attr: state_dict . Buffers can be accessed as attributes using given names. Args: name (str): name of the buffer. The buffer can be accessed from this module using the given name tensor (Tensor or None): buffer to be registered. If None , then operations that run on buffers, such as :attr: cuda , are ignored. If None , the buffer is not included in the module's :attr: state_dict . persistent (bool): whether the buffer is part of this module's :attr: state_dict . Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> self.register_buffer('running_mean', torch.zeros(num_features)) register_buffer(self, name: str, tensor: Optional[torch.Tensor], persistent: bool = True) -> None","title":"register_buffer"},{"location":"src_model_edgeformer/#register_forward_hook_1","text":"Register a forward hook on the module. The hook will be called every time after :func: forward has computed an output. If with_kwargs is False or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the output. It can modify the input inplace but it will not have effect on forward since this is called after :func: forward is called. The hook should have the following signature:: hook(module, args, output) -> None or modified output If with_kwargs is True , the forward hook will be passed the kwargs given to the forward function and be expected to return the output possibly modified. The hook should have the following signature:: hook(module, args, kwargs, output) -> None or modified output Args: hook (Callable): The user defined hook to be registered. prepend (bool): If True , the provided hook will be fired before all existing forward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward hooks on this :class: torch.nn.modules.Module . Note that global forward hooks registered with :func: register_module_forward_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If True , the hook will be passed the kwargs given to the forward function. Default: False always_call (bool): If True the hook will be run regardless of whether an exception is raised while calling the Module. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...], Any], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any], Any], Optional[Any]]], *, prepend: bool = False, with_kwargs: bool = False, always_call: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_forward_hook"},{"location":"src_model_edgeformer/#register_forward_pre_hook_1","text":"Register a forward pre-hook on the module. The hook will be called every time before :func: forward is invoked. If with_kwargs is false or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the input. User can either return a tuple or a single modified value in the hook. We will wrap the value into a tuple if a single value is returned (unless that value is already a tuple). The hook should have the following signature:: hook(module, args) -> None or modified input If with_kwargs is true, the forward pre-hook will be passed the kwargs given to the forward function. And if the hook modifies the input, both the args and kwargs should be returned. The hook should have the following signature:: hook(module, args, kwargs) -> None or a tuple of modified input and kwargs Args: hook (Callable): The user defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing forward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward_pre hooks on this :class: torch.nn.modules.Module . Note that global forward_pre hooks registered with :func: register_module_forward_pre_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If true, the hook will be passed the kwargs given to the forward function. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_pre_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...]], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any]], Optional[Tuple[Any, Dict[str, Any]]]]], *, prepend: bool = False, with_kwargs: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_forward_pre_hook"},{"location":"src_model_edgeformer/#register_full_backward_hook_1","text":"Register a backward hook on the module. The hook will be called every time the gradients with respect to a module are computed, i.e. the hook will execute if and only if the gradients with respect to module outputs are computed. The hook should have the following signature:: hook(module, grad_input, grad_output) -> tuple(Tensor) or None The :attr: grad_input and :attr: grad_output are tuples that contain the gradients with respect to the inputs and outputs respectively. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the input that will be used in place of :attr: grad_input in subsequent computations. :attr: grad_input will only correspond to the inputs given as positional arguments and all kwarg arguments are ignored. Entries in :attr: grad_input and :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs or outputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward hooks on this :class: torch.nn.modules.Module . Note that global backward hooks registered with :func: register_module_full_backward_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_full_backward_hook"},{"location":"src_model_edgeformer/#register_full_backward_pre_hook_1","text":"Register a backward pre-hook on the module. The hook will be called every time the gradients for the module are computed. The hook should have the following signature:: hook(module, grad_output) -> tuple[Tensor] or None The :attr: grad_output is a tuple. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the output that will be used in place of :attr: grad_output in subsequent computations. Entries in :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward_pre hooks on this :class: torch.nn.modules.Module . Note that global backward_pre hooks registered with :func: register_module_full_backward_pre_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_pre_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_full_backward_pre_hook"},{"location":"src_model_edgeformer/#register_load_state_dict_post_hook_1","text":"Register a post-hook to be run after module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, incompatible_keys) -> None The module argument is the current module that this hook is registered on, and the incompatible_keys argument is a NamedTuple consisting of attributes missing_keys and unexpected_keys . missing_keys is a list of str containing the missing keys and unexpected_keys is a list of str containing the unexpected keys. The given incompatible_keys can be modified inplace if needed. Note that the checks performed when calling :func: load_state_dict with strict=True are affected by modifications the hook makes to missing_keys or unexpected_keys , as expected. Additions to either set of keys will result in an error being thrown when strict=True , and clearing out both missing and unexpected keys will avoid an error. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_load_state_dict_post_hook(self, hook)","title":"register_load_state_dict_post_hook"},{"location":"src_model_edgeformer/#register_load_state_dict_pre_hook_1","text":"Register a pre-hook to be run before module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs) -> None # noqa: B950 Arguments: hook (Callable): Callable hook that will be invoked before loading the state dict. register_load_state_dict_pre_hook(self, hook)","title":"register_load_state_dict_pre_hook"},{"location":"src_model_edgeformer/#register_module_1","text":"Alias for :func: add_module . register_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None","title":"register_module"},{"location":"src_model_edgeformer/#register_parameter_1","text":"Add a parameter to the module. The parameter can be accessed as an attribute using given name. Args: name (str): name of the parameter. The parameter can be accessed from this module using the given name param (Parameter or None): parameter to be added to the module. If None , then operations that run on parameters, such as :attr: cuda , are ignored. If None , the parameter is not included in the module's :attr: state_dict . register_parameter(self, name: str, param: Optional[torch.nn.parameter.Parameter]) -> None","title":"register_parameter"},{"location":"src_model_edgeformer/#register_state_dict_post_hook_1","text":"Register a post-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, state_dict, prefix, local_metadata) -> None The registered hooks can modify the state_dict inplace. register_state_dict_post_hook(self, hook)","title":"register_state_dict_post_hook"},{"location":"src_model_edgeformer/#register_state_dict_pre_hook_1","text":"Register a pre-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, prefix, keep_vars) -> None The registered hooks can be used to perform pre-processing before the state_dict call is made. register_state_dict_pre_hook(self, hook)","title":"register_state_dict_pre_hook"},{"location":"src_model_edgeformer/#requires_grad__1","text":"Change if autograd should record operations on parameters in this module. This method sets the parameters' :attr: requires_grad attributes in-place. This method is helpful for freezing part of the module for finetuning or training parts of a model individually (e.g., GAN training). See :ref: locally-disable-grad-doc for a comparison between .requires_grad_() and several similar mechanisms that may be confused with it. Args: requires_grad (bool): whether autograd should record operations on parameters in this module. Default: True . Returns: Module: self requires_grad_(self: ~T, requires_grad: bool = True) -> ~T","title":"requires_grad_"},{"location":"src_model_edgeformer/#set_extra_state_1","text":"Set extra state contained in the loaded state_dict . This function is called from :func: load_state_dict to handle any extra state found within the state_dict . Implement this function and a corresponding :func: get_extra_state for your module if you need to store extra state within its state_dict . Args: state (dict): Extra state from the state_dict set_extra_state(self, state: Any) -> None","title":"set_extra_state"},{"location":"src_model_edgeformer/#set_submodule_1","text":"Set the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To overide the Conv2d with a new submodule Linear , you would call set_submodule(\"net_b.net_c.conv\", nn.Linear(33, 16)) . Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) module: The module to set the submodule to. Raises: ValueError: If the target string is empty AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module set_submodule(self, target: str, module: 'Module') -> None","title":"set_submodule"},{"location":"src_model_edgeformer/#share_memory_1","text":"See :meth: torch.Tensor.share_memory_ . share_memory(self: ~T) -> ~T","title":"share_memory"},{"location":"src_model_edgeformer/#state_dict_1","text":"Return a dictionary containing references to the whole state of the module. Both parameters and persistent buffers (e.g. running averages) are included. Keys are corresponding parameter and buffer names. Parameters and buffers set to None are not included. .. note:: The returned object is a shallow copy. It contains references to the module's parameters and buffers. .. warning:: Currently state_dict() also accepts positional arguments for destination , prefix and keep_vars in order. However, this is being deprecated and keyword arguments will be enforced in future releases. .. warning:: Please avoid the use of argument destination as it is not designed for end-users. Args: destination (dict, optional): If provided, the state of module will be updated into the dict and the same object is returned. Otherwise, an OrderedDict will be created and returned. Default: None . prefix (str, optional): a prefix added to parameter and buffer names to compose the keys in state_dict. Default: '' . keep_vars (bool, optional): by default the :class: ~torch.Tensor s returned in the state dict are detached from autograd. If it's set to True , detaching will not be performed. Default: False . Returns: dict: a dictionary containing a whole state of the module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> module.state_dict().keys() ['bias', 'weight'] state_dict(self, *args, destination=None, prefix='', keep_vars=False)","title":"state_dict"},{"location":"src_model_edgeformer/#to_1","text":"Move and/or cast the parameters and buffers. This can be called as .. function:: to(device=None, dtype=None, non_blocking=False) :noindex: .. function:: to(dtype, non_blocking=False) :noindex: .. function:: to(tensor, non_blocking=False) :noindex: .. function:: to(memory_format=torch.channels_last) :noindex: Its signature is similar to :meth: torch.Tensor.to , but only accepts floating point or complex :attr: dtype \\ s. In addition, this method will only cast the floating point or complex parameters and buffers to :attr: dtype (if given). The integral parameters and buffers will be moved :attr: device , if that is given, but with dtypes unchanged. When :attr: non_blocking is set, it tries to convert/move asynchronously with respect to the host if possible, e.g., moving CPU Tensors with pinned memory to CUDA devices. See below for examples. .. note:: This method modifies the module in-place. Args: device (:class: torch.device ): the desired device of the parameters and buffers in this module dtype (:class: torch.dtype ): the desired floating point or complex dtype of the parameters and buffers in this module tensor (torch.Tensor): Tensor whose dtype and device are the desired dtype and device for all parameters and buffers in this module memory_format (:class: torch.memory_format ): the desired memory format for 4D parameters and buffers in this module (keyword only argument) Returns: Module: self Examples:: >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\") >>> linear = nn.Linear(2, 2) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]]) >>> linear.to(torch.double) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]], dtype=torch.float64) >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA1) >>> gpu1 = torch.device(\"cuda:1\") >>> linear.to(gpu1, dtype=torch.half, non_blocking=True) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1') >>> cpu = torch.device(\"cpu\") >>> linear.to(cpu) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16) >>> linear = nn.Linear(2, 2, bias=None).to(torch.cdouble) >>> linear.weight Parameter containing: tensor([[ 0.3741+0.j, 0.2382+0.j], [ 0.5593+0.j, -0.4443+0.j]], dtype=torch.complex128) >>> linear(torch.ones(3, 2, dtype=torch.cdouble)) tensor([[0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j]], dtype=torch.complex128) to(self, *args, **kwargs)","title":"to"},{"location":"src_model_edgeformer/#to_empty_1","text":"Move the parameters and buffers to the specified device without copying storage. Args: device (:class: torch.device ): The desired device of the parameters and buffers in this module. recurse (bool): Whether parameters and buffers of submodules should be recursively moved to the specified device. Returns: Module: self to_empty(self: ~T, *, device: Union[int, str, torch.device, NoneType], recurse: bool = True) -> ~T","title":"to_empty"},{"location":"src_model_edgeformer/#train_1","text":"Set the module in training mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e., whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. Args: mode (bool): whether to set training mode ( True ) or evaluation mode ( False ). Default: True . Returns: Module: self train(self: ~T, mode: bool = True) -> ~T","title":"train"},{"location":"src_model_edgeformer/#type_1","text":"Casts all parameters and buffers to :attr: dst_type . .. note:: This method modifies the module in-place. Args: dst_type (type or string): the desired type Returns: Module: self type(self: ~T, dst_type: Union[torch.dtype, str]) -> ~T","title":"type"},{"location":"src_model_edgeformer/#xpu_1","text":"Move all model parameters and buffers to the XPU. This also makes associated parameters and buffers different objects. So it should be called before constructing optimizer if the module will live on XPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self xpu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"xpu"},{"location":"src_model_edgeformer/#zero_grad_1","text":"Reset gradients of all model parameters. See similar function under :class: torch.optim.Optimizer for more context. Args: set_to_none (bool): instead of setting to zero, set the grads to None. See :meth: torch.optim.Optimizer.zero_grad for details. zero_grad(self, set_to_none: bool = True) -> None","title":"zero_grad"},{"location":"src_model_edgeformer/#edgeformerlmhead","text":"","title":"EdgeFormerLMHead"},{"location":"src_model_edgeformer/#methods_2","text":"","title":"Methods"},{"location":"src_model_edgeformer/#__init___2","text":"__init__(self, config)","title":"__init__"},{"location":"src_model_edgeformer/#add_module_2","text":"Add a child module to the current module. The module can be accessed as an attribute using the given name. Args: name (str): name of the child module. The child module can be accessed from this module using the given name module (Module): child module to be added to the module. add_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None","title":"add_module"},{"location":"src_model_edgeformer/#apply_2","text":"Apply fn recursively to every submodule (as returned by .children() ) as well as self. Typical use includes initializing the parameters of a model (see also :ref: nn-init-doc ). Args: fn (:class: Module -> None): function to be applied to each submodule Returns: Module: self Example:: >>> @torch.no_grad() >>> def init_weights(m): >>> print(m) >>> if type(m) == nn.Linear: >>> m.weight.fill_(1.0) >>> print(m.weight) >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2)) >>> net.apply(init_weights) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) apply(self: ~T, fn: Callable[[ForwardRef('Module')], NoneType]) -> ~T","title":"apply"},{"location":"src_model_edgeformer/#bfloat16_2","text":"Casts all floating point parameters and buffers to bfloat16 datatype. .. note:: This method modifies the module in-place. Returns: Module: self bfloat16(self: ~T) -> ~T","title":"bfloat16"},{"location":"src_model_edgeformer/#buffers_2","text":"Return an iterator over module buffers. Args: recurse (bool): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Yields: torch.Tensor: module buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for buf in model.buffers(): >>> print(type(buf), buf.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) buffers(self, recurse: bool = True) -> Iterator[torch.Tensor]","title":"buffers"},{"location":"src_model_edgeformer/#children_2","text":"Return an iterator over immediate children modules. Yields: Module: a child module children(self) -> Iterator[ForwardRef('Module')]","title":"children"},{"location":"src_model_edgeformer/#compile_2","text":"Compile this Module's forward using :func: torch.compile . This Module's __call__ method is compiled and all arguments are passed as-is to :func: torch.compile . See :func: torch.compile for details on the arguments for this function. compile(self, *args, **kwargs)","title":"compile"},{"location":"src_model_edgeformer/#cpu_2","text":"Move all model parameters and buffers to the CPU. .. note:: This method modifies the module in-place. Returns: Module: self cpu(self: ~T) -> ~T","title":"cpu"},{"location":"src_model_edgeformer/#cuda_2","text":"Move all model parameters and buffers to the GPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on GPU while being optimized. .. note:: This method modifies the module in-place. Args: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self cuda(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"cuda"},{"location":"src_model_edgeformer/#double_2","text":"Casts all floating point parameters and buffers to double datatype. .. note:: This method modifies the module in-place. Returns: Module: self double(self: ~T) -> ~T","title":"double"},{"location":"src_model_edgeformer/#eval_2","text":"Set the module in evaluation mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e. whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. This is equivalent with :meth: self.train(False) <torch.nn.Module.train> . See :ref: locally-disable-grad-doc for a comparison between .eval() and several similar mechanisms that may be confused with it. Returns: Module: self eval(self: ~T) -> ~T","title":"eval"},{"location":"src_model_edgeformer/#extra_repr_2","text":"Return the extra representation of the module. To print customized extra information, you should re-implement this method in your own modules. Both single-line and multi-line strings are acceptable. extra_repr(self) -> str","title":"extra_repr"},{"location":"src_model_edgeformer/#float_2","text":"Casts all floating point parameters and buffers to float datatype. .. note:: This method modifies the module in-place. Returns: Module: self float(self: ~T) -> ~T","title":"float"},{"location":"src_model_edgeformer/#forward_2","text":"forward(self, hidden_states)","title":"forward"},{"location":"src_model_edgeformer/#get_buffer_2","text":"Return the buffer given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the buffer to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.Tensor: The buffer referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not a buffer get_buffer(self, target: str) -> 'Tensor'","title":"get_buffer"},{"location":"src_model_edgeformer/#get_extra_state_2","text":"Return any extra state to include in the module's state_dict. Implement this and a corresponding :func: set_extra_state for your module if you need to store extra state. This function is called when building the module's state_dict() . Note that extra state should be picklable to ensure working serialization of the state_dict. We only provide backwards compatibility guarantees for serializing Tensors; other objects may break backwards compatibility if their serialized pickled form changes. Returns: object: Any extra state to store in the module's state_dict get_extra_state(self) -> Any","title":"get_extra_state"},{"location":"src_model_edgeformer/#get_parameter_2","text":"Return the parameter given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the Parameter to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.nn.Parameter: The Parameter referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Parameter get_parameter(self, target: str) -> 'Parameter'","title":"get_parameter"},{"location":"src_model_edgeformer/#get_submodule_2","text":"Return the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A which has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To check whether or not we have the linear submodule, we would call get_submodule(\"net_b.linear\") . To check whether we have the conv submodule, we would call get_submodule(\"net_b.net_c.conv\") . The runtime of get_submodule is bounded by the degree of module nesting in target . A query against named_modules achieves the same result, but it is O(N) in the number of transitive modules. So, for a simple check to see if some submodule exists, get_submodule should always be used. Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) Returns: torch.nn.Module: The submodule referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module get_submodule(self, target: str) -> 'Module'","title":"get_submodule"},{"location":"src_model_edgeformer/#half_2","text":"Casts all floating point parameters and buffers to half datatype. .. note:: This method modifies the module in-place. Returns: Module: self half(self: ~T) -> ~T","title":"half"},{"location":"src_model_edgeformer/#ipu_2","text":"Move all model parameters and buffers to the IPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on IPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self ipu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"ipu"},{"location":"src_model_edgeformer/#load_state_dict_2","text":"Copy parameters and buffers from :attr: state_dict into this module and its descendants. If :attr: strict is True , then the keys of :attr: state_dict must exactly match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. .. warning:: If :attr: assign is True the optimizer must be created after the call to :attr: load_state_dict unless :func: ~torch.__future__.get_swap_module_params_on_conversion is True . Args: state_dict (dict): a dict containing parameters and persistent buffers. strict (bool, optional): whether to strictly enforce that the keys in :attr: state_dict match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. Default: True assign (bool, optional): When set to False , the properties of the tensors in the current module are preserved whereas setting it to True preserves properties of the Tensors in the state dict. The only exception is the requires_grad field of :class: ~torch.nn.Parameter s for which the value from the module is preserved. Default: False Returns: NamedTuple with missing_keys and unexpected_keys fields: * missing_keys is a list of str containing any keys that are expected by this module but missing from the provided state_dict . * unexpected_keys is a list of str containing the keys that are not expected by this module but present in the provided state_dict . Note: If a parameter or buffer is registered as None and its corresponding key exists in :attr: state_dict , :meth: load_state_dict will raise a RuntimeError . load_state_dict(self, state_dict: Mapping[str, Any], strict: bool = True, assign: bool = False)","title":"load_state_dict"},{"location":"src_model_edgeformer/#modules_2","text":"Return an iterator over all modules in the network. Yields: Module: a module in the network Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.modules()): ... print(idx, '->', m) 0 -> Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) 1 -> Linear(in_features=2, out_features=2, bias=True) modules(self) -> Iterator[ForwardRef('Module')]","title":"modules"},{"location":"src_model_edgeformer/#mtia_2","text":"Move all model parameters and buffers to the MTIA. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on MTIA while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self mtia(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"mtia"},{"location":"src_model_edgeformer/#named_buffers_2","text":"Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself. Args: prefix (str): prefix to prepend to all buffer names. recurse (bool, optional): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Defaults to True. remove_duplicate (bool, optional): whether to remove the duplicated buffers in the result. Defaults to True. Yields: (str, torch.Tensor): Tuple containing the name and buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, buf in self.named_buffers(): >>> if name in ['running_var']: >>> print(buf.size()) named_buffers(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.Tensor]]","title":"named_buffers"},{"location":"src_model_edgeformer/#named_children_2","text":"Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself. Yields: (str, Module): Tuple containing a name and child module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, module in model.named_children(): >>> if name in ['conv4', 'conv5']: >>> print(module) named_children(self) -> Iterator[Tuple[str, ForwardRef('Module')]]","title":"named_children"},{"location":"src_model_edgeformer/#named_modules_2","text":"Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself. Args: memo: a memo to store the set of modules already added to the result prefix: a prefix that will be added to the name of the module remove_duplicate: whether to remove the duplicated module instances in the result or not Yields: (str, Module): Tuple of name and module Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.named_modules()): ... print(idx, '->', m) 0 -> ('', Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) )) 1 -> ('0', Linear(in_features=2, out_features=2, bias=True)) named_modules(self, memo: Optional[Set[ForwardRef('Module')]] = None, prefix: str = '', remove_duplicate: bool = True)","title":"named_modules"},{"location":"src_model_edgeformer/#named_parameters_2","text":"Return an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself. Args: prefix (str): prefix to prepend to all parameter names. recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. remove_duplicate (bool, optional): whether to remove the duplicated parameters in the result. Defaults to True. Yields: (str, Parameter): Tuple containing the name and parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, param in self.named_parameters(): >>> if name in ['bias']: >>> print(param.size()) named_parameters(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.nn.parameter.Parameter]]","title":"named_parameters"},{"location":"src_model_edgeformer/#parameters_2","text":"Return an iterator over module parameters. This is typically passed to an optimizer. Args: recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. Yields: Parameter: module parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for param in model.parameters(): >>> print(type(param), param.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) parameters(self, recurse: bool = True) -> Iterator[torch.nn.parameter.Parameter]","title":"parameters"},{"location":"src_model_edgeformer/#register_backward_hook_2","text":"Register a backward hook on the module. This function is deprecated in favor of :meth: ~torch.nn.Module.register_full_backward_hook and the behavior of this function will change in future versions. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]]) -> torch.utils.hooks.RemovableHandle","title":"register_backward_hook"},{"location":"src_model_edgeformer/#register_buffer_2","text":"Add a buffer to the module. This is typically used to register a buffer that should not to be considered a model parameter. For example, BatchNorm's running_mean is not a parameter, but is part of the module's state. Buffers, by default, are persistent and will be saved alongside parameters. This behavior can be changed by setting :attr: persistent to False . The only difference between a persistent buffer and a non-persistent buffer is that the latter will not be a part of this module's :attr: state_dict . Buffers can be accessed as attributes using given names. Args: name (str): name of the buffer. The buffer can be accessed from this module using the given name tensor (Tensor or None): buffer to be registered. If None , then operations that run on buffers, such as :attr: cuda , are ignored. If None , the buffer is not included in the module's :attr: state_dict . persistent (bool): whether the buffer is part of this module's :attr: state_dict . Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> self.register_buffer('running_mean', torch.zeros(num_features)) register_buffer(self, name: str, tensor: Optional[torch.Tensor], persistent: bool = True) -> None","title":"register_buffer"},{"location":"src_model_edgeformer/#register_forward_hook_2","text":"Register a forward hook on the module. The hook will be called every time after :func: forward has computed an output. If with_kwargs is False or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the output. It can modify the input inplace but it will not have effect on forward since this is called after :func: forward is called. The hook should have the following signature:: hook(module, args, output) -> None or modified output If with_kwargs is True , the forward hook will be passed the kwargs given to the forward function and be expected to return the output possibly modified. The hook should have the following signature:: hook(module, args, kwargs, output) -> None or modified output Args: hook (Callable): The user defined hook to be registered. prepend (bool): If True , the provided hook will be fired before all existing forward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward hooks on this :class: torch.nn.modules.Module . Note that global forward hooks registered with :func: register_module_forward_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If True , the hook will be passed the kwargs given to the forward function. Default: False always_call (bool): If True the hook will be run regardless of whether an exception is raised while calling the Module. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...], Any], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any], Any], Optional[Any]]], *, prepend: bool = False, with_kwargs: bool = False, always_call: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_forward_hook"},{"location":"src_model_edgeformer/#register_forward_pre_hook_2","text":"Register a forward pre-hook on the module. The hook will be called every time before :func: forward is invoked. If with_kwargs is false or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the input. User can either return a tuple or a single modified value in the hook. We will wrap the value into a tuple if a single value is returned (unless that value is already a tuple). The hook should have the following signature:: hook(module, args) -> None or modified input If with_kwargs is true, the forward pre-hook will be passed the kwargs given to the forward function. And if the hook modifies the input, both the args and kwargs should be returned. The hook should have the following signature:: hook(module, args, kwargs) -> None or a tuple of modified input and kwargs Args: hook (Callable): The user defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing forward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward_pre hooks on this :class: torch.nn.modules.Module . Note that global forward_pre hooks registered with :func: register_module_forward_pre_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If true, the hook will be passed the kwargs given to the forward function. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_pre_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...]], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any]], Optional[Tuple[Any, Dict[str, Any]]]]], *, prepend: bool = False, with_kwargs: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_forward_pre_hook"},{"location":"src_model_edgeformer/#register_full_backward_hook_2","text":"Register a backward hook on the module. The hook will be called every time the gradients with respect to a module are computed, i.e. the hook will execute if and only if the gradients with respect to module outputs are computed. The hook should have the following signature:: hook(module, grad_input, grad_output) -> tuple(Tensor) or None The :attr: grad_input and :attr: grad_output are tuples that contain the gradients with respect to the inputs and outputs respectively. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the input that will be used in place of :attr: grad_input in subsequent computations. :attr: grad_input will only correspond to the inputs given as positional arguments and all kwarg arguments are ignored. Entries in :attr: grad_input and :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs or outputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward hooks on this :class: torch.nn.modules.Module . Note that global backward hooks registered with :func: register_module_full_backward_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_full_backward_hook"},{"location":"src_model_edgeformer/#register_full_backward_pre_hook_2","text":"Register a backward pre-hook on the module. The hook will be called every time the gradients for the module are computed. The hook should have the following signature:: hook(module, grad_output) -> tuple[Tensor] or None The :attr: grad_output is a tuple. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the output that will be used in place of :attr: grad_output in subsequent computations. Entries in :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward_pre hooks on this :class: torch.nn.modules.Module . Note that global backward_pre hooks registered with :func: register_module_full_backward_pre_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_pre_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_full_backward_pre_hook"},{"location":"src_model_edgeformer/#register_load_state_dict_post_hook_2","text":"Register a post-hook to be run after module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, incompatible_keys) -> None The module argument is the current module that this hook is registered on, and the incompatible_keys argument is a NamedTuple consisting of attributes missing_keys and unexpected_keys . missing_keys is a list of str containing the missing keys and unexpected_keys is a list of str containing the unexpected keys. The given incompatible_keys can be modified inplace if needed. Note that the checks performed when calling :func: load_state_dict with strict=True are affected by modifications the hook makes to missing_keys or unexpected_keys , as expected. Additions to either set of keys will result in an error being thrown when strict=True , and clearing out both missing and unexpected keys will avoid an error. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_load_state_dict_post_hook(self, hook)","title":"register_load_state_dict_post_hook"},{"location":"src_model_edgeformer/#register_load_state_dict_pre_hook_2","text":"Register a pre-hook to be run before module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs) -> None # noqa: B950 Arguments: hook (Callable): Callable hook that will be invoked before loading the state dict. register_load_state_dict_pre_hook(self, hook)","title":"register_load_state_dict_pre_hook"},{"location":"src_model_edgeformer/#register_module_2","text":"Alias for :func: add_module . register_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None","title":"register_module"},{"location":"src_model_edgeformer/#register_parameter_2","text":"Add a parameter to the module. The parameter can be accessed as an attribute using given name. Args: name (str): name of the parameter. The parameter can be accessed from this module using the given name param (Parameter or None): parameter to be added to the module. If None , then operations that run on parameters, such as :attr: cuda , are ignored. If None , the parameter is not included in the module's :attr: state_dict . register_parameter(self, name: str, param: Optional[torch.nn.parameter.Parameter]) -> None","title":"register_parameter"},{"location":"src_model_edgeformer/#register_state_dict_post_hook_2","text":"Register a post-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, state_dict, prefix, local_metadata) -> None The registered hooks can modify the state_dict inplace. register_state_dict_post_hook(self, hook)","title":"register_state_dict_post_hook"},{"location":"src_model_edgeformer/#register_state_dict_pre_hook_2","text":"Register a pre-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, prefix, keep_vars) -> None The registered hooks can be used to perform pre-processing before the state_dict call is made. register_state_dict_pre_hook(self, hook)","title":"register_state_dict_pre_hook"},{"location":"src_model_edgeformer/#requires_grad__2","text":"Change if autograd should record operations on parameters in this module. This method sets the parameters' :attr: requires_grad attributes in-place. This method is helpful for freezing part of the module for finetuning or training parts of a model individually (e.g., GAN training). See :ref: locally-disable-grad-doc for a comparison between .requires_grad_() and several similar mechanisms that may be confused with it. Args: requires_grad (bool): whether autograd should record operations on parameters in this module. Default: True . Returns: Module: self requires_grad_(self: ~T, requires_grad: bool = True) -> ~T","title":"requires_grad_"},{"location":"src_model_edgeformer/#set_extra_state_2","text":"Set extra state contained in the loaded state_dict . This function is called from :func: load_state_dict to handle any extra state found within the state_dict . Implement this function and a corresponding :func: get_extra_state for your module if you need to store extra state within its state_dict . Args: state (dict): Extra state from the state_dict set_extra_state(self, state: Any) -> None","title":"set_extra_state"},{"location":"src_model_edgeformer/#set_submodule_2","text":"Set the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To overide the Conv2d with a new submodule Linear , you would call set_submodule(\"net_b.net_c.conv\", nn.Linear(33, 16)) . Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) module: The module to set the submodule to. Raises: ValueError: If the target string is empty AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module set_submodule(self, target: str, module: 'Module') -> None","title":"set_submodule"},{"location":"src_model_edgeformer/#share_memory_2","text":"See :meth: torch.Tensor.share_memory_ . share_memory(self: ~T) -> ~T","title":"share_memory"},{"location":"src_model_edgeformer/#state_dict_2","text":"Return a dictionary containing references to the whole state of the module. Both parameters and persistent buffers (e.g. running averages) are included. Keys are corresponding parameter and buffer names. Parameters and buffers set to None are not included. .. note:: The returned object is a shallow copy. It contains references to the module's parameters and buffers. .. warning:: Currently state_dict() also accepts positional arguments for destination , prefix and keep_vars in order. However, this is being deprecated and keyword arguments will be enforced in future releases. .. warning:: Please avoid the use of argument destination as it is not designed for end-users. Args: destination (dict, optional): If provided, the state of module will be updated into the dict and the same object is returned. Otherwise, an OrderedDict will be created and returned. Default: None . prefix (str, optional): a prefix added to parameter and buffer names to compose the keys in state_dict. Default: '' . keep_vars (bool, optional): by default the :class: ~torch.Tensor s returned in the state dict are detached from autograd. If it's set to True , detaching will not be performed. Default: False . Returns: dict: a dictionary containing a whole state of the module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> module.state_dict().keys() ['bias', 'weight'] state_dict(self, *args, destination=None, prefix='', keep_vars=False)","title":"state_dict"},{"location":"src_model_edgeformer/#to_2","text":"Move and/or cast the parameters and buffers. This can be called as .. function:: to(device=None, dtype=None, non_blocking=False) :noindex: .. function:: to(dtype, non_blocking=False) :noindex: .. function:: to(tensor, non_blocking=False) :noindex: .. function:: to(memory_format=torch.channels_last) :noindex: Its signature is similar to :meth: torch.Tensor.to , but only accepts floating point or complex :attr: dtype \\ s. In addition, this method will only cast the floating point or complex parameters and buffers to :attr: dtype (if given). The integral parameters and buffers will be moved :attr: device , if that is given, but with dtypes unchanged. When :attr: non_blocking is set, it tries to convert/move asynchronously with respect to the host if possible, e.g., moving CPU Tensors with pinned memory to CUDA devices. See below for examples. .. note:: This method modifies the module in-place. Args: device (:class: torch.device ): the desired device of the parameters and buffers in this module dtype (:class: torch.dtype ): the desired floating point or complex dtype of the parameters and buffers in this module tensor (torch.Tensor): Tensor whose dtype and device are the desired dtype and device for all parameters and buffers in this module memory_format (:class: torch.memory_format ): the desired memory format for 4D parameters and buffers in this module (keyword only argument) Returns: Module: self Examples:: >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\") >>> linear = nn.Linear(2, 2) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]]) >>> linear.to(torch.double) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]], dtype=torch.float64) >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA1) >>> gpu1 = torch.device(\"cuda:1\") >>> linear.to(gpu1, dtype=torch.half, non_blocking=True) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1') >>> cpu = torch.device(\"cpu\") >>> linear.to(cpu) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16) >>> linear = nn.Linear(2, 2, bias=None).to(torch.cdouble) >>> linear.weight Parameter containing: tensor([[ 0.3741+0.j, 0.2382+0.j], [ 0.5593+0.j, -0.4443+0.j]], dtype=torch.complex128) >>> linear(torch.ones(3, 2, dtype=torch.cdouble)) tensor([[0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j]], dtype=torch.complex128) to(self, *args, **kwargs)","title":"to"},{"location":"src_model_edgeformer/#to_empty_2","text":"Move the parameters and buffers to the specified device without copying storage. Args: device (:class: torch.device ): The desired device of the parameters and buffers in this module. recurse (bool): Whether parameters and buffers of submodules should be recursively moved to the specified device. Returns: Module: self to_empty(self: ~T, *, device: Union[int, str, torch.device, NoneType], recurse: bool = True) -> ~T","title":"to_empty"},{"location":"src_model_edgeformer/#train_2","text":"Set the module in training mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e., whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. Args: mode (bool): whether to set training mode ( True ) or evaluation mode ( False ). Default: True . Returns: Module: self train(self: ~T, mode: bool = True) -> ~T","title":"train"},{"location":"src_model_edgeformer/#type_2","text":"Casts all parameters and buffers to :attr: dst_type . .. note:: This method modifies the module in-place. Args: dst_type (type or string): the desired type Returns: Module: self type(self: ~T, dst_type: Union[torch.dtype, str]) -> ~T","title":"type"},{"location":"src_model_edgeformer/#xpu_2","text":"Move all model parameters and buffers to the XPU. This also makes associated parameters and buffers different objects. So it should be called before constructing optimizer if the module will live on XPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self xpu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"xpu"},{"location":"src_model_edgeformer/#zero_grad_2","text":"Reset gradients of all model parameters. See similar function under :class: torch.optim.Optimizer for more context. Args: set_to_none (bool): instead of setting to zero, set the grads to None. See :meth: torch.optim.Optimizer.zero_grad for details. zero_grad(self, set_to_none: bool = True) -> None","title":"zero_grad"},{"location":"src_model_multi_head_latent_attention/","text":"src.model.multi_head_latent_attention Classes MultiHeadLatentAttention Multi-Head Latent Attention implementation based on DeepSeek's approach. Reduces KV cache size by projecting into a shared latent space. Methods __init__ __init__(self, config) add_module Add a child module to the current module. The module can be accessed as an attribute using the given name. Args: name (str): name of the child module. The child module can be accessed from this module using the given name module (Module): child module to be added to the module. add_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None apply Apply fn recursively to every submodule (as returned by .children() ) as well as self. Typical use includes initializing the parameters of a model (see also :ref: nn-init-doc ). Args: fn (:class: Module -> None): function to be applied to each submodule Returns: Module: self Example:: >>> @torch.no_grad() >>> def init_weights(m): >>> print(m) >>> if type(m) == nn.Linear: >>> m.weight.fill_(1.0) >>> print(m.weight) >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2)) >>> net.apply(init_weights) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) apply(self: ~T, fn: Callable[[ForwardRef('Module')], NoneType]) -> ~T bfloat16 Casts all floating point parameters and buffers to bfloat16 datatype. .. note:: This method modifies the module in-place. Returns: Module: self bfloat16(self: ~T) -> ~T buffers Return an iterator over module buffers. Args: recurse (bool): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Yields: torch.Tensor: module buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for buf in model.buffers(): >>> print(type(buf), buf.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) buffers(self, recurse: bool = True) -> Iterator[torch.Tensor] children Return an iterator over immediate children modules. Yields: Module: a child module children(self) -> Iterator[ForwardRef('Module')] compile Compile this Module's forward using :func: torch.compile . This Module's __call__ method is compiled and all arguments are passed as-is to :func: torch.compile . See :func: torch.compile for details on the arguments for this function. compile(self, *args, **kwargs) cpu Move all model parameters and buffers to the CPU. .. note:: This method modifies the module in-place. Returns: Module: self cpu(self: ~T) -> ~T cuda Move all model parameters and buffers to the GPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on GPU while being optimized. .. note:: This method modifies the module in-place. Args: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self cuda(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T double Casts all floating point parameters and buffers to double datatype. .. note:: This method modifies the module in-place. Returns: Module: self double(self: ~T) -> ~T eval Set the module in evaluation mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e. whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. This is equivalent with :meth: self.train(False) <torch.nn.Module.train> . See :ref: locally-disable-grad-doc for a comparison between .eval() and several similar mechanisms that may be confused with it. Returns: Module: self eval(self: ~T) -> ~T extra_repr Return the extra representation of the module. To print customized extra information, you should re-implement this method in your own modules. Both single-line and multi-line strings are acceptable. extra_repr(self) -> str float Casts all floating point parameters and buffers to float datatype. .. note:: This method modifies the module in-place. Returns: Module: self float(self: ~T) -> ~T forward forward(self, hidden_states, attention_mask=None, position_bias=None, head_mask=None, past_key_value=None, use_cache=False, output_attentions=False, sliding_window_size=None) get_buffer Return the buffer given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the buffer to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.Tensor: The buffer referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not a buffer get_buffer(self, target: str) -> 'Tensor' get_extra_state Return any extra state to include in the module's state_dict. Implement this and a corresponding :func: set_extra_state for your module if you need to store extra state. This function is called when building the module's state_dict() . Note that extra state should be picklable to ensure working serialization of the state_dict. We only provide backwards compatibility guarantees for serializing Tensors; other objects may break backwards compatibility if their serialized pickled form changes. Returns: object: Any extra state to store in the module's state_dict get_extra_state(self) -> Any get_parameter Return the parameter given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the Parameter to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.nn.Parameter: The Parameter referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Parameter get_parameter(self, target: str) -> 'Parameter' get_submodule Return the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A which has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To check whether or not we have the linear submodule, we would call get_submodule(\"net_b.linear\") . To check whether we have the conv submodule, we would call get_submodule(\"net_b.net_c.conv\") . The runtime of get_submodule is bounded by the degree of module nesting in target . A query against named_modules achieves the same result, but it is O(N) in the number of transitive modules. So, for a simple check to see if some submodule exists, get_submodule should always be used. Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) Returns: torch.nn.Module: The submodule referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module get_submodule(self, target: str) -> 'Module' half Casts all floating point parameters and buffers to half datatype. .. note:: This method modifies the module in-place. Returns: Module: self half(self: ~T) -> ~T ipu Move all model parameters and buffers to the IPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on IPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self ipu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T load_state_dict Copy parameters and buffers from :attr: state_dict into this module and its descendants. If :attr: strict is True , then the keys of :attr: state_dict must exactly match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. .. warning:: If :attr: assign is True the optimizer must be created after the call to :attr: load_state_dict unless :func: ~torch.__future__.get_swap_module_params_on_conversion is True . Args: state_dict (dict): a dict containing parameters and persistent buffers. strict (bool, optional): whether to strictly enforce that the keys in :attr: state_dict match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. Default: True assign (bool, optional): When set to False , the properties of the tensors in the current module are preserved whereas setting it to True preserves properties of the Tensors in the state dict. The only exception is the requires_grad field of :class: ~torch.nn.Parameter s for which the value from the module is preserved. Default: False Returns: NamedTuple with missing_keys and unexpected_keys fields: * missing_keys is a list of str containing any keys that are expected by this module but missing from the provided state_dict . * unexpected_keys is a list of str containing the keys that are not expected by this module but present in the provided state_dict . Note: If a parameter or buffer is registered as None and its corresponding key exists in :attr: state_dict , :meth: load_state_dict will raise a RuntimeError . load_state_dict(self, state_dict: Mapping[str, Any], strict: bool = True, assign: bool = False) modules Return an iterator over all modules in the network. Yields: Module: a module in the network Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.modules()): ... print(idx, '->', m) 0 -> Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) 1 -> Linear(in_features=2, out_features=2, bias=True) modules(self) -> Iterator[ForwardRef('Module')] mtia Move all model parameters and buffers to the MTIA. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on MTIA while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self mtia(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T named_buffers Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself. Args: prefix (str): prefix to prepend to all buffer names. recurse (bool, optional): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Defaults to True. remove_duplicate (bool, optional): whether to remove the duplicated buffers in the result. Defaults to True. Yields: (str, torch.Tensor): Tuple containing the name and buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, buf in self.named_buffers(): >>> if name in ['running_var']: >>> print(buf.size()) named_buffers(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.Tensor]] named_children Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself. Yields: (str, Module): Tuple containing a name and child module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, module in model.named_children(): >>> if name in ['conv4', 'conv5']: >>> print(module) named_children(self) -> Iterator[Tuple[str, ForwardRef('Module')]] named_modules Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself. Args: memo: a memo to store the set of modules already added to the result prefix: a prefix that will be added to the name of the module remove_duplicate: whether to remove the duplicated module instances in the result or not Yields: (str, Module): Tuple of name and module Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.named_modules()): ... print(idx, '->', m) 0 -> ('', Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) )) 1 -> ('0', Linear(in_features=2, out_features=2, bias=True)) named_modules(self, memo: Optional[Set[ForwardRef('Module')]] = None, prefix: str = '', remove_duplicate: bool = True) named_parameters Return an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself. Args: prefix (str): prefix to prepend to all parameter names. recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. remove_duplicate (bool, optional): whether to remove the duplicated parameters in the result. Defaults to True. Yields: (str, Parameter): Tuple containing the name and parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, param in self.named_parameters(): >>> if name in ['bias']: >>> print(param.size()) named_parameters(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.nn.parameter.Parameter]] parameters Return an iterator over module parameters. This is typically passed to an optimizer. Args: recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. Yields: Parameter: module parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for param in model.parameters(): >>> print(type(param), param.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) parameters(self, recurse: bool = True) -> Iterator[torch.nn.parameter.Parameter] register_backward_hook Register a backward hook on the module. This function is deprecated in favor of :meth: ~torch.nn.Module.register_full_backward_hook and the behavior of this function will change in future versions. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]]) -> torch.utils.hooks.RemovableHandle register_buffer Add a buffer to the module. This is typically used to register a buffer that should not to be considered a model parameter. For example, BatchNorm's running_mean is not a parameter, but is part of the module's state. Buffers, by default, are persistent and will be saved alongside parameters. This behavior can be changed by setting :attr: persistent to False . The only difference between a persistent buffer and a non-persistent buffer is that the latter will not be a part of this module's :attr: state_dict . Buffers can be accessed as attributes using given names. Args: name (str): name of the buffer. The buffer can be accessed from this module using the given name tensor (Tensor or None): buffer to be registered. If None , then operations that run on buffers, such as :attr: cuda , are ignored. If None , the buffer is not included in the module's :attr: state_dict . persistent (bool): whether the buffer is part of this module's :attr: state_dict . Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> self.register_buffer('running_mean', torch.zeros(num_features)) register_buffer(self, name: str, tensor: Optional[torch.Tensor], persistent: bool = True) -> None register_forward_hook Register a forward hook on the module. The hook will be called every time after :func: forward has computed an output. If with_kwargs is False or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the output. It can modify the input inplace but it will not have effect on forward since this is called after :func: forward is called. The hook should have the following signature:: hook(module, args, output) -> None or modified output If with_kwargs is True , the forward hook will be passed the kwargs given to the forward function and be expected to return the output possibly modified. The hook should have the following signature:: hook(module, args, kwargs, output) -> None or modified output Args: hook (Callable): The user defined hook to be registered. prepend (bool): If True , the provided hook will be fired before all existing forward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward hooks on this :class: torch.nn.modules.Module . Note that global forward hooks registered with :func: register_module_forward_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If True , the hook will be passed the kwargs given to the forward function. Default: False always_call (bool): If True the hook will be run regardless of whether an exception is raised while calling the Module. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...], Any], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any], Any], Optional[Any]]], *, prepend: bool = False, with_kwargs: bool = False, always_call: bool = False) -> torch.utils.hooks.RemovableHandle register_forward_pre_hook Register a forward pre-hook on the module. The hook will be called every time before :func: forward is invoked. If with_kwargs is false or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the input. User can either return a tuple or a single modified value in the hook. We will wrap the value into a tuple if a single value is returned (unless that value is already a tuple). The hook should have the following signature:: hook(module, args) -> None or modified input If with_kwargs is true, the forward pre-hook will be passed the kwargs given to the forward function. And if the hook modifies the input, both the args and kwargs should be returned. The hook should have the following signature:: hook(module, args, kwargs) -> None or a tuple of modified input and kwargs Args: hook (Callable): The user defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing forward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward_pre hooks on this :class: torch.nn.modules.Module . Note that global forward_pre hooks registered with :func: register_module_forward_pre_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If true, the hook will be passed the kwargs given to the forward function. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_pre_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...]], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any]], Optional[Tuple[Any, Dict[str, Any]]]]], *, prepend: bool = False, with_kwargs: bool = False) -> torch.utils.hooks.RemovableHandle register_full_backward_hook Register a backward hook on the module. The hook will be called every time the gradients with respect to a module are computed, i.e. the hook will execute if and only if the gradients with respect to module outputs are computed. The hook should have the following signature:: hook(module, grad_input, grad_output) -> tuple(Tensor) or None The :attr: grad_input and :attr: grad_output are tuples that contain the gradients with respect to the inputs and outputs respectively. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the input that will be used in place of :attr: grad_input in subsequent computations. :attr: grad_input will only correspond to the inputs given as positional arguments and all kwarg arguments are ignored. Entries in :attr: grad_input and :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs or outputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward hooks on this :class: torch.nn.modules.Module . Note that global backward hooks registered with :func: register_module_full_backward_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle register_full_backward_pre_hook Register a backward pre-hook on the module. The hook will be called every time the gradients for the module are computed. The hook should have the following signature:: hook(module, grad_output) -> tuple[Tensor] or None The :attr: grad_output is a tuple. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the output that will be used in place of :attr: grad_output in subsequent computations. Entries in :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward_pre hooks on this :class: torch.nn.modules.Module . Note that global backward_pre hooks registered with :func: register_module_full_backward_pre_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_pre_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle register_load_state_dict_post_hook Register a post-hook to be run after module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, incompatible_keys) -> None The module argument is the current module that this hook is registered on, and the incompatible_keys argument is a NamedTuple consisting of attributes missing_keys and unexpected_keys . missing_keys is a list of str containing the missing keys and unexpected_keys is a list of str containing the unexpected keys. The given incompatible_keys can be modified inplace if needed. Note that the checks performed when calling :func: load_state_dict with strict=True are affected by modifications the hook makes to missing_keys or unexpected_keys , as expected. Additions to either set of keys will result in an error being thrown when strict=True , and clearing out both missing and unexpected keys will avoid an error. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_load_state_dict_post_hook(self, hook) register_load_state_dict_pre_hook Register a pre-hook to be run before module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs) -> None # noqa: B950 Arguments: hook (Callable): Callable hook that will be invoked before loading the state dict. register_load_state_dict_pre_hook(self, hook) register_module Alias for :func: add_module . register_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None register_parameter Add a parameter to the module. The parameter can be accessed as an attribute using given name. Args: name (str): name of the parameter. The parameter can be accessed from this module using the given name param (Parameter or None): parameter to be added to the module. If None , then operations that run on parameters, such as :attr: cuda , are ignored. If None , the parameter is not included in the module's :attr: state_dict . register_parameter(self, name: str, param: Optional[torch.nn.parameter.Parameter]) -> None register_state_dict_post_hook Register a post-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, state_dict, prefix, local_metadata) -> None The registered hooks can modify the state_dict inplace. register_state_dict_post_hook(self, hook) register_state_dict_pre_hook Register a pre-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, prefix, keep_vars) -> None The registered hooks can be used to perform pre-processing before the state_dict call is made. register_state_dict_pre_hook(self, hook) requires_grad_ Change if autograd should record operations on parameters in this module. This method sets the parameters' :attr: requires_grad attributes in-place. This method is helpful for freezing part of the module for finetuning or training parts of a model individually (e.g., GAN training). See :ref: locally-disable-grad-doc for a comparison between .requires_grad_() and several similar mechanisms that may be confused with it. Args: requires_grad (bool): whether autograd should record operations on parameters in this module. Default: True . Returns: Module: self requires_grad_(self: ~T, requires_grad: bool = True) -> ~T set_extra_state Set extra state contained in the loaded state_dict . This function is called from :func: load_state_dict to handle any extra state found within the state_dict . Implement this function and a corresponding :func: get_extra_state for your module if you need to store extra state within its state_dict . Args: state (dict): Extra state from the state_dict set_extra_state(self, state: Any) -> None set_submodule Set the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To overide the Conv2d with a new submodule Linear , you would call set_submodule(\"net_b.net_c.conv\", nn.Linear(33, 16)) . Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) module: The module to set the submodule to. Raises: ValueError: If the target string is empty AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module set_submodule(self, target: str, module: 'Module') -> None share_memory See :meth: torch.Tensor.share_memory_ . share_memory(self: ~T) -> ~T state_dict Return a dictionary containing references to the whole state of the module. Both parameters and persistent buffers (e.g. running averages) are included. Keys are corresponding parameter and buffer names. Parameters and buffers set to None are not included. .. note:: The returned object is a shallow copy. It contains references to the module's parameters and buffers. .. warning:: Currently state_dict() also accepts positional arguments for destination , prefix and keep_vars in order. However, this is being deprecated and keyword arguments will be enforced in future releases. .. warning:: Please avoid the use of argument destination as it is not designed for end-users. Args: destination (dict, optional): If provided, the state of module will be updated into the dict and the same object is returned. Otherwise, an OrderedDict will be created and returned. Default: None . prefix (str, optional): a prefix added to parameter and buffer names to compose the keys in state_dict. Default: '' . keep_vars (bool, optional): by default the :class: ~torch.Tensor s returned in the state dict are detached from autograd. If it's set to True , detaching will not be performed. Default: False . Returns: dict: a dictionary containing a whole state of the module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> module.state_dict().keys() ['bias', 'weight'] state_dict(self, *args, destination=None, prefix='', keep_vars=False) to Move and/or cast the parameters and buffers. This can be called as .. function:: to(device=None, dtype=None, non_blocking=False) :noindex: .. function:: to(dtype, non_blocking=False) :noindex: .. function:: to(tensor, non_blocking=False) :noindex: .. function:: to(memory_format=torch.channels_last) :noindex: Its signature is similar to :meth: torch.Tensor.to , but only accepts floating point or complex :attr: dtype \\ s. In addition, this method will only cast the floating point or complex parameters and buffers to :attr: dtype (if given). The integral parameters and buffers will be moved :attr: device , if that is given, but with dtypes unchanged. When :attr: non_blocking is set, it tries to convert/move asynchronously with respect to the host if possible, e.g., moving CPU Tensors with pinned memory to CUDA devices. See below for examples. .. note:: This method modifies the module in-place. Args: device (:class: torch.device ): the desired device of the parameters and buffers in this module dtype (:class: torch.dtype ): the desired floating point or complex dtype of the parameters and buffers in this module tensor (torch.Tensor): Tensor whose dtype and device are the desired dtype and device for all parameters and buffers in this module memory_format (:class: torch.memory_format ): the desired memory format for 4D parameters and buffers in this module (keyword only argument) Returns: Module: self Examples:: >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\") >>> linear = nn.Linear(2, 2) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]]) >>> linear.to(torch.double) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]], dtype=torch.float64) >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA1) >>> gpu1 = torch.device(\"cuda:1\") >>> linear.to(gpu1, dtype=torch.half, non_blocking=True) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1') >>> cpu = torch.device(\"cpu\") >>> linear.to(cpu) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16) >>> linear = nn.Linear(2, 2, bias=None).to(torch.cdouble) >>> linear.weight Parameter containing: tensor([[ 0.3741+0.j, 0.2382+0.j], [ 0.5593+0.j, -0.4443+0.j]], dtype=torch.complex128) >>> linear(torch.ones(3, 2, dtype=torch.cdouble)) tensor([[0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j]], dtype=torch.complex128) to(self, *args, **kwargs) to_empty Move the parameters and buffers to the specified device without copying storage. Args: device (:class: torch.device ): The desired device of the parameters and buffers in this module. recurse (bool): Whether parameters and buffers of submodules should be recursively moved to the specified device. Returns: Module: self to_empty(self: ~T, *, device: Union[int, str, torch.device, NoneType], recurse: bool = True) -> ~T train Set the module in training mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e., whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. Args: mode (bool): whether to set training mode ( True ) or evaluation mode ( False ). Default: True . Returns: Module: self train(self: ~T, mode: bool = True) -> ~T type Casts all parameters and buffers to :attr: dst_type . .. note:: This method modifies the module in-place. Args: dst_type (type or string): the desired type Returns: Module: self type(self: ~T, dst_type: Union[torch.dtype, str]) -> ~T xpu Move all model parameters and buffers to the XPU. This also makes associated parameters and buffers different objects. So it should be called before constructing optimizer if the module will live on XPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self xpu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T zero_grad Reset gradients of all model parameters. See similar function under :class: torch.optim.Optimizer for more context. Args: set_to_none (bool): instead of setting to zero, set the grads to None. See :meth: torch.optim.Optimizer.zero_grad for details. zero_grad(self, set_to_none: bool = True) -> None","title":"src.model.multi_head_latent_attention"},{"location":"src_model_multi_head_latent_attention/#srcmodelmulti_head_latent_attention","text":"","title":"src.model.multi_head_latent_attention"},{"location":"src_model_multi_head_latent_attention/#classes","text":"","title":"Classes"},{"location":"src_model_multi_head_latent_attention/#multiheadlatentattention","text":"Multi-Head Latent Attention implementation based on DeepSeek's approach. Reduces KV cache size by projecting into a shared latent space.","title":"MultiHeadLatentAttention"},{"location":"src_model_multi_head_latent_attention/#methods","text":"","title":"Methods"},{"location":"src_model_multi_head_latent_attention/#__init__","text":"__init__(self, config)","title":"__init__"},{"location":"src_model_multi_head_latent_attention/#add_module","text":"Add a child module to the current module. The module can be accessed as an attribute using the given name. Args: name (str): name of the child module. The child module can be accessed from this module using the given name module (Module): child module to be added to the module. add_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None","title":"add_module"},{"location":"src_model_multi_head_latent_attention/#apply","text":"Apply fn recursively to every submodule (as returned by .children() ) as well as self. Typical use includes initializing the parameters of a model (see also :ref: nn-init-doc ). Args: fn (:class: Module -> None): function to be applied to each submodule Returns: Module: self Example:: >>> @torch.no_grad() >>> def init_weights(m): >>> print(m) >>> if type(m) == nn.Linear: >>> m.weight.fill_(1.0) >>> print(m.weight) >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2)) >>> net.apply(init_weights) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) apply(self: ~T, fn: Callable[[ForwardRef('Module')], NoneType]) -> ~T","title":"apply"},{"location":"src_model_multi_head_latent_attention/#bfloat16","text":"Casts all floating point parameters and buffers to bfloat16 datatype. .. note:: This method modifies the module in-place. Returns: Module: self bfloat16(self: ~T) -> ~T","title":"bfloat16"},{"location":"src_model_multi_head_latent_attention/#buffers","text":"Return an iterator over module buffers. Args: recurse (bool): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Yields: torch.Tensor: module buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for buf in model.buffers(): >>> print(type(buf), buf.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) buffers(self, recurse: bool = True) -> Iterator[torch.Tensor]","title":"buffers"},{"location":"src_model_multi_head_latent_attention/#children","text":"Return an iterator over immediate children modules. Yields: Module: a child module children(self) -> Iterator[ForwardRef('Module')]","title":"children"},{"location":"src_model_multi_head_latent_attention/#compile","text":"Compile this Module's forward using :func: torch.compile . This Module's __call__ method is compiled and all arguments are passed as-is to :func: torch.compile . See :func: torch.compile for details on the arguments for this function. compile(self, *args, **kwargs)","title":"compile"},{"location":"src_model_multi_head_latent_attention/#cpu","text":"Move all model parameters and buffers to the CPU. .. note:: This method modifies the module in-place. Returns: Module: self cpu(self: ~T) -> ~T","title":"cpu"},{"location":"src_model_multi_head_latent_attention/#cuda","text":"Move all model parameters and buffers to the GPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on GPU while being optimized. .. note:: This method modifies the module in-place. Args: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self cuda(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"cuda"},{"location":"src_model_multi_head_latent_attention/#double","text":"Casts all floating point parameters and buffers to double datatype. .. note:: This method modifies the module in-place. Returns: Module: self double(self: ~T) -> ~T","title":"double"},{"location":"src_model_multi_head_latent_attention/#eval","text":"Set the module in evaluation mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e. whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. This is equivalent with :meth: self.train(False) <torch.nn.Module.train> . See :ref: locally-disable-grad-doc for a comparison between .eval() and several similar mechanisms that may be confused with it. Returns: Module: self eval(self: ~T) -> ~T","title":"eval"},{"location":"src_model_multi_head_latent_attention/#extra_repr","text":"Return the extra representation of the module. To print customized extra information, you should re-implement this method in your own modules. Both single-line and multi-line strings are acceptable. extra_repr(self) -> str","title":"extra_repr"},{"location":"src_model_multi_head_latent_attention/#float","text":"Casts all floating point parameters and buffers to float datatype. .. note:: This method modifies the module in-place. Returns: Module: self float(self: ~T) -> ~T","title":"float"},{"location":"src_model_multi_head_latent_attention/#forward","text":"forward(self, hidden_states, attention_mask=None, position_bias=None, head_mask=None, past_key_value=None, use_cache=False, output_attentions=False, sliding_window_size=None)","title":"forward"},{"location":"src_model_multi_head_latent_attention/#get_buffer","text":"Return the buffer given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the buffer to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.Tensor: The buffer referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not a buffer get_buffer(self, target: str) -> 'Tensor'","title":"get_buffer"},{"location":"src_model_multi_head_latent_attention/#get_extra_state","text":"Return any extra state to include in the module's state_dict. Implement this and a corresponding :func: set_extra_state for your module if you need to store extra state. This function is called when building the module's state_dict() . Note that extra state should be picklable to ensure working serialization of the state_dict. We only provide backwards compatibility guarantees for serializing Tensors; other objects may break backwards compatibility if their serialized pickled form changes. Returns: object: Any extra state to store in the module's state_dict get_extra_state(self) -> Any","title":"get_extra_state"},{"location":"src_model_multi_head_latent_attention/#get_parameter","text":"Return the parameter given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the Parameter to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.nn.Parameter: The Parameter referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Parameter get_parameter(self, target: str) -> 'Parameter'","title":"get_parameter"},{"location":"src_model_multi_head_latent_attention/#get_submodule","text":"Return the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A which has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To check whether or not we have the linear submodule, we would call get_submodule(\"net_b.linear\") . To check whether we have the conv submodule, we would call get_submodule(\"net_b.net_c.conv\") . The runtime of get_submodule is bounded by the degree of module nesting in target . A query against named_modules achieves the same result, but it is O(N) in the number of transitive modules. So, for a simple check to see if some submodule exists, get_submodule should always be used. Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) Returns: torch.nn.Module: The submodule referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module get_submodule(self, target: str) -> 'Module'","title":"get_submodule"},{"location":"src_model_multi_head_latent_attention/#half","text":"Casts all floating point parameters and buffers to half datatype. .. note:: This method modifies the module in-place. Returns: Module: self half(self: ~T) -> ~T","title":"half"},{"location":"src_model_multi_head_latent_attention/#ipu","text":"Move all model parameters and buffers to the IPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on IPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self ipu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"ipu"},{"location":"src_model_multi_head_latent_attention/#load_state_dict","text":"Copy parameters and buffers from :attr: state_dict into this module and its descendants. If :attr: strict is True , then the keys of :attr: state_dict must exactly match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. .. warning:: If :attr: assign is True the optimizer must be created after the call to :attr: load_state_dict unless :func: ~torch.__future__.get_swap_module_params_on_conversion is True . Args: state_dict (dict): a dict containing parameters and persistent buffers. strict (bool, optional): whether to strictly enforce that the keys in :attr: state_dict match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. Default: True assign (bool, optional): When set to False , the properties of the tensors in the current module are preserved whereas setting it to True preserves properties of the Tensors in the state dict. The only exception is the requires_grad field of :class: ~torch.nn.Parameter s for which the value from the module is preserved. Default: False Returns: NamedTuple with missing_keys and unexpected_keys fields: * missing_keys is a list of str containing any keys that are expected by this module but missing from the provided state_dict . * unexpected_keys is a list of str containing the keys that are not expected by this module but present in the provided state_dict . Note: If a parameter or buffer is registered as None and its corresponding key exists in :attr: state_dict , :meth: load_state_dict will raise a RuntimeError . load_state_dict(self, state_dict: Mapping[str, Any], strict: bool = True, assign: bool = False)","title":"load_state_dict"},{"location":"src_model_multi_head_latent_attention/#modules","text":"Return an iterator over all modules in the network. Yields: Module: a module in the network Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.modules()): ... print(idx, '->', m) 0 -> Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) 1 -> Linear(in_features=2, out_features=2, bias=True) modules(self) -> Iterator[ForwardRef('Module')]","title":"modules"},{"location":"src_model_multi_head_latent_attention/#mtia","text":"Move all model parameters and buffers to the MTIA. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on MTIA while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self mtia(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"mtia"},{"location":"src_model_multi_head_latent_attention/#named_buffers","text":"Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself. Args: prefix (str): prefix to prepend to all buffer names. recurse (bool, optional): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Defaults to True. remove_duplicate (bool, optional): whether to remove the duplicated buffers in the result. Defaults to True. Yields: (str, torch.Tensor): Tuple containing the name and buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, buf in self.named_buffers(): >>> if name in ['running_var']: >>> print(buf.size()) named_buffers(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.Tensor]]","title":"named_buffers"},{"location":"src_model_multi_head_latent_attention/#named_children","text":"Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself. Yields: (str, Module): Tuple containing a name and child module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, module in model.named_children(): >>> if name in ['conv4', 'conv5']: >>> print(module) named_children(self) -> Iterator[Tuple[str, ForwardRef('Module')]]","title":"named_children"},{"location":"src_model_multi_head_latent_attention/#named_modules","text":"Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself. Args: memo: a memo to store the set of modules already added to the result prefix: a prefix that will be added to the name of the module remove_duplicate: whether to remove the duplicated module instances in the result or not Yields: (str, Module): Tuple of name and module Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.named_modules()): ... print(idx, '->', m) 0 -> ('', Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) )) 1 -> ('0', Linear(in_features=2, out_features=2, bias=True)) named_modules(self, memo: Optional[Set[ForwardRef('Module')]] = None, prefix: str = '', remove_duplicate: bool = True)","title":"named_modules"},{"location":"src_model_multi_head_latent_attention/#named_parameters","text":"Return an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself. Args: prefix (str): prefix to prepend to all parameter names. recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. remove_duplicate (bool, optional): whether to remove the duplicated parameters in the result. Defaults to True. Yields: (str, Parameter): Tuple containing the name and parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, param in self.named_parameters(): >>> if name in ['bias']: >>> print(param.size()) named_parameters(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.nn.parameter.Parameter]]","title":"named_parameters"},{"location":"src_model_multi_head_latent_attention/#parameters","text":"Return an iterator over module parameters. This is typically passed to an optimizer. Args: recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. Yields: Parameter: module parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for param in model.parameters(): >>> print(type(param), param.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) parameters(self, recurse: bool = True) -> Iterator[torch.nn.parameter.Parameter]","title":"parameters"},{"location":"src_model_multi_head_latent_attention/#register_backward_hook","text":"Register a backward hook on the module. This function is deprecated in favor of :meth: ~torch.nn.Module.register_full_backward_hook and the behavior of this function will change in future versions. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]]) -> torch.utils.hooks.RemovableHandle","title":"register_backward_hook"},{"location":"src_model_multi_head_latent_attention/#register_buffer","text":"Add a buffer to the module. This is typically used to register a buffer that should not to be considered a model parameter. For example, BatchNorm's running_mean is not a parameter, but is part of the module's state. Buffers, by default, are persistent and will be saved alongside parameters. This behavior can be changed by setting :attr: persistent to False . The only difference between a persistent buffer and a non-persistent buffer is that the latter will not be a part of this module's :attr: state_dict . Buffers can be accessed as attributes using given names. Args: name (str): name of the buffer. The buffer can be accessed from this module using the given name tensor (Tensor or None): buffer to be registered. If None , then operations that run on buffers, such as :attr: cuda , are ignored. If None , the buffer is not included in the module's :attr: state_dict . persistent (bool): whether the buffer is part of this module's :attr: state_dict . Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> self.register_buffer('running_mean', torch.zeros(num_features)) register_buffer(self, name: str, tensor: Optional[torch.Tensor], persistent: bool = True) -> None","title":"register_buffer"},{"location":"src_model_multi_head_latent_attention/#register_forward_hook","text":"Register a forward hook on the module. The hook will be called every time after :func: forward has computed an output. If with_kwargs is False or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the output. It can modify the input inplace but it will not have effect on forward since this is called after :func: forward is called. The hook should have the following signature:: hook(module, args, output) -> None or modified output If with_kwargs is True , the forward hook will be passed the kwargs given to the forward function and be expected to return the output possibly modified. The hook should have the following signature:: hook(module, args, kwargs, output) -> None or modified output Args: hook (Callable): The user defined hook to be registered. prepend (bool): If True , the provided hook will be fired before all existing forward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward hooks on this :class: torch.nn.modules.Module . Note that global forward hooks registered with :func: register_module_forward_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If True , the hook will be passed the kwargs given to the forward function. Default: False always_call (bool): If True the hook will be run regardless of whether an exception is raised while calling the Module. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...], Any], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any], Any], Optional[Any]]], *, prepend: bool = False, with_kwargs: bool = False, always_call: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_forward_hook"},{"location":"src_model_multi_head_latent_attention/#register_forward_pre_hook","text":"Register a forward pre-hook on the module. The hook will be called every time before :func: forward is invoked. If with_kwargs is false or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the input. User can either return a tuple or a single modified value in the hook. We will wrap the value into a tuple if a single value is returned (unless that value is already a tuple). The hook should have the following signature:: hook(module, args) -> None or modified input If with_kwargs is true, the forward pre-hook will be passed the kwargs given to the forward function. And if the hook modifies the input, both the args and kwargs should be returned. The hook should have the following signature:: hook(module, args, kwargs) -> None or a tuple of modified input and kwargs Args: hook (Callable): The user defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing forward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward_pre hooks on this :class: torch.nn.modules.Module . Note that global forward_pre hooks registered with :func: register_module_forward_pre_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If true, the hook will be passed the kwargs given to the forward function. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_pre_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...]], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any]], Optional[Tuple[Any, Dict[str, Any]]]]], *, prepend: bool = False, with_kwargs: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_forward_pre_hook"},{"location":"src_model_multi_head_latent_attention/#register_full_backward_hook","text":"Register a backward hook on the module. The hook will be called every time the gradients with respect to a module are computed, i.e. the hook will execute if and only if the gradients with respect to module outputs are computed. The hook should have the following signature:: hook(module, grad_input, grad_output) -> tuple(Tensor) or None The :attr: grad_input and :attr: grad_output are tuples that contain the gradients with respect to the inputs and outputs respectively. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the input that will be used in place of :attr: grad_input in subsequent computations. :attr: grad_input will only correspond to the inputs given as positional arguments and all kwarg arguments are ignored. Entries in :attr: grad_input and :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs or outputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward hooks on this :class: torch.nn.modules.Module . Note that global backward hooks registered with :func: register_module_full_backward_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_full_backward_hook"},{"location":"src_model_multi_head_latent_attention/#register_full_backward_pre_hook","text":"Register a backward pre-hook on the module. The hook will be called every time the gradients for the module are computed. The hook should have the following signature:: hook(module, grad_output) -> tuple[Tensor] or None The :attr: grad_output is a tuple. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the output that will be used in place of :attr: grad_output in subsequent computations. Entries in :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward_pre hooks on this :class: torch.nn.modules.Module . Note that global backward_pre hooks registered with :func: register_module_full_backward_pre_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_pre_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_full_backward_pre_hook"},{"location":"src_model_multi_head_latent_attention/#register_load_state_dict_post_hook","text":"Register a post-hook to be run after module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, incompatible_keys) -> None The module argument is the current module that this hook is registered on, and the incompatible_keys argument is a NamedTuple consisting of attributes missing_keys and unexpected_keys . missing_keys is a list of str containing the missing keys and unexpected_keys is a list of str containing the unexpected keys. The given incompatible_keys can be modified inplace if needed. Note that the checks performed when calling :func: load_state_dict with strict=True are affected by modifications the hook makes to missing_keys or unexpected_keys , as expected. Additions to either set of keys will result in an error being thrown when strict=True , and clearing out both missing and unexpected keys will avoid an error. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_load_state_dict_post_hook(self, hook)","title":"register_load_state_dict_post_hook"},{"location":"src_model_multi_head_latent_attention/#register_load_state_dict_pre_hook","text":"Register a pre-hook to be run before module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs) -> None # noqa: B950 Arguments: hook (Callable): Callable hook that will be invoked before loading the state dict. register_load_state_dict_pre_hook(self, hook)","title":"register_load_state_dict_pre_hook"},{"location":"src_model_multi_head_latent_attention/#register_module","text":"Alias for :func: add_module . register_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None","title":"register_module"},{"location":"src_model_multi_head_latent_attention/#register_parameter","text":"Add a parameter to the module. The parameter can be accessed as an attribute using given name. Args: name (str): name of the parameter. The parameter can be accessed from this module using the given name param (Parameter or None): parameter to be added to the module. If None , then operations that run on parameters, such as :attr: cuda , are ignored. If None , the parameter is not included in the module's :attr: state_dict . register_parameter(self, name: str, param: Optional[torch.nn.parameter.Parameter]) -> None","title":"register_parameter"},{"location":"src_model_multi_head_latent_attention/#register_state_dict_post_hook","text":"Register a post-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, state_dict, prefix, local_metadata) -> None The registered hooks can modify the state_dict inplace. register_state_dict_post_hook(self, hook)","title":"register_state_dict_post_hook"},{"location":"src_model_multi_head_latent_attention/#register_state_dict_pre_hook","text":"Register a pre-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, prefix, keep_vars) -> None The registered hooks can be used to perform pre-processing before the state_dict call is made. register_state_dict_pre_hook(self, hook)","title":"register_state_dict_pre_hook"},{"location":"src_model_multi_head_latent_attention/#requires_grad_","text":"Change if autograd should record operations on parameters in this module. This method sets the parameters' :attr: requires_grad attributes in-place. This method is helpful for freezing part of the module for finetuning or training parts of a model individually (e.g., GAN training). See :ref: locally-disable-grad-doc for a comparison between .requires_grad_() and several similar mechanisms that may be confused with it. Args: requires_grad (bool): whether autograd should record operations on parameters in this module. Default: True . Returns: Module: self requires_grad_(self: ~T, requires_grad: bool = True) -> ~T","title":"requires_grad_"},{"location":"src_model_multi_head_latent_attention/#set_extra_state","text":"Set extra state contained in the loaded state_dict . This function is called from :func: load_state_dict to handle any extra state found within the state_dict . Implement this function and a corresponding :func: get_extra_state for your module if you need to store extra state within its state_dict . Args: state (dict): Extra state from the state_dict set_extra_state(self, state: Any) -> None","title":"set_extra_state"},{"location":"src_model_multi_head_latent_attention/#set_submodule","text":"Set the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To overide the Conv2d with a new submodule Linear , you would call set_submodule(\"net_b.net_c.conv\", nn.Linear(33, 16)) . Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) module: The module to set the submodule to. Raises: ValueError: If the target string is empty AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module set_submodule(self, target: str, module: 'Module') -> None","title":"set_submodule"},{"location":"src_model_multi_head_latent_attention/#share_memory","text":"See :meth: torch.Tensor.share_memory_ . share_memory(self: ~T) -> ~T","title":"share_memory"},{"location":"src_model_multi_head_latent_attention/#state_dict","text":"Return a dictionary containing references to the whole state of the module. Both parameters and persistent buffers (e.g. running averages) are included. Keys are corresponding parameter and buffer names. Parameters and buffers set to None are not included. .. note:: The returned object is a shallow copy. It contains references to the module's parameters and buffers. .. warning:: Currently state_dict() also accepts positional arguments for destination , prefix and keep_vars in order. However, this is being deprecated and keyword arguments will be enforced in future releases. .. warning:: Please avoid the use of argument destination as it is not designed for end-users. Args: destination (dict, optional): If provided, the state of module will be updated into the dict and the same object is returned. Otherwise, an OrderedDict will be created and returned. Default: None . prefix (str, optional): a prefix added to parameter and buffer names to compose the keys in state_dict. Default: '' . keep_vars (bool, optional): by default the :class: ~torch.Tensor s returned in the state dict are detached from autograd. If it's set to True , detaching will not be performed. Default: False . Returns: dict: a dictionary containing a whole state of the module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> module.state_dict().keys() ['bias', 'weight'] state_dict(self, *args, destination=None, prefix='', keep_vars=False)","title":"state_dict"},{"location":"src_model_multi_head_latent_attention/#to","text":"Move and/or cast the parameters and buffers. This can be called as .. function:: to(device=None, dtype=None, non_blocking=False) :noindex: .. function:: to(dtype, non_blocking=False) :noindex: .. function:: to(tensor, non_blocking=False) :noindex: .. function:: to(memory_format=torch.channels_last) :noindex: Its signature is similar to :meth: torch.Tensor.to , but only accepts floating point or complex :attr: dtype \\ s. In addition, this method will only cast the floating point or complex parameters and buffers to :attr: dtype (if given). The integral parameters and buffers will be moved :attr: device , if that is given, but with dtypes unchanged. When :attr: non_blocking is set, it tries to convert/move asynchronously with respect to the host if possible, e.g., moving CPU Tensors with pinned memory to CUDA devices. See below for examples. .. note:: This method modifies the module in-place. Args: device (:class: torch.device ): the desired device of the parameters and buffers in this module dtype (:class: torch.dtype ): the desired floating point or complex dtype of the parameters and buffers in this module tensor (torch.Tensor): Tensor whose dtype and device are the desired dtype and device for all parameters and buffers in this module memory_format (:class: torch.memory_format ): the desired memory format for 4D parameters and buffers in this module (keyword only argument) Returns: Module: self Examples:: >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\") >>> linear = nn.Linear(2, 2) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]]) >>> linear.to(torch.double) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]], dtype=torch.float64) >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA1) >>> gpu1 = torch.device(\"cuda:1\") >>> linear.to(gpu1, dtype=torch.half, non_blocking=True) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1') >>> cpu = torch.device(\"cpu\") >>> linear.to(cpu) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16) >>> linear = nn.Linear(2, 2, bias=None).to(torch.cdouble) >>> linear.weight Parameter containing: tensor([[ 0.3741+0.j, 0.2382+0.j], [ 0.5593+0.j, -0.4443+0.j]], dtype=torch.complex128) >>> linear(torch.ones(3, 2, dtype=torch.cdouble)) tensor([[0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j]], dtype=torch.complex128) to(self, *args, **kwargs)","title":"to"},{"location":"src_model_multi_head_latent_attention/#to_empty","text":"Move the parameters and buffers to the specified device without copying storage. Args: device (:class: torch.device ): The desired device of the parameters and buffers in this module. recurse (bool): Whether parameters and buffers of submodules should be recursively moved to the specified device. Returns: Module: self to_empty(self: ~T, *, device: Union[int, str, torch.device, NoneType], recurse: bool = True) -> ~T","title":"to_empty"},{"location":"src_model_multi_head_latent_attention/#train","text":"Set the module in training mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e., whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. Args: mode (bool): whether to set training mode ( True ) or evaluation mode ( False ). Default: True . Returns: Module: self train(self: ~T, mode: bool = True) -> ~T","title":"train"},{"location":"src_model_multi_head_latent_attention/#type","text":"Casts all parameters and buffers to :attr: dst_type . .. note:: This method modifies the module in-place. Args: dst_type (type or string): the desired type Returns: Module: self type(self: ~T, dst_type: Union[torch.dtype, str]) -> ~T","title":"type"},{"location":"src_model_multi_head_latent_attention/#xpu","text":"Move all model parameters and buffers to the XPU. This also makes associated parameters and buffers different objects. So it should be called before constructing optimizer if the module will live on XPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self xpu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"xpu"},{"location":"src_model_multi_head_latent_attention/#zero_grad","text":"Reset gradients of all model parameters. See similar function under :class: torch.optim.Optimizer for more context. Args: set_to_none (bool): instead of setting to zero, set the grads to None. See :meth: torch.optim.Optimizer.zero_grad for details. zero_grad(self, set_to_none: bool = True) -> None","title":"zero_grad"},{"location":"src_model_sparse_mlp/","text":"src.model.sparse_mlp Classes SparseMLP Methods __init__ __init__(self, config) add_module Add a child module to the current module. The module can be accessed as an attribute using the given name. Args: name (str): name of the child module. The child module can be accessed from this module using the given name module (Module): child module to be added to the module. add_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None apply Apply fn recursively to every submodule (as returned by .children() ) as well as self. Typical use includes initializing the parameters of a model (see also :ref: nn-init-doc ). Args: fn (:class: Module -> None): function to be applied to each submodule Returns: Module: self Example:: >>> @torch.no_grad() >>> def init_weights(m): >>> print(m) >>> if type(m) == nn.Linear: >>> m.weight.fill_(1.0) >>> print(m.weight) >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2)) >>> net.apply(init_weights) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) apply(self: ~T, fn: Callable[[ForwardRef('Module')], NoneType]) -> ~T apply_sparsity_masks Apply sparsity masks to weights. apply_sparsity_masks(self) bfloat16 Casts all floating point parameters and buffers to bfloat16 datatype. .. note:: This method modifies the module in-place. Returns: Module: self bfloat16(self: ~T) -> ~T buffers Return an iterator over module buffers. Args: recurse (bool): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Yields: torch.Tensor: module buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for buf in model.buffers(): >>> print(type(buf), buf.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) buffers(self, recurse: bool = True) -> Iterator[torch.Tensor] children Return an iterator over immediate children modules. Yields: Module: a child module children(self) -> Iterator[ForwardRef('Module')] compile Compile this Module's forward using :func: torch.compile . This Module's __call__ method is compiled and all arguments are passed as-is to :func: torch.compile . See :func: torch.compile for details on the arguments for this function. compile(self, *args, **kwargs) cpu Move all model parameters and buffers to the CPU. .. note:: This method modifies the module in-place. Returns: Module: self cpu(self: ~T) -> ~T cuda Move all model parameters and buffers to the GPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on GPU while being optimized. .. note:: This method modifies the module in-place. Args: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self cuda(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T double Casts all floating point parameters and buffers to double datatype. .. note:: This method modifies the module in-place. Returns: Module: self double(self: ~T) -> ~T eval Set the module in evaluation mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e. whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. This is equivalent with :meth: self.train(False) <torch.nn.Module.train> . See :ref: locally-disable-grad-doc for a comparison between .eval() and several similar mechanisms that may be confused with it. Returns: Module: self eval(self: ~T) -> ~T extra_repr Return the extra representation of the module. To print customized extra information, you should re-implement this method in your own modules. Both single-line and multi-line strings are acceptable. extra_repr(self) -> str float Casts all floating point parameters and buffers to float datatype. .. note:: This method modifies the module in-place. Returns: Module: self float(self: ~T) -> ~T forward forward(self, hidden_states) get_activation_mask Generate activation sparsity mask with the correct dimensions. Args: shape: Tuple (batch_size, seq_length, dim) device: The device to create the mask on Returns: A sparsity mask tensor of shape (batch_size, seq_length, dim) get_activation_mask(self, shape, device) get_buffer Return the buffer given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the buffer to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.Tensor: The buffer referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not a buffer get_buffer(self, target: str) -> 'Tensor' get_extra_state Return any extra state to include in the module's state_dict. Implement this and a corresponding :func: set_extra_state for your module if you need to store extra state. This function is called when building the module's state_dict() . Note that extra state should be picklable to ensure working serialization of the state_dict. We only provide backwards compatibility guarantees for serializing Tensors; other objects may break backwards compatibility if their serialized pickled form changes. Returns: object: Any extra state to store in the module's state_dict get_extra_state(self) -> Any get_parameter Return the parameter given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the Parameter to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.nn.Parameter: The Parameter referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Parameter get_parameter(self, target: str) -> 'Parameter' get_submodule Return the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A which has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To check whether or not we have the linear submodule, we would call get_submodule(\"net_b.linear\") . To check whether we have the conv submodule, we would call get_submodule(\"net_b.net_c.conv\") . The runtime of get_submodule is bounded by the degree of module nesting in target . A query against named_modules achieves the same result, but it is O(N) in the number of transitive modules. So, for a simple check to see if some submodule exists, get_submodule should always be used. Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) Returns: torch.nn.Module: The submodule referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module get_submodule(self, target: str) -> 'Module' half Casts all floating point parameters and buffers to half datatype. .. note:: This method modifies the module in-place. Returns: Module: self half(self: ~T) -> ~T ipu Move all model parameters and buffers to the IPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on IPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self ipu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T load_state_dict Copy parameters and buffers from :attr: state_dict into this module and its descendants. If :attr: strict is True , then the keys of :attr: state_dict must exactly match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. .. warning:: If :attr: assign is True the optimizer must be created after the call to :attr: load_state_dict unless :func: ~torch.__future__.get_swap_module_params_on_conversion is True . Args: state_dict (dict): a dict containing parameters and persistent buffers. strict (bool, optional): whether to strictly enforce that the keys in :attr: state_dict match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. Default: True assign (bool, optional): When set to False , the properties of the tensors in the current module are preserved whereas setting it to True preserves properties of the Tensors in the state dict. The only exception is the requires_grad field of :class: ~torch.nn.Parameter s for which the value from the module is preserved. Default: False Returns: NamedTuple with missing_keys and unexpected_keys fields: * missing_keys is a list of str containing any keys that are expected by this module but missing from the provided state_dict . * unexpected_keys is a list of str containing the keys that are not expected by this module but present in the provided state_dict . Note: If a parameter or buffer is registered as None and its corresponding key exists in :attr: state_dict , :meth: load_state_dict will raise a RuntimeError . load_state_dict(self, state_dict: Mapping[str, Any], strict: bool = True, assign: bool = False) modules Return an iterator over all modules in the network. Yields: Module: a module in the network Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.modules()): ... print(idx, '->', m) 0 -> Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) 1 -> Linear(in_features=2, out_features=2, bias=True) modules(self) -> Iterator[ForwardRef('Module')] mtia Move all model parameters and buffers to the MTIA. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on MTIA while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self mtia(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T named_buffers Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself. Args: prefix (str): prefix to prepend to all buffer names. recurse (bool, optional): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Defaults to True. remove_duplicate (bool, optional): whether to remove the duplicated buffers in the result. Defaults to True. Yields: (str, torch.Tensor): Tuple containing the name and buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, buf in self.named_buffers(): >>> if name in ['running_var']: >>> print(buf.size()) named_buffers(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.Tensor]] named_children Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself. Yields: (str, Module): Tuple containing a name and child module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, module in model.named_children(): >>> if name in ['conv4', 'conv5']: >>> print(module) named_children(self) -> Iterator[Tuple[str, ForwardRef('Module')]] named_modules Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself. Args: memo: a memo to store the set of modules already added to the result prefix: a prefix that will be added to the name of the module remove_duplicate: whether to remove the duplicated module instances in the result or not Yields: (str, Module): Tuple of name and module Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.named_modules()): ... print(idx, '->', m) 0 -> ('', Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) )) 1 -> ('0', Linear(in_features=2, out_features=2, bias=True)) named_modules(self, memo: Optional[Set[ForwardRef('Module')]] = None, prefix: str = '', remove_duplicate: bool = True) named_parameters Return an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself. Args: prefix (str): prefix to prepend to all parameter names. recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. remove_duplicate (bool, optional): whether to remove the duplicated parameters in the result. Defaults to True. Yields: (str, Parameter): Tuple containing the name and parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, param in self.named_parameters(): >>> if name in ['bias']: >>> print(param.size()) named_parameters(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.nn.parameter.Parameter]] parameters Return an iterator over module parameters. This is typically passed to an optimizer. Args: recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. Yields: Parameter: module parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for param in model.parameters(): >>> print(type(param), param.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) parameters(self, recurse: bool = True) -> Iterator[torch.nn.parameter.Parameter] register_backward_hook Register a backward hook on the module. This function is deprecated in favor of :meth: ~torch.nn.Module.register_full_backward_hook and the behavior of this function will change in future versions. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]]) -> torch.utils.hooks.RemovableHandle register_buffer Add a buffer to the module. This is typically used to register a buffer that should not to be considered a model parameter. For example, BatchNorm's running_mean is not a parameter, but is part of the module's state. Buffers, by default, are persistent and will be saved alongside parameters. This behavior can be changed by setting :attr: persistent to False . The only difference between a persistent buffer and a non-persistent buffer is that the latter will not be a part of this module's :attr: state_dict . Buffers can be accessed as attributes using given names. Args: name (str): name of the buffer. The buffer can be accessed from this module using the given name tensor (Tensor or None): buffer to be registered. If None , then operations that run on buffers, such as :attr: cuda , are ignored. If None , the buffer is not included in the module's :attr: state_dict . persistent (bool): whether the buffer is part of this module's :attr: state_dict . Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> self.register_buffer('running_mean', torch.zeros(num_features)) register_buffer(self, name: str, tensor: Optional[torch.Tensor], persistent: bool = True) -> None register_forward_hook Register a forward hook on the module. The hook will be called every time after :func: forward has computed an output. If with_kwargs is False or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the output. It can modify the input inplace but it will not have effect on forward since this is called after :func: forward is called. The hook should have the following signature:: hook(module, args, output) -> None or modified output If with_kwargs is True , the forward hook will be passed the kwargs given to the forward function and be expected to return the output possibly modified. The hook should have the following signature:: hook(module, args, kwargs, output) -> None or modified output Args: hook (Callable): The user defined hook to be registered. prepend (bool): If True , the provided hook will be fired before all existing forward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward hooks on this :class: torch.nn.modules.Module . Note that global forward hooks registered with :func: register_module_forward_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If True , the hook will be passed the kwargs given to the forward function. Default: False always_call (bool): If True the hook will be run regardless of whether an exception is raised while calling the Module. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...], Any], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any], Any], Optional[Any]]], *, prepend: bool = False, with_kwargs: bool = False, always_call: bool = False) -> torch.utils.hooks.RemovableHandle register_forward_pre_hook Register a forward pre-hook on the module. The hook will be called every time before :func: forward is invoked. If with_kwargs is false or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the input. User can either return a tuple or a single modified value in the hook. We will wrap the value into a tuple if a single value is returned (unless that value is already a tuple). The hook should have the following signature:: hook(module, args) -> None or modified input If with_kwargs is true, the forward pre-hook will be passed the kwargs given to the forward function. And if the hook modifies the input, both the args and kwargs should be returned. The hook should have the following signature:: hook(module, args, kwargs) -> None or a tuple of modified input and kwargs Args: hook (Callable): The user defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing forward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward_pre hooks on this :class: torch.nn.modules.Module . Note that global forward_pre hooks registered with :func: register_module_forward_pre_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If true, the hook will be passed the kwargs given to the forward function. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_pre_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...]], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any]], Optional[Tuple[Any, Dict[str, Any]]]]], *, prepend: bool = False, with_kwargs: bool = False) -> torch.utils.hooks.RemovableHandle register_full_backward_hook Register a backward hook on the module. The hook will be called every time the gradients with respect to a module are computed, i.e. the hook will execute if and only if the gradients with respect to module outputs are computed. The hook should have the following signature:: hook(module, grad_input, grad_output) -> tuple(Tensor) or None The :attr: grad_input and :attr: grad_output are tuples that contain the gradients with respect to the inputs and outputs respectively. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the input that will be used in place of :attr: grad_input in subsequent computations. :attr: grad_input will only correspond to the inputs given as positional arguments and all kwarg arguments are ignored. Entries in :attr: grad_input and :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs or outputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward hooks on this :class: torch.nn.modules.Module . Note that global backward hooks registered with :func: register_module_full_backward_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle register_full_backward_pre_hook Register a backward pre-hook on the module. The hook will be called every time the gradients for the module are computed. The hook should have the following signature:: hook(module, grad_output) -> tuple[Tensor] or None The :attr: grad_output is a tuple. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the output that will be used in place of :attr: grad_output in subsequent computations. Entries in :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward_pre hooks on this :class: torch.nn.modules.Module . Note that global backward_pre hooks registered with :func: register_module_full_backward_pre_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_pre_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle register_load_state_dict_post_hook Register a post-hook to be run after module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, incompatible_keys) -> None The module argument is the current module that this hook is registered on, and the incompatible_keys argument is a NamedTuple consisting of attributes missing_keys and unexpected_keys . missing_keys is a list of str containing the missing keys and unexpected_keys is a list of str containing the unexpected keys. The given incompatible_keys can be modified inplace if needed. Note that the checks performed when calling :func: load_state_dict with strict=True are affected by modifications the hook makes to missing_keys or unexpected_keys , as expected. Additions to either set of keys will result in an error being thrown when strict=True , and clearing out both missing and unexpected keys will avoid an error. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_load_state_dict_post_hook(self, hook) register_load_state_dict_pre_hook Register a pre-hook to be run before module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs) -> None # noqa: B950 Arguments: hook (Callable): Callable hook that will be invoked before loading the state dict. register_load_state_dict_pre_hook(self, hook) register_module Alias for :func: add_module . register_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None register_parameter Add a parameter to the module. The parameter can be accessed as an attribute using given name. Args: name (str): name of the parameter. The parameter can be accessed from this module using the given name param (Parameter or None): parameter to be added to the module. If None , then operations that run on parameters, such as :attr: cuda , are ignored. If None , the parameter is not included in the module's :attr: state_dict . register_parameter(self, name: str, param: Optional[torch.nn.parameter.Parameter]) -> None register_state_dict_post_hook Register a post-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, state_dict, prefix, local_metadata) -> None The registered hooks can modify the state_dict inplace. register_state_dict_post_hook(self, hook) register_state_dict_pre_hook Register a pre-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, prefix, keep_vars) -> None The registered hooks can be used to perform pre-processing before the state_dict call is made. register_state_dict_pre_hook(self, hook) requires_grad_ Change if autograd should record operations on parameters in this module. This method sets the parameters' :attr: requires_grad attributes in-place. This method is helpful for freezing part of the module for finetuning or training parts of a model individually (e.g., GAN training). See :ref: locally-disable-grad-doc for a comparison between .requires_grad_() and several similar mechanisms that may be confused with it. Args: requires_grad (bool): whether autograd should record operations on parameters in this module. Default: True . Returns: Module: self requires_grad_(self: ~T, requires_grad: bool = True) -> ~T set_extra_state Set extra state contained in the loaded state_dict . This function is called from :func: load_state_dict to handle any extra state found within the state_dict . Implement this function and a corresponding :func: get_extra_state for your module if you need to store extra state within its state_dict . Args: state (dict): Extra state from the state_dict set_extra_state(self, state: Any) -> None set_submodule Set the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To overide the Conv2d with a new submodule Linear , you would call set_submodule(\"net_b.net_c.conv\", nn.Linear(33, 16)) . Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) module: The module to set the submodule to. Raises: ValueError: If the target string is empty AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module set_submodule(self, target: str, module: 'Module') -> None share_memory See :meth: torch.Tensor.share_memory_ . share_memory(self: ~T) -> ~T state_dict Return a dictionary containing references to the whole state of the module. Both parameters and persistent buffers (e.g. running averages) are included. Keys are corresponding parameter and buffer names. Parameters and buffers set to None are not included. .. note:: The returned object is a shallow copy. It contains references to the module's parameters and buffers. .. warning:: Currently state_dict() also accepts positional arguments for destination , prefix and keep_vars in order. However, this is being deprecated and keyword arguments will be enforced in future releases. .. warning:: Please avoid the use of argument destination as it is not designed for end-users. Args: destination (dict, optional): If provided, the state of module will be updated into the dict and the same object is returned. Otherwise, an OrderedDict will be created and returned. Default: None . prefix (str, optional): a prefix added to parameter and buffer names to compose the keys in state_dict. Default: '' . keep_vars (bool, optional): by default the :class: ~torch.Tensor s returned in the state dict are detached from autograd. If it's set to True , detaching will not be performed. Default: False . Returns: dict: a dictionary containing a whole state of the module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> module.state_dict().keys() ['bias', 'weight'] state_dict(self, *args, destination=None, prefix='', keep_vars=False) to Move and/or cast the parameters and buffers. This can be called as .. function:: to(device=None, dtype=None, non_blocking=False) :noindex: .. function:: to(dtype, non_blocking=False) :noindex: .. function:: to(tensor, non_blocking=False) :noindex: .. function:: to(memory_format=torch.channels_last) :noindex: Its signature is similar to :meth: torch.Tensor.to , but only accepts floating point or complex :attr: dtype \\ s. In addition, this method will only cast the floating point or complex parameters and buffers to :attr: dtype (if given). The integral parameters and buffers will be moved :attr: device , if that is given, but with dtypes unchanged. When :attr: non_blocking is set, it tries to convert/move asynchronously with respect to the host if possible, e.g., moving CPU Tensors with pinned memory to CUDA devices. See below for examples. .. note:: This method modifies the module in-place. Args: device (:class: torch.device ): the desired device of the parameters and buffers in this module dtype (:class: torch.dtype ): the desired floating point or complex dtype of the parameters and buffers in this module tensor (torch.Tensor): Tensor whose dtype and device are the desired dtype and device for all parameters and buffers in this module memory_format (:class: torch.memory_format ): the desired memory format for 4D parameters and buffers in this module (keyword only argument) Returns: Module: self Examples:: >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\") >>> linear = nn.Linear(2, 2) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]]) >>> linear.to(torch.double) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]], dtype=torch.float64) >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA1) >>> gpu1 = torch.device(\"cuda:1\") >>> linear.to(gpu1, dtype=torch.half, non_blocking=True) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1') >>> cpu = torch.device(\"cpu\") >>> linear.to(cpu) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16) >>> linear = nn.Linear(2, 2, bias=None).to(torch.cdouble) >>> linear.weight Parameter containing: tensor([[ 0.3741+0.j, 0.2382+0.j], [ 0.5593+0.j, -0.4443+0.j]], dtype=torch.complex128) >>> linear(torch.ones(3, 2, dtype=torch.cdouble)) tensor([[0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j]], dtype=torch.complex128) to(self, *args, **kwargs) to_empty Move the parameters and buffers to the specified device without copying storage. Args: device (:class: torch.device ): The desired device of the parameters and buffers in this module. recurse (bool): Whether parameters and buffers of submodules should be recursively moved to the specified device. Returns: Module: self to_empty(self: ~T, *, device: Union[int, str, torch.device, NoneType], recurse: bool = True) -> ~T train Set the module in training mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e., whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. Args: mode (bool): whether to set training mode ( True ) or evaluation mode ( False ). Default: True . Returns: Module: self train(self: ~T, mode: bool = True) -> ~T type Casts all parameters and buffers to :attr: dst_type . .. note:: This method modifies the module in-place. Args: dst_type (type or string): the desired type Returns: Module: self type(self: ~T, dst_type: Union[torch.dtype, str]) -> ~T xpu Move all model parameters and buffers to the XPU. This also makes associated parameters and buffers different objects. So it should be called before constructing optimizer if the module will live on XPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self xpu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T zero_grad Reset gradients of all model parameters. See similar function under :class: torch.optim.Optimizer for more context. Args: set_to_none (bool): instead of setting to zero, set the grads to None. See :meth: torch.optim.Optimizer.zero_grad for details. zero_grad(self, set_to_none: bool = True) -> None","title":"src.model.sparse_mlp"},{"location":"src_model_sparse_mlp/#srcmodelsparse_mlp","text":"","title":"src.model.sparse_mlp"},{"location":"src_model_sparse_mlp/#classes","text":"","title":"Classes"},{"location":"src_model_sparse_mlp/#sparsemlp","text":"","title":"SparseMLP"},{"location":"src_model_sparse_mlp/#methods","text":"","title":"Methods"},{"location":"src_model_sparse_mlp/#__init__","text":"__init__(self, config)","title":"__init__"},{"location":"src_model_sparse_mlp/#add_module","text":"Add a child module to the current module. The module can be accessed as an attribute using the given name. Args: name (str): name of the child module. The child module can be accessed from this module using the given name module (Module): child module to be added to the module. add_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None","title":"add_module"},{"location":"src_model_sparse_mlp/#apply","text":"Apply fn recursively to every submodule (as returned by .children() ) as well as self. Typical use includes initializing the parameters of a model (see also :ref: nn-init-doc ). Args: fn (:class: Module -> None): function to be applied to each submodule Returns: Module: self Example:: >>> @torch.no_grad() >>> def init_weights(m): >>> print(m) >>> if type(m) == nn.Linear: >>> m.weight.fill_(1.0) >>> print(m.weight) >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2)) >>> net.apply(init_weights) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) apply(self: ~T, fn: Callable[[ForwardRef('Module')], NoneType]) -> ~T","title":"apply"},{"location":"src_model_sparse_mlp/#apply_sparsity_masks","text":"Apply sparsity masks to weights. apply_sparsity_masks(self)","title":"apply_sparsity_masks"},{"location":"src_model_sparse_mlp/#bfloat16","text":"Casts all floating point parameters and buffers to bfloat16 datatype. .. note:: This method modifies the module in-place. Returns: Module: self bfloat16(self: ~T) -> ~T","title":"bfloat16"},{"location":"src_model_sparse_mlp/#buffers","text":"Return an iterator over module buffers. Args: recurse (bool): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Yields: torch.Tensor: module buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for buf in model.buffers(): >>> print(type(buf), buf.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) buffers(self, recurse: bool = True) -> Iterator[torch.Tensor]","title":"buffers"},{"location":"src_model_sparse_mlp/#children","text":"Return an iterator over immediate children modules. Yields: Module: a child module children(self) -> Iterator[ForwardRef('Module')]","title":"children"},{"location":"src_model_sparse_mlp/#compile","text":"Compile this Module's forward using :func: torch.compile . This Module's __call__ method is compiled and all arguments are passed as-is to :func: torch.compile . See :func: torch.compile for details on the arguments for this function. compile(self, *args, **kwargs)","title":"compile"},{"location":"src_model_sparse_mlp/#cpu","text":"Move all model parameters and buffers to the CPU. .. note:: This method modifies the module in-place. Returns: Module: self cpu(self: ~T) -> ~T","title":"cpu"},{"location":"src_model_sparse_mlp/#cuda","text":"Move all model parameters and buffers to the GPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on GPU while being optimized. .. note:: This method modifies the module in-place. Args: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self cuda(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"cuda"},{"location":"src_model_sparse_mlp/#double","text":"Casts all floating point parameters and buffers to double datatype. .. note:: This method modifies the module in-place. Returns: Module: self double(self: ~T) -> ~T","title":"double"},{"location":"src_model_sparse_mlp/#eval","text":"Set the module in evaluation mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e. whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. This is equivalent with :meth: self.train(False) <torch.nn.Module.train> . See :ref: locally-disable-grad-doc for a comparison between .eval() and several similar mechanisms that may be confused with it. Returns: Module: self eval(self: ~T) -> ~T","title":"eval"},{"location":"src_model_sparse_mlp/#extra_repr","text":"Return the extra representation of the module. To print customized extra information, you should re-implement this method in your own modules. Both single-line and multi-line strings are acceptable. extra_repr(self) -> str","title":"extra_repr"},{"location":"src_model_sparse_mlp/#float","text":"Casts all floating point parameters and buffers to float datatype. .. note:: This method modifies the module in-place. Returns: Module: self float(self: ~T) -> ~T","title":"float"},{"location":"src_model_sparse_mlp/#forward","text":"forward(self, hidden_states)","title":"forward"},{"location":"src_model_sparse_mlp/#get_activation_mask","text":"Generate activation sparsity mask with the correct dimensions. Args: shape: Tuple (batch_size, seq_length, dim) device: The device to create the mask on Returns: A sparsity mask tensor of shape (batch_size, seq_length, dim) get_activation_mask(self, shape, device)","title":"get_activation_mask"},{"location":"src_model_sparse_mlp/#get_buffer","text":"Return the buffer given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the buffer to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.Tensor: The buffer referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not a buffer get_buffer(self, target: str) -> 'Tensor'","title":"get_buffer"},{"location":"src_model_sparse_mlp/#get_extra_state","text":"Return any extra state to include in the module's state_dict. Implement this and a corresponding :func: set_extra_state for your module if you need to store extra state. This function is called when building the module's state_dict() . Note that extra state should be picklable to ensure working serialization of the state_dict. We only provide backwards compatibility guarantees for serializing Tensors; other objects may break backwards compatibility if their serialized pickled form changes. Returns: object: Any extra state to store in the module's state_dict get_extra_state(self) -> Any","title":"get_extra_state"},{"location":"src_model_sparse_mlp/#get_parameter","text":"Return the parameter given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the Parameter to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.nn.Parameter: The Parameter referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Parameter get_parameter(self, target: str) -> 'Parameter'","title":"get_parameter"},{"location":"src_model_sparse_mlp/#get_submodule","text":"Return the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A which has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To check whether or not we have the linear submodule, we would call get_submodule(\"net_b.linear\") . To check whether we have the conv submodule, we would call get_submodule(\"net_b.net_c.conv\") . The runtime of get_submodule is bounded by the degree of module nesting in target . A query against named_modules achieves the same result, but it is O(N) in the number of transitive modules. So, for a simple check to see if some submodule exists, get_submodule should always be used. Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) Returns: torch.nn.Module: The submodule referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module get_submodule(self, target: str) -> 'Module'","title":"get_submodule"},{"location":"src_model_sparse_mlp/#half","text":"Casts all floating point parameters and buffers to half datatype. .. note:: This method modifies the module in-place. Returns: Module: self half(self: ~T) -> ~T","title":"half"},{"location":"src_model_sparse_mlp/#ipu","text":"Move all model parameters and buffers to the IPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on IPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self ipu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"ipu"},{"location":"src_model_sparse_mlp/#load_state_dict","text":"Copy parameters and buffers from :attr: state_dict into this module and its descendants. If :attr: strict is True , then the keys of :attr: state_dict must exactly match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. .. warning:: If :attr: assign is True the optimizer must be created after the call to :attr: load_state_dict unless :func: ~torch.__future__.get_swap_module_params_on_conversion is True . Args: state_dict (dict): a dict containing parameters and persistent buffers. strict (bool, optional): whether to strictly enforce that the keys in :attr: state_dict match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. Default: True assign (bool, optional): When set to False , the properties of the tensors in the current module are preserved whereas setting it to True preserves properties of the Tensors in the state dict. The only exception is the requires_grad field of :class: ~torch.nn.Parameter s for which the value from the module is preserved. Default: False Returns: NamedTuple with missing_keys and unexpected_keys fields: * missing_keys is a list of str containing any keys that are expected by this module but missing from the provided state_dict . * unexpected_keys is a list of str containing the keys that are not expected by this module but present in the provided state_dict . Note: If a parameter or buffer is registered as None and its corresponding key exists in :attr: state_dict , :meth: load_state_dict will raise a RuntimeError . load_state_dict(self, state_dict: Mapping[str, Any], strict: bool = True, assign: bool = False)","title":"load_state_dict"},{"location":"src_model_sparse_mlp/#modules","text":"Return an iterator over all modules in the network. Yields: Module: a module in the network Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.modules()): ... print(idx, '->', m) 0 -> Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) 1 -> Linear(in_features=2, out_features=2, bias=True) modules(self) -> Iterator[ForwardRef('Module')]","title":"modules"},{"location":"src_model_sparse_mlp/#mtia","text":"Move all model parameters and buffers to the MTIA. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on MTIA while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self mtia(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"mtia"},{"location":"src_model_sparse_mlp/#named_buffers","text":"Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself. Args: prefix (str): prefix to prepend to all buffer names. recurse (bool, optional): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Defaults to True. remove_duplicate (bool, optional): whether to remove the duplicated buffers in the result. Defaults to True. Yields: (str, torch.Tensor): Tuple containing the name and buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, buf in self.named_buffers(): >>> if name in ['running_var']: >>> print(buf.size()) named_buffers(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.Tensor]]","title":"named_buffers"},{"location":"src_model_sparse_mlp/#named_children","text":"Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself. Yields: (str, Module): Tuple containing a name and child module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, module in model.named_children(): >>> if name in ['conv4', 'conv5']: >>> print(module) named_children(self) -> Iterator[Tuple[str, ForwardRef('Module')]]","title":"named_children"},{"location":"src_model_sparse_mlp/#named_modules","text":"Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself. Args: memo: a memo to store the set of modules already added to the result prefix: a prefix that will be added to the name of the module remove_duplicate: whether to remove the duplicated module instances in the result or not Yields: (str, Module): Tuple of name and module Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.named_modules()): ... print(idx, '->', m) 0 -> ('', Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) )) 1 -> ('0', Linear(in_features=2, out_features=2, bias=True)) named_modules(self, memo: Optional[Set[ForwardRef('Module')]] = None, prefix: str = '', remove_duplicate: bool = True)","title":"named_modules"},{"location":"src_model_sparse_mlp/#named_parameters","text":"Return an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself. Args: prefix (str): prefix to prepend to all parameter names. recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. remove_duplicate (bool, optional): whether to remove the duplicated parameters in the result. Defaults to True. Yields: (str, Parameter): Tuple containing the name and parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, param in self.named_parameters(): >>> if name in ['bias']: >>> print(param.size()) named_parameters(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.nn.parameter.Parameter]]","title":"named_parameters"},{"location":"src_model_sparse_mlp/#parameters","text":"Return an iterator over module parameters. This is typically passed to an optimizer. Args: recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. Yields: Parameter: module parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for param in model.parameters(): >>> print(type(param), param.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) parameters(self, recurse: bool = True) -> Iterator[torch.nn.parameter.Parameter]","title":"parameters"},{"location":"src_model_sparse_mlp/#register_backward_hook","text":"Register a backward hook on the module. This function is deprecated in favor of :meth: ~torch.nn.Module.register_full_backward_hook and the behavior of this function will change in future versions. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]]) -> torch.utils.hooks.RemovableHandle","title":"register_backward_hook"},{"location":"src_model_sparse_mlp/#register_buffer","text":"Add a buffer to the module. This is typically used to register a buffer that should not to be considered a model parameter. For example, BatchNorm's running_mean is not a parameter, but is part of the module's state. Buffers, by default, are persistent and will be saved alongside parameters. This behavior can be changed by setting :attr: persistent to False . The only difference between a persistent buffer and a non-persistent buffer is that the latter will not be a part of this module's :attr: state_dict . Buffers can be accessed as attributes using given names. Args: name (str): name of the buffer. The buffer can be accessed from this module using the given name tensor (Tensor or None): buffer to be registered. If None , then operations that run on buffers, such as :attr: cuda , are ignored. If None , the buffer is not included in the module's :attr: state_dict . persistent (bool): whether the buffer is part of this module's :attr: state_dict . Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> self.register_buffer('running_mean', torch.zeros(num_features)) register_buffer(self, name: str, tensor: Optional[torch.Tensor], persistent: bool = True) -> None","title":"register_buffer"},{"location":"src_model_sparse_mlp/#register_forward_hook","text":"Register a forward hook on the module. The hook will be called every time after :func: forward has computed an output. If with_kwargs is False or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the output. It can modify the input inplace but it will not have effect on forward since this is called after :func: forward is called. The hook should have the following signature:: hook(module, args, output) -> None or modified output If with_kwargs is True , the forward hook will be passed the kwargs given to the forward function and be expected to return the output possibly modified. The hook should have the following signature:: hook(module, args, kwargs, output) -> None or modified output Args: hook (Callable): The user defined hook to be registered. prepend (bool): If True , the provided hook will be fired before all existing forward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward hooks on this :class: torch.nn.modules.Module . Note that global forward hooks registered with :func: register_module_forward_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If True , the hook will be passed the kwargs given to the forward function. Default: False always_call (bool): If True the hook will be run regardless of whether an exception is raised while calling the Module. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...], Any], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any], Any], Optional[Any]]], *, prepend: bool = False, with_kwargs: bool = False, always_call: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_forward_hook"},{"location":"src_model_sparse_mlp/#register_forward_pre_hook","text":"Register a forward pre-hook on the module. The hook will be called every time before :func: forward is invoked. If with_kwargs is false or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the input. User can either return a tuple or a single modified value in the hook. We will wrap the value into a tuple if a single value is returned (unless that value is already a tuple). The hook should have the following signature:: hook(module, args) -> None or modified input If with_kwargs is true, the forward pre-hook will be passed the kwargs given to the forward function. And if the hook modifies the input, both the args and kwargs should be returned. The hook should have the following signature:: hook(module, args, kwargs) -> None or a tuple of modified input and kwargs Args: hook (Callable): The user defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing forward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward_pre hooks on this :class: torch.nn.modules.Module . Note that global forward_pre hooks registered with :func: register_module_forward_pre_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If true, the hook will be passed the kwargs given to the forward function. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_pre_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...]], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any]], Optional[Tuple[Any, Dict[str, Any]]]]], *, prepend: bool = False, with_kwargs: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_forward_pre_hook"},{"location":"src_model_sparse_mlp/#register_full_backward_hook","text":"Register a backward hook on the module. The hook will be called every time the gradients with respect to a module are computed, i.e. the hook will execute if and only if the gradients with respect to module outputs are computed. The hook should have the following signature:: hook(module, grad_input, grad_output) -> tuple(Tensor) or None The :attr: grad_input and :attr: grad_output are tuples that contain the gradients with respect to the inputs and outputs respectively. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the input that will be used in place of :attr: grad_input in subsequent computations. :attr: grad_input will only correspond to the inputs given as positional arguments and all kwarg arguments are ignored. Entries in :attr: grad_input and :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs or outputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward hooks on this :class: torch.nn.modules.Module . Note that global backward hooks registered with :func: register_module_full_backward_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_full_backward_hook"},{"location":"src_model_sparse_mlp/#register_full_backward_pre_hook","text":"Register a backward pre-hook on the module. The hook will be called every time the gradients for the module are computed. The hook should have the following signature:: hook(module, grad_output) -> tuple[Tensor] or None The :attr: grad_output is a tuple. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the output that will be used in place of :attr: grad_output in subsequent computations. Entries in :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward_pre hooks on this :class: torch.nn.modules.Module . Note that global backward_pre hooks registered with :func: register_module_full_backward_pre_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_pre_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_full_backward_pre_hook"},{"location":"src_model_sparse_mlp/#register_load_state_dict_post_hook","text":"Register a post-hook to be run after module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, incompatible_keys) -> None The module argument is the current module that this hook is registered on, and the incompatible_keys argument is a NamedTuple consisting of attributes missing_keys and unexpected_keys . missing_keys is a list of str containing the missing keys and unexpected_keys is a list of str containing the unexpected keys. The given incompatible_keys can be modified inplace if needed. Note that the checks performed when calling :func: load_state_dict with strict=True are affected by modifications the hook makes to missing_keys or unexpected_keys , as expected. Additions to either set of keys will result in an error being thrown when strict=True , and clearing out both missing and unexpected keys will avoid an error. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_load_state_dict_post_hook(self, hook)","title":"register_load_state_dict_post_hook"},{"location":"src_model_sparse_mlp/#register_load_state_dict_pre_hook","text":"Register a pre-hook to be run before module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs) -> None # noqa: B950 Arguments: hook (Callable): Callable hook that will be invoked before loading the state dict. register_load_state_dict_pre_hook(self, hook)","title":"register_load_state_dict_pre_hook"},{"location":"src_model_sparse_mlp/#register_module","text":"Alias for :func: add_module . register_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None","title":"register_module"},{"location":"src_model_sparse_mlp/#register_parameter","text":"Add a parameter to the module. The parameter can be accessed as an attribute using given name. Args: name (str): name of the parameter. The parameter can be accessed from this module using the given name param (Parameter or None): parameter to be added to the module. If None , then operations that run on parameters, such as :attr: cuda , are ignored. If None , the parameter is not included in the module's :attr: state_dict . register_parameter(self, name: str, param: Optional[torch.nn.parameter.Parameter]) -> None","title":"register_parameter"},{"location":"src_model_sparse_mlp/#register_state_dict_post_hook","text":"Register a post-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, state_dict, prefix, local_metadata) -> None The registered hooks can modify the state_dict inplace. register_state_dict_post_hook(self, hook)","title":"register_state_dict_post_hook"},{"location":"src_model_sparse_mlp/#register_state_dict_pre_hook","text":"Register a pre-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, prefix, keep_vars) -> None The registered hooks can be used to perform pre-processing before the state_dict call is made. register_state_dict_pre_hook(self, hook)","title":"register_state_dict_pre_hook"},{"location":"src_model_sparse_mlp/#requires_grad_","text":"Change if autograd should record operations on parameters in this module. This method sets the parameters' :attr: requires_grad attributes in-place. This method is helpful for freezing part of the module for finetuning or training parts of a model individually (e.g., GAN training). See :ref: locally-disable-grad-doc for a comparison between .requires_grad_() and several similar mechanisms that may be confused with it. Args: requires_grad (bool): whether autograd should record operations on parameters in this module. Default: True . Returns: Module: self requires_grad_(self: ~T, requires_grad: bool = True) -> ~T","title":"requires_grad_"},{"location":"src_model_sparse_mlp/#set_extra_state","text":"Set extra state contained in the loaded state_dict . This function is called from :func: load_state_dict to handle any extra state found within the state_dict . Implement this function and a corresponding :func: get_extra_state for your module if you need to store extra state within its state_dict . Args: state (dict): Extra state from the state_dict set_extra_state(self, state: Any) -> None","title":"set_extra_state"},{"location":"src_model_sparse_mlp/#set_submodule","text":"Set the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To overide the Conv2d with a new submodule Linear , you would call set_submodule(\"net_b.net_c.conv\", nn.Linear(33, 16)) . Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) module: The module to set the submodule to. Raises: ValueError: If the target string is empty AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module set_submodule(self, target: str, module: 'Module') -> None","title":"set_submodule"},{"location":"src_model_sparse_mlp/#share_memory","text":"See :meth: torch.Tensor.share_memory_ . share_memory(self: ~T) -> ~T","title":"share_memory"},{"location":"src_model_sparse_mlp/#state_dict","text":"Return a dictionary containing references to the whole state of the module. Both parameters and persistent buffers (e.g. running averages) are included. Keys are corresponding parameter and buffer names. Parameters and buffers set to None are not included. .. note:: The returned object is a shallow copy. It contains references to the module's parameters and buffers. .. warning:: Currently state_dict() also accepts positional arguments for destination , prefix and keep_vars in order. However, this is being deprecated and keyword arguments will be enforced in future releases. .. warning:: Please avoid the use of argument destination as it is not designed for end-users. Args: destination (dict, optional): If provided, the state of module will be updated into the dict and the same object is returned. Otherwise, an OrderedDict will be created and returned. Default: None . prefix (str, optional): a prefix added to parameter and buffer names to compose the keys in state_dict. Default: '' . keep_vars (bool, optional): by default the :class: ~torch.Tensor s returned in the state dict are detached from autograd. If it's set to True , detaching will not be performed. Default: False . Returns: dict: a dictionary containing a whole state of the module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> module.state_dict().keys() ['bias', 'weight'] state_dict(self, *args, destination=None, prefix='', keep_vars=False)","title":"state_dict"},{"location":"src_model_sparse_mlp/#to","text":"Move and/or cast the parameters and buffers. This can be called as .. function:: to(device=None, dtype=None, non_blocking=False) :noindex: .. function:: to(dtype, non_blocking=False) :noindex: .. function:: to(tensor, non_blocking=False) :noindex: .. function:: to(memory_format=torch.channels_last) :noindex: Its signature is similar to :meth: torch.Tensor.to , but only accepts floating point or complex :attr: dtype \\ s. In addition, this method will only cast the floating point or complex parameters and buffers to :attr: dtype (if given). The integral parameters and buffers will be moved :attr: device , if that is given, but with dtypes unchanged. When :attr: non_blocking is set, it tries to convert/move asynchronously with respect to the host if possible, e.g., moving CPU Tensors with pinned memory to CUDA devices. See below for examples. .. note:: This method modifies the module in-place. Args: device (:class: torch.device ): the desired device of the parameters and buffers in this module dtype (:class: torch.dtype ): the desired floating point or complex dtype of the parameters and buffers in this module tensor (torch.Tensor): Tensor whose dtype and device are the desired dtype and device for all parameters and buffers in this module memory_format (:class: torch.memory_format ): the desired memory format for 4D parameters and buffers in this module (keyword only argument) Returns: Module: self Examples:: >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\") >>> linear = nn.Linear(2, 2) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]]) >>> linear.to(torch.double) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]], dtype=torch.float64) >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA1) >>> gpu1 = torch.device(\"cuda:1\") >>> linear.to(gpu1, dtype=torch.half, non_blocking=True) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1') >>> cpu = torch.device(\"cpu\") >>> linear.to(cpu) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16) >>> linear = nn.Linear(2, 2, bias=None).to(torch.cdouble) >>> linear.weight Parameter containing: tensor([[ 0.3741+0.j, 0.2382+0.j], [ 0.5593+0.j, -0.4443+0.j]], dtype=torch.complex128) >>> linear(torch.ones(3, 2, dtype=torch.cdouble)) tensor([[0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j]], dtype=torch.complex128) to(self, *args, **kwargs)","title":"to"},{"location":"src_model_sparse_mlp/#to_empty","text":"Move the parameters and buffers to the specified device without copying storage. Args: device (:class: torch.device ): The desired device of the parameters and buffers in this module. recurse (bool): Whether parameters and buffers of submodules should be recursively moved to the specified device. Returns: Module: self to_empty(self: ~T, *, device: Union[int, str, torch.device, NoneType], recurse: bool = True) -> ~T","title":"to_empty"},{"location":"src_model_sparse_mlp/#train","text":"Set the module in training mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e., whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. Args: mode (bool): whether to set training mode ( True ) or evaluation mode ( False ). Default: True . Returns: Module: self train(self: ~T, mode: bool = True) -> ~T","title":"train"},{"location":"src_model_sparse_mlp/#type","text":"Casts all parameters and buffers to :attr: dst_type . .. note:: This method modifies the module in-place. Args: dst_type (type or string): the desired type Returns: Module: self type(self: ~T, dst_type: Union[torch.dtype, str]) -> ~T","title":"type"},{"location":"src_model_sparse_mlp/#xpu","text":"Move all model parameters and buffers to the XPU. This also makes associated parameters and buffers different objects. So it should be called before constructing optimizer if the module will live on XPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self xpu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"xpu"},{"location":"src_model_sparse_mlp/#zero_grad","text":"Reset gradients of all model parameters. See similar function under :class: torch.optim.Optimizer for more context. Args: set_to_none (bool): instead of setting to zero, set the grads to None. See :meth: torch.optim.Optimizer.zero_grad for details. zero_grad(self, set_to_none: bool = True) -> None","title":"zero_grad"},{"location":"src_model_transformer_block/","text":"src.model.transformer_block Classes EdgeFormerBlock Methods __init__ __init__(self, config, layer_idx=None) add_module Add a child module to the current module. The module can be accessed as an attribute using the given name. Args: name (str): name of the child module. The child module can be accessed from this module using the given name module (Module): child module to be added to the module. add_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None apply Apply fn recursively to every submodule (as returned by .children() ) as well as self. Typical use includes initializing the parameters of a model (see also :ref: nn-init-doc ). Args: fn (:class: Module -> None): function to be applied to each submodule Returns: Module: self Example:: >>> @torch.no_grad() >>> def init_weights(m): >>> print(m) >>> if type(m) == nn.Linear: >>> m.weight.fill_(1.0) >>> print(m.weight) >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2)) >>> net.apply(init_weights) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) apply(self: ~T, fn: Callable[[ForwardRef('Module')], NoneType]) -> ~T bfloat16 Casts all floating point parameters and buffers to bfloat16 datatype. .. note:: This method modifies the module in-place. Returns: Module: self bfloat16(self: ~T) -> ~T buffers Return an iterator over module buffers. Args: recurse (bool): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Yields: torch.Tensor: module buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for buf in model.buffers(): >>> print(type(buf), buf.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) buffers(self, recurse: bool = True) -> Iterator[torch.Tensor] children Return an iterator over immediate children modules. Yields: Module: a child module children(self) -> Iterator[ForwardRef('Module')] compile Compile this Module's forward using :func: torch.compile . This Module's __call__ method is compiled and all arguments are passed as-is to :func: torch.compile . See :func: torch.compile for details on the arguments for this function. compile(self, *args, **kwargs) cpu Move all model parameters and buffers to the CPU. .. note:: This method modifies the module in-place. Returns: Module: self cpu(self: ~T) -> ~T cuda Move all model parameters and buffers to the GPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on GPU while being optimized. .. note:: This method modifies the module in-place. Args: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self cuda(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T double Casts all floating point parameters and buffers to double datatype. .. note:: This method modifies the module in-place. Returns: Module: self double(self: ~T) -> ~T eval Set the module in evaluation mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e. whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. This is equivalent with :meth: self.train(False) <torch.nn.Module.train> . See :ref: locally-disable-grad-doc for a comparison between .eval() and several similar mechanisms that may be confused with it. Returns: Module: self eval(self: ~T) -> ~T extra_repr Return the extra representation of the module. To print customized extra information, you should re-implement this method in your own modules. Both single-line and multi-line strings are acceptable. extra_repr(self) -> str float Casts all floating point parameters and buffers to float datatype. .. note:: This method modifies the module in-place. Returns: Module: self float(self: ~T) -> ~T forward forward(self, hidden_states, attention_mask=None, position_bias=None, head_mask=None, past_key_value=None, use_cache=False, output_attentions=False, sliding_window_size=None) get_buffer Return the buffer given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the buffer to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.Tensor: The buffer referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not a buffer get_buffer(self, target: str) -> 'Tensor' get_extra_state Return any extra state to include in the module's state_dict. Implement this and a corresponding :func: set_extra_state for your module if you need to store extra state. This function is called when building the module's state_dict() . Note that extra state should be picklable to ensure working serialization of the state_dict. We only provide backwards compatibility guarantees for serializing Tensors; other objects may break backwards compatibility if their serialized pickled form changes. Returns: object: Any extra state to store in the module's state_dict get_extra_state(self) -> Any get_parameter Return the parameter given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the Parameter to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.nn.Parameter: The Parameter referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Parameter get_parameter(self, target: str) -> 'Parameter' get_submodule Return the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A which has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To check whether or not we have the linear submodule, we would call get_submodule(\"net_b.linear\") . To check whether we have the conv submodule, we would call get_submodule(\"net_b.net_c.conv\") . The runtime of get_submodule is bounded by the degree of module nesting in target . A query against named_modules achieves the same result, but it is O(N) in the number of transitive modules. So, for a simple check to see if some submodule exists, get_submodule should always be used. Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) Returns: torch.nn.Module: The submodule referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module get_submodule(self, target: str) -> 'Module' half Casts all floating point parameters and buffers to half datatype. .. note:: This method modifies the module in-place. Returns: Module: self half(self: ~T) -> ~T ipu Move all model parameters and buffers to the IPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on IPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self ipu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T load_state_dict Copy parameters and buffers from :attr: state_dict into this module and its descendants. If :attr: strict is True , then the keys of :attr: state_dict must exactly match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. .. warning:: If :attr: assign is True the optimizer must be created after the call to :attr: load_state_dict unless :func: ~torch.__future__.get_swap_module_params_on_conversion is True . Args: state_dict (dict): a dict containing parameters and persistent buffers. strict (bool, optional): whether to strictly enforce that the keys in :attr: state_dict match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. Default: True assign (bool, optional): When set to False , the properties of the tensors in the current module are preserved whereas setting it to True preserves properties of the Tensors in the state dict. The only exception is the requires_grad field of :class: ~torch.nn.Parameter s for which the value from the module is preserved. Default: False Returns: NamedTuple with missing_keys and unexpected_keys fields: * missing_keys is a list of str containing any keys that are expected by this module but missing from the provided state_dict . * unexpected_keys is a list of str containing the keys that are not expected by this module but present in the provided state_dict . Note: If a parameter or buffer is registered as None and its corresponding key exists in :attr: state_dict , :meth: load_state_dict will raise a RuntimeError . load_state_dict(self, state_dict: Mapping[str, Any], strict: bool = True, assign: bool = False) modules Return an iterator over all modules in the network. Yields: Module: a module in the network Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.modules()): ... print(idx, '->', m) 0 -> Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) 1 -> Linear(in_features=2, out_features=2, bias=True) modules(self) -> Iterator[ForwardRef('Module')] mtia Move all model parameters and buffers to the MTIA. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on MTIA while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self mtia(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T named_buffers Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself. Args: prefix (str): prefix to prepend to all buffer names. recurse (bool, optional): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Defaults to True. remove_duplicate (bool, optional): whether to remove the duplicated buffers in the result. Defaults to True. Yields: (str, torch.Tensor): Tuple containing the name and buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, buf in self.named_buffers(): >>> if name in ['running_var']: >>> print(buf.size()) named_buffers(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.Tensor]] named_children Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself. Yields: (str, Module): Tuple containing a name and child module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, module in model.named_children(): >>> if name in ['conv4', 'conv5']: >>> print(module) named_children(self) -> Iterator[Tuple[str, ForwardRef('Module')]] named_modules Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself. Args: memo: a memo to store the set of modules already added to the result prefix: a prefix that will be added to the name of the module remove_duplicate: whether to remove the duplicated module instances in the result or not Yields: (str, Module): Tuple of name and module Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.named_modules()): ... print(idx, '->', m) 0 -> ('', Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) )) 1 -> ('0', Linear(in_features=2, out_features=2, bias=True)) named_modules(self, memo: Optional[Set[ForwardRef('Module')]] = None, prefix: str = '', remove_duplicate: bool = True) named_parameters Return an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself. Args: prefix (str): prefix to prepend to all parameter names. recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. remove_duplicate (bool, optional): whether to remove the duplicated parameters in the result. Defaults to True. Yields: (str, Parameter): Tuple containing the name and parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, param in self.named_parameters(): >>> if name in ['bias']: >>> print(param.size()) named_parameters(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.nn.parameter.Parameter]] parameters Return an iterator over module parameters. This is typically passed to an optimizer. Args: recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. Yields: Parameter: module parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for param in model.parameters(): >>> print(type(param), param.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) parameters(self, recurse: bool = True) -> Iterator[torch.nn.parameter.Parameter] register_backward_hook Register a backward hook on the module. This function is deprecated in favor of :meth: ~torch.nn.Module.register_full_backward_hook and the behavior of this function will change in future versions. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]]) -> torch.utils.hooks.RemovableHandle register_buffer Add a buffer to the module. This is typically used to register a buffer that should not to be considered a model parameter. For example, BatchNorm's running_mean is not a parameter, but is part of the module's state. Buffers, by default, are persistent and will be saved alongside parameters. This behavior can be changed by setting :attr: persistent to False . The only difference between a persistent buffer and a non-persistent buffer is that the latter will not be a part of this module's :attr: state_dict . Buffers can be accessed as attributes using given names. Args: name (str): name of the buffer. The buffer can be accessed from this module using the given name tensor (Tensor or None): buffer to be registered. If None , then operations that run on buffers, such as :attr: cuda , are ignored. If None , the buffer is not included in the module's :attr: state_dict . persistent (bool): whether the buffer is part of this module's :attr: state_dict . Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> self.register_buffer('running_mean', torch.zeros(num_features)) register_buffer(self, name: str, tensor: Optional[torch.Tensor], persistent: bool = True) -> None register_forward_hook Register a forward hook on the module. The hook will be called every time after :func: forward has computed an output. If with_kwargs is False or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the output. It can modify the input inplace but it will not have effect on forward since this is called after :func: forward is called. The hook should have the following signature:: hook(module, args, output) -> None or modified output If with_kwargs is True , the forward hook will be passed the kwargs given to the forward function and be expected to return the output possibly modified. The hook should have the following signature:: hook(module, args, kwargs, output) -> None or modified output Args: hook (Callable): The user defined hook to be registered. prepend (bool): If True , the provided hook will be fired before all existing forward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward hooks on this :class: torch.nn.modules.Module . Note that global forward hooks registered with :func: register_module_forward_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If True , the hook will be passed the kwargs given to the forward function. Default: False always_call (bool): If True the hook will be run regardless of whether an exception is raised while calling the Module. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...], Any], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any], Any], Optional[Any]]], *, prepend: bool = False, with_kwargs: bool = False, always_call: bool = False) -> torch.utils.hooks.RemovableHandle register_forward_pre_hook Register a forward pre-hook on the module. The hook will be called every time before :func: forward is invoked. If with_kwargs is false or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the input. User can either return a tuple or a single modified value in the hook. We will wrap the value into a tuple if a single value is returned (unless that value is already a tuple). The hook should have the following signature:: hook(module, args) -> None or modified input If with_kwargs is true, the forward pre-hook will be passed the kwargs given to the forward function. And if the hook modifies the input, both the args and kwargs should be returned. The hook should have the following signature:: hook(module, args, kwargs) -> None or a tuple of modified input and kwargs Args: hook (Callable): The user defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing forward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward_pre hooks on this :class: torch.nn.modules.Module . Note that global forward_pre hooks registered with :func: register_module_forward_pre_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If true, the hook will be passed the kwargs given to the forward function. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_pre_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...]], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any]], Optional[Tuple[Any, Dict[str, Any]]]]], *, prepend: bool = False, with_kwargs: bool = False) -> torch.utils.hooks.RemovableHandle register_full_backward_hook Register a backward hook on the module. The hook will be called every time the gradients with respect to a module are computed, i.e. the hook will execute if and only if the gradients with respect to module outputs are computed. The hook should have the following signature:: hook(module, grad_input, grad_output) -> tuple(Tensor) or None The :attr: grad_input and :attr: grad_output are tuples that contain the gradients with respect to the inputs and outputs respectively. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the input that will be used in place of :attr: grad_input in subsequent computations. :attr: grad_input will only correspond to the inputs given as positional arguments and all kwarg arguments are ignored. Entries in :attr: grad_input and :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs or outputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward hooks on this :class: torch.nn.modules.Module . Note that global backward hooks registered with :func: register_module_full_backward_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle register_full_backward_pre_hook Register a backward pre-hook on the module. The hook will be called every time the gradients for the module are computed. The hook should have the following signature:: hook(module, grad_output) -> tuple[Tensor] or None The :attr: grad_output is a tuple. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the output that will be used in place of :attr: grad_output in subsequent computations. Entries in :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward_pre hooks on this :class: torch.nn.modules.Module . Note that global backward_pre hooks registered with :func: register_module_full_backward_pre_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_pre_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle register_load_state_dict_post_hook Register a post-hook to be run after module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, incompatible_keys) -> None The module argument is the current module that this hook is registered on, and the incompatible_keys argument is a NamedTuple consisting of attributes missing_keys and unexpected_keys . missing_keys is a list of str containing the missing keys and unexpected_keys is a list of str containing the unexpected keys. The given incompatible_keys can be modified inplace if needed. Note that the checks performed when calling :func: load_state_dict with strict=True are affected by modifications the hook makes to missing_keys or unexpected_keys , as expected. Additions to either set of keys will result in an error being thrown when strict=True , and clearing out both missing and unexpected keys will avoid an error. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_load_state_dict_post_hook(self, hook) register_load_state_dict_pre_hook Register a pre-hook to be run before module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs) -> None # noqa: B950 Arguments: hook (Callable): Callable hook that will be invoked before loading the state dict. register_load_state_dict_pre_hook(self, hook) register_module Alias for :func: add_module . register_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None register_parameter Add a parameter to the module. The parameter can be accessed as an attribute using given name. Args: name (str): name of the parameter. The parameter can be accessed from this module using the given name param (Parameter or None): parameter to be added to the module. If None , then operations that run on parameters, such as :attr: cuda , are ignored. If None , the parameter is not included in the module's :attr: state_dict . register_parameter(self, name: str, param: Optional[torch.nn.parameter.Parameter]) -> None register_state_dict_post_hook Register a post-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, state_dict, prefix, local_metadata) -> None The registered hooks can modify the state_dict inplace. register_state_dict_post_hook(self, hook) register_state_dict_pre_hook Register a pre-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, prefix, keep_vars) -> None The registered hooks can be used to perform pre-processing before the state_dict call is made. register_state_dict_pre_hook(self, hook) requires_grad_ Change if autograd should record operations on parameters in this module. This method sets the parameters' :attr: requires_grad attributes in-place. This method is helpful for freezing part of the module for finetuning or training parts of a model individually (e.g., GAN training). See :ref: locally-disable-grad-doc for a comparison between .requires_grad_() and several similar mechanisms that may be confused with it. Args: requires_grad (bool): whether autograd should record operations on parameters in this module. Default: True . Returns: Module: self requires_grad_(self: ~T, requires_grad: bool = True) -> ~T set_extra_state Set extra state contained in the loaded state_dict . This function is called from :func: load_state_dict to handle any extra state found within the state_dict . Implement this function and a corresponding :func: get_extra_state for your module if you need to store extra state within its state_dict . Args: state (dict): Extra state from the state_dict set_extra_state(self, state: Any) -> None set_submodule Set the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To overide the Conv2d with a new submodule Linear , you would call set_submodule(\"net_b.net_c.conv\", nn.Linear(33, 16)) . Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) module: The module to set the submodule to. Raises: ValueError: If the target string is empty AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module set_submodule(self, target: str, module: 'Module') -> None share_memory See :meth: torch.Tensor.share_memory_ . share_memory(self: ~T) -> ~T state_dict Return a dictionary containing references to the whole state of the module. Both parameters and persistent buffers (e.g. running averages) are included. Keys are corresponding parameter and buffer names. Parameters and buffers set to None are not included. .. note:: The returned object is a shallow copy. It contains references to the module's parameters and buffers. .. warning:: Currently state_dict() also accepts positional arguments for destination , prefix and keep_vars in order. However, this is being deprecated and keyword arguments will be enforced in future releases. .. warning:: Please avoid the use of argument destination as it is not designed for end-users. Args: destination (dict, optional): If provided, the state of module will be updated into the dict and the same object is returned. Otherwise, an OrderedDict will be created and returned. Default: None . prefix (str, optional): a prefix added to parameter and buffer names to compose the keys in state_dict. Default: '' . keep_vars (bool, optional): by default the :class: ~torch.Tensor s returned in the state dict are detached from autograd. If it's set to True , detaching will not be performed. Default: False . Returns: dict: a dictionary containing a whole state of the module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> module.state_dict().keys() ['bias', 'weight'] state_dict(self, *args, destination=None, prefix='', keep_vars=False) to Move and/or cast the parameters and buffers. This can be called as .. function:: to(device=None, dtype=None, non_blocking=False) :noindex: .. function:: to(dtype, non_blocking=False) :noindex: .. function:: to(tensor, non_blocking=False) :noindex: .. function:: to(memory_format=torch.channels_last) :noindex: Its signature is similar to :meth: torch.Tensor.to , but only accepts floating point or complex :attr: dtype \\ s. In addition, this method will only cast the floating point or complex parameters and buffers to :attr: dtype (if given). The integral parameters and buffers will be moved :attr: device , if that is given, but with dtypes unchanged. When :attr: non_blocking is set, it tries to convert/move asynchronously with respect to the host if possible, e.g., moving CPU Tensors with pinned memory to CUDA devices. See below for examples. .. note:: This method modifies the module in-place. Args: device (:class: torch.device ): the desired device of the parameters and buffers in this module dtype (:class: torch.dtype ): the desired floating point or complex dtype of the parameters and buffers in this module tensor (torch.Tensor): Tensor whose dtype and device are the desired dtype and device for all parameters and buffers in this module memory_format (:class: torch.memory_format ): the desired memory format for 4D parameters and buffers in this module (keyword only argument) Returns: Module: self Examples:: >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\") >>> linear = nn.Linear(2, 2) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]]) >>> linear.to(torch.double) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]], dtype=torch.float64) >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA1) >>> gpu1 = torch.device(\"cuda:1\") >>> linear.to(gpu1, dtype=torch.half, non_blocking=True) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1') >>> cpu = torch.device(\"cpu\") >>> linear.to(cpu) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16) >>> linear = nn.Linear(2, 2, bias=None).to(torch.cdouble) >>> linear.weight Parameter containing: tensor([[ 0.3741+0.j, 0.2382+0.j], [ 0.5593+0.j, -0.4443+0.j]], dtype=torch.complex128) >>> linear(torch.ones(3, 2, dtype=torch.cdouble)) tensor([[0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j]], dtype=torch.complex128) to(self, *args, **kwargs) to_empty Move the parameters and buffers to the specified device without copying storage. Args: device (:class: torch.device ): The desired device of the parameters and buffers in this module. recurse (bool): Whether parameters and buffers of submodules should be recursively moved to the specified device. Returns: Module: self to_empty(self: ~T, *, device: Union[int, str, torch.device, NoneType], recurse: bool = True) -> ~T train Set the module in training mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e., whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. Args: mode (bool): whether to set training mode ( True ) or evaluation mode ( False ). Default: True . Returns: Module: self train(self: ~T, mode: bool = True) -> ~T type Casts all parameters and buffers to :attr: dst_type . .. note:: This method modifies the module in-place. Args: dst_type (type or string): the desired type Returns: Module: self type(self: ~T, dst_type: Union[torch.dtype, str]) -> ~T xpu Move all model parameters and buffers to the XPU. This also makes associated parameters and buffers different objects. So it should be called before constructing optimizer if the module will live on XPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self xpu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T zero_grad Reset gradients of all model parameters. See similar function under :class: torch.optim.Optimizer for more context. Args: set_to_none (bool): instead of setting to zero, set the grads to None. See :meth: torch.optim.Optimizer.zero_grad for details. zero_grad(self, set_to_none: bool = True) -> None","title":"src.model.transformer_block"},{"location":"src_model_transformer_block/#srcmodeltransformer_block","text":"","title":"src.model.transformer_block"},{"location":"src_model_transformer_block/#classes","text":"","title":"Classes"},{"location":"src_model_transformer_block/#edgeformerblock","text":"","title":"EdgeFormerBlock"},{"location":"src_model_transformer_block/#methods","text":"","title":"Methods"},{"location":"src_model_transformer_block/#__init__","text":"__init__(self, config, layer_idx=None)","title":"__init__"},{"location":"src_model_transformer_block/#add_module","text":"Add a child module to the current module. The module can be accessed as an attribute using the given name. Args: name (str): name of the child module. The child module can be accessed from this module using the given name module (Module): child module to be added to the module. add_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None","title":"add_module"},{"location":"src_model_transformer_block/#apply","text":"Apply fn recursively to every submodule (as returned by .children() ) as well as self. Typical use includes initializing the parameters of a model (see also :ref: nn-init-doc ). Args: fn (:class: Module -> None): function to be applied to each submodule Returns: Module: self Example:: >>> @torch.no_grad() >>> def init_weights(m): >>> print(m) >>> if type(m) == nn.Linear: >>> m.weight.fill_(1.0) >>> print(m.weight) >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2)) >>> net.apply(init_weights) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) apply(self: ~T, fn: Callable[[ForwardRef('Module')], NoneType]) -> ~T","title":"apply"},{"location":"src_model_transformer_block/#bfloat16","text":"Casts all floating point parameters and buffers to bfloat16 datatype. .. note:: This method modifies the module in-place. Returns: Module: self bfloat16(self: ~T) -> ~T","title":"bfloat16"},{"location":"src_model_transformer_block/#buffers","text":"Return an iterator over module buffers. Args: recurse (bool): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Yields: torch.Tensor: module buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for buf in model.buffers(): >>> print(type(buf), buf.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) buffers(self, recurse: bool = True) -> Iterator[torch.Tensor]","title":"buffers"},{"location":"src_model_transformer_block/#children","text":"Return an iterator over immediate children modules. Yields: Module: a child module children(self) -> Iterator[ForwardRef('Module')]","title":"children"},{"location":"src_model_transformer_block/#compile","text":"Compile this Module's forward using :func: torch.compile . This Module's __call__ method is compiled and all arguments are passed as-is to :func: torch.compile . See :func: torch.compile for details on the arguments for this function. compile(self, *args, **kwargs)","title":"compile"},{"location":"src_model_transformer_block/#cpu","text":"Move all model parameters and buffers to the CPU. .. note:: This method modifies the module in-place. Returns: Module: self cpu(self: ~T) -> ~T","title":"cpu"},{"location":"src_model_transformer_block/#cuda","text":"Move all model parameters and buffers to the GPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on GPU while being optimized. .. note:: This method modifies the module in-place. Args: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self cuda(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"cuda"},{"location":"src_model_transformer_block/#double","text":"Casts all floating point parameters and buffers to double datatype. .. note:: This method modifies the module in-place. Returns: Module: self double(self: ~T) -> ~T","title":"double"},{"location":"src_model_transformer_block/#eval","text":"Set the module in evaluation mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e. whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. This is equivalent with :meth: self.train(False) <torch.nn.Module.train> . See :ref: locally-disable-grad-doc for a comparison between .eval() and several similar mechanisms that may be confused with it. Returns: Module: self eval(self: ~T) -> ~T","title":"eval"},{"location":"src_model_transformer_block/#extra_repr","text":"Return the extra representation of the module. To print customized extra information, you should re-implement this method in your own modules. Both single-line and multi-line strings are acceptable. extra_repr(self) -> str","title":"extra_repr"},{"location":"src_model_transformer_block/#float","text":"Casts all floating point parameters and buffers to float datatype. .. note:: This method modifies the module in-place. Returns: Module: self float(self: ~T) -> ~T","title":"float"},{"location":"src_model_transformer_block/#forward","text":"forward(self, hidden_states, attention_mask=None, position_bias=None, head_mask=None, past_key_value=None, use_cache=False, output_attentions=False, sliding_window_size=None)","title":"forward"},{"location":"src_model_transformer_block/#get_buffer","text":"Return the buffer given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the buffer to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.Tensor: The buffer referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not a buffer get_buffer(self, target: str) -> 'Tensor'","title":"get_buffer"},{"location":"src_model_transformer_block/#get_extra_state","text":"Return any extra state to include in the module's state_dict. Implement this and a corresponding :func: set_extra_state for your module if you need to store extra state. This function is called when building the module's state_dict() . Note that extra state should be picklable to ensure working serialization of the state_dict. We only provide backwards compatibility guarantees for serializing Tensors; other objects may break backwards compatibility if their serialized pickled form changes. Returns: object: Any extra state to store in the module's state_dict get_extra_state(self) -> Any","title":"get_extra_state"},{"location":"src_model_transformer_block/#get_parameter","text":"Return the parameter given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the Parameter to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.nn.Parameter: The Parameter referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Parameter get_parameter(self, target: str) -> 'Parameter'","title":"get_parameter"},{"location":"src_model_transformer_block/#get_submodule","text":"Return the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A which has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To check whether or not we have the linear submodule, we would call get_submodule(\"net_b.linear\") . To check whether we have the conv submodule, we would call get_submodule(\"net_b.net_c.conv\") . The runtime of get_submodule is bounded by the degree of module nesting in target . A query against named_modules achieves the same result, but it is O(N) in the number of transitive modules. So, for a simple check to see if some submodule exists, get_submodule should always be used. Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) Returns: torch.nn.Module: The submodule referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module get_submodule(self, target: str) -> 'Module'","title":"get_submodule"},{"location":"src_model_transformer_block/#half","text":"Casts all floating point parameters and buffers to half datatype. .. note:: This method modifies the module in-place. Returns: Module: self half(self: ~T) -> ~T","title":"half"},{"location":"src_model_transformer_block/#ipu","text":"Move all model parameters and buffers to the IPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on IPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self ipu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"ipu"},{"location":"src_model_transformer_block/#load_state_dict","text":"Copy parameters and buffers from :attr: state_dict into this module and its descendants. If :attr: strict is True , then the keys of :attr: state_dict must exactly match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. .. warning:: If :attr: assign is True the optimizer must be created after the call to :attr: load_state_dict unless :func: ~torch.__future__.get_swap_module_params_on_conversion is True . Args: state_dict (dict): a dict containing parameters and persistent buffers. strict (bool, optional): whether to strictly enforce that the keys in :attr: state_dict match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. Default: True assign (bool, optional): When set to False , the properties of the tensors in the current module are preserved whereas setting it to True preserves properties of the Tensors in the state dict. The only exception is the requires_grad field of :class: ~torch.nn.Parameter s for which the value from the module is preserved. Default: False Returns: NamedTuple with missing_keys and unexpected_keys fields: * missing_keys is a list of str containing any keys that are expected by this module but missing from the provided state_dict . * unexpected_keys is a list of str containing the keys that are not expected by this module but present in the provided state_dict . Note: If a parameter or buffer is registered as None and its corresponding key exists in :attr: state_dict , :meth: load_state_dict will raise a RuntimeError . load_state_dict(self, state_dict: Mapping[str, Any], strict: bool = True, assign: bool = False)","title":"load_state_dict"},{"location":"src_model_transformer_block/#modules","text":"Return an iterator over all modules in the network. Yields: Module: a module in the network Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.modules()): ... print(idx, '->', m) 0 -> Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) 1 -> Linear(in_features=2, out_features=2, bias=True) modules(self) -> Iterator[ForwardRef('Module')]","title":"modules"},{"location":"src_model_transformer_block/#mtia","text":"Move all model parameters and buffers to the MTIA. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on MTIA while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self mtia(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"mtia"},{"location":"src_model_transformer_block/#named_buffers","text":"Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself. Args: prefix (str): prefix to prepend to all buffer names. recurse (bool, optional): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Defaults to True. remove_duplicate (bool, optional): whether to remove the duplicated buffers in the result. Defaults to True. Yields: (str, torch.Tensor): Tuple containing the name and buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, buf in self.named_buffers(): >>> if name in ['running_var']: >>> print(buf.size()) named_buffers(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.Tensor]]","title":"named_buffers"},{"location":"src_model_transformer_block/#named_children","text":"Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself. Yields: (str, Module): Tuple containing a name and child module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, module in model.named_children(): >>> if name in ['conv4', 'conv5']: >>> print(module) named_children(self) -> Iterator[Tuple[str, ForwardRef('Module')]]","title":"named_children"},{"location":"src_model_transformer_block/#named_modules","text":"Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself. Args: memo: a memo to store the set of modules already added to the result prefix: a prefix that will be added to the name of the module remove_duplicate: whether to remove the duplicated module instances in the result or not Yields: (str, Module): Tuple of name and module Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.named_modules()): ... print(idx, '->', m) 0 -> ('', Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) )) 1 -> ('0', Linear(in_features=2, out_features=2, bias=True)) named_modules(self, memo: Optional[Set[ForwardRef('Module')]] = None, prefix: str = '', remove_duplicate: bool = True)","title":"named_modules"},{"location":"src_model_transformer_block/#named_parameters","text":"Return an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself. Args: prefix (str): prefix to prepend to all parameter names. recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. remove_duplicate (bool, optional): whether to remove the duplicated parameters in the result. Defaults to True. Yields: (str, Parameter): Tuple containing the name and parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, param in self.named_parameters(): >>> if name in ['bias']: >>> print(param.size()) named_parameters(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.nn.parameter.Parameter]]","title":"named_parameters"},{"location":"src_model_transformer_block/#parameters","text":"Return an iterator over module parameters. This is typically passed to an optimizer. Args: recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. Yields: Parameter: module parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for param in model.parameters(): >>> print(type(param), param.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) parameters(self, recurse: bool = True) -> Iterator[torch.nn.parameter.Parameter]","title":"parameters"},{"location":"src_model_transformer_block/#register_backward_hook","text":"Register a backward hook on the module. This function is deprecated in favor of :meth: ~torch.nn.Module.register_full_backward_hook and the behavior of this function will change in future versions. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]]) -> torch.utils.hooks.RemovableHandle","title":"register_backward_hook"},{"location":"src_model_transformer_block/#register_buffer","text":"Add a buffer to the module. This is typically used to register a buffer that should not to be considered a model parameter. For example, BatchNorm's running_mean is not a parameter, but is part of the module's state. Buffers, by default, are persistent and will be saved alongside parameters. This behavior can be changed by setting :attr: persistent to False . The only difference between a persistent buffer and a non-persistent buffer is that the latter will not be a part of this module's :attr: state_dict . Buffers can be accessed as attributes using given names. Args: name (str): name of the buffer. The buffer can be accessed from this module using the given name tensor (Tensor or None): buffer to be registered. If None , then operations that run on buffers, such as :attr: cuda , are ignored. If None , the buffer is not included in the module's :attr: state_dict . persistent (bool): whether the buffer is part of this module's :attr: state_dict . Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> self.register_buffer('running_mean', torch.zeros(num_features)) register_buffer(self, name: str, tensor: Optional[torch.Tensor], persistent: bool = True) -> None","title":"register_buffer"},{"location":"src_model_transformer_block/#register_forward_hook","text":"Register a forward hook on the module. The hook will be called every time after :func: forward has computed an output. If with_kwargs is False or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the output. It can modify the input inplace but it will not have effect on forward since this is called after :func: forward is called. The hook should have the following signature:: hook(module, args, output) -> None or modified output If with_kwargs is True , the forward hook will be passed the kwargs given to the forward function and be expected to return the output possibly modified. The hook should have the following signature:: hook(module, args, kwargs, output) -> None or modified output Args: hook (Callable): The user defined hook to be registered. prepend (bool): If True , the provided hook will be fired before all existing forward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward hooks on this :class: torch.nn.modules.Module . Note that global forward hooks registered with :func: register_module_forward_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If True , the hook will be passed the kwargs given to the forward function. Default: False always_call (bool): If True the hook will be run regardless of whether an exception is raised while calling the Module. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...], Any], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any], Any], Optional[Any]]], *, prepend: bool = False, with_kwargs: bool = False, always_call: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_forward_hook"},{"location":"src_model_transformer_block/#register_forward_pre_hook","text":"Register a forward pre-hook on the module. The hook will be called every time before :func: forward is invoked. If with_kwargs is false or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the input. User can either return a tuple or a single modified value in the hook. We will wrap the value into a tuple if a single value is returned (unless that value is already a tuple). The hook should have the following signature:: hook(module, args) -> None or modified input If with_kwargs is true, the forward pre-hook will be passed the kwargs given to the forward function. And if the hook modifies the input, both the args and kwargs should be returned. The hook should have the following signature:: hook(module, args, kwargs) -> None or a tuple of modified input and kwargs Args: hook (Callable): The user defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing forward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward_pre hooks on this :class: torch.nn.modules.Module . Note that global forward_pre hooks registered with :func: register_module_forward_pre_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If true, the hook will be passed the kwargs given to the forward function. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_pre_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...]], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any]], Optional[Tuple[Any, Dict[str, Any]]]]], *, prepend: bool = False, with_kwargs: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_forward_pre_hook"},{"location":"src_model_transformer_block/#register_full_backward_hook","text":"Register a backward hook on the module. The hook will be called every time the gradients with respect to a module are computed, i.e. the hook will execute if and only if the gradients with respect to module outputs are computed. The hook should have the following signature:: hook(module, grad_input, grad_output) -> tuple(Tensor) or None The :attr: grad_input and :attr: grad_output are tuples that contain the gradients with respect to the inputs and outputs respectively. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the input that will be used in place of :attr: grad_input in subsequent computations. :attr: grad_input will only correspond to the inputs given as positional arguments and all kwarg arguments are ignored. Entries in :attr: grad_input and :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs or outputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward hooks on this :class: torch.nn.modules.Module . Note that global backward hooks registered with :func: register_module_full_backward_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_full_backward_hook"},{"location":"src_model_transformer_block/#register_full_backward_pre_hook","text":"Register a backward pre-hook on the module. The hook will be called every time the gradients for the module are computed. The hook should have the following signature:: hook(module, grad_output) -> tuple[Tensor] or None The :attr: grad_output is a tuple. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the output that will be used in place of :attr: grad_output in subsequent computations. Entries in :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward_pre hooks on this :class: torch.nn.modules.Module . Note that global backward_pre hooks registered with :func: register_module_full_backward_pre_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_pre_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_full_backward_pre_hook"},{"location":"src_model_transformer_block/#register_load_state_dict_post_hook","text":"Register a post-hook to be run after module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, incompatible_keys) -> None The module argument is the current module that this hook is registered on, and the incompatible_keys argument is a NamedTuple consisting of attributes missing_keys and unexpected_keys . missing_keys is a list of str containing the missing keys and unexpected_keys is a list of str containing the unexpected keys. The given incompatible_keys can be modified inplace if needed. Note that the checks performed when calling :func: load_state_dict with strict=True are affected by modifications the hook makes to missing_keys or unexpected_keys , as expected. Additions to either set of keys will result in an error being thrown when strict=True , and clearing out both missing and unexpected keys will avoid an error. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_load_state_dict_post_hook(self, hook)","title":"register_load_state_dict_post_hook"},{"location":"src_model_transformer_block/#register_load_state_dict_pre_hook","text":"Register a pre-hook to be run before module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs) -> None # noqa: B950 Arguments: hook (Callable): Callable hook that will be invoked before loading the state dict. register_load_state_dict_pre_hook(self, hook)","title":"register_load_state_dict_pre_hook"},{"location":"src_model_transformer_block/#register_module","text":"Alias for :func: add_module . register_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None","title":"register_module"},{"location":"src_model_transformer_block/#register_parameter","text":"Add a parameter to the module. The parameter can be accessed as an attribute using given name. Args: name (str): name of the parameter. The parameter can be accessed from this module using the given name param (Parameter or None): parameter to be added to the module. If None , then operations that run on parameters, such as :attr: cuda , are ignored. If None , the parameter is not included in the module's :attr: state_dict . register_parameter(self, name: str, param: Optional[torch.nn.parameter.Parameter]) -> None","title":"register_parameter"},{"location":"src_model_transformer_block/#register_state_dict_post_hook","text":"Register a post-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, state_dict, prefix, local_metadata) -> None The registered hooks can modify the state_dict inplace. register_state_dict_post_hook(self, hook)","title":"register_state_dict_post_hook"},{"location":"src_model_transformer_block/#register_state_dict_pre_hook","text":"Register a pre-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, prefix, keep_vars) -> None The registered hooks can be used to perform pre-processing before the state_dict call is made. register_state_dict_pre_hook(self, hook)","title":"register_state_dict_pre_hook"},{"location":"src_model_transformer_block/#requires_grad_","text":"Change if autograd should record operations on parameters in this module. This method sets the parameters' :attr: requires_grad attributes in-place. This method is helpful for freezing part of the module for finetuning or training parts of a model individually (e.g., GAN training). See :ref: locally-disable-grad-doc for a comparison between .requires_grad_() and several similar mechanisms that may be confused with it. Args: requires_grad (bool): whether autograd should record operations on parameters in this module. Default: True . Returns: Module: self requires_grad_(self: ~T, requires_grad: bool = True) -> ~T","title":"requires_grad_"},{"location":"src_model_transformer_block/#set_extra_state","text":"Set extra state contained in the loaded state_dict . This function is called from :func: load_state_dict to handle any extra state found within the state_dict . Implement this function and a corresponding :func: get_extra_state for your module if you need to store extra state within its state_dict . Args: state (dict): Extra state from the state_dict set_extra_state(self, state: Any) -> None","title":"set_extra_state"},{"location":"src_model_transformer_block/#set_submodule","text":"Set the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To overide the Conv2d with a new submodule Linear , you would call set_submodule(\"net_b.net_c.conv\", nn.Linear(33, 16)) . Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) module: The module to set the submodule to. Raises: ValueError: If the target string is empty AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module set_submodule(self, target: str, module: 'Module') -> None","title":"set_submodule"},{"location":"src_model_transformer_block/#share_memory","text":"See :meth: torch.Tensor.share_memory_ . share_memory(self: ~T) -> ~T","title":"share_memory"},{"location":"src_model_transformer_block/#state_dict","text":"Return a dictionary containing references to the whole state of the module. Both parameters and persistent buffers (e.g. running averages) are included. Keys are corresponding parameter and buffer names. Parameters and buffers set to None are not included. .. note:: The returned object is a shallow copy. It contains references to the module's parameters and buffers. .. warning:: Currently state_dict() also accepts positional arguments for destination , prefix and keep_vars in order. However, this is being deprecated and keyword arguments will be enforced in future releases. .. warning:: Please avoid the use of argument destination as it is not designed for end-users. Args: destination (dict, optional): If provided, the state of module will be updated into the dict and the same object is returned. Otherwise, an OrderedDict will be created and returned. Default: None . prefix (str, optional): a prefix added to parameter and buffer names to compose the keys in state_dict. Default: '' . keep_vars (bool, optional): by default the :class: ~torch.Tensor s returned in the state dict are detached from autograd. If it's set to True , detaching will not be performed. Default: False . Returns: dict: a dictionary containing a whole state of the module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> module.state_dict().keys() ['bias', 'weight'] state_dict(self, *args, destination=None, prefix='', keep_vars=False)","title":"state_dict"},{"location":"src_model_transformer_block/#to","text":"Move and/or cast the parameters and buffers. This can be called as .. function:: to(device=None, dtype=None, non_blocking=False) :noindex: .. function:: to(dtype, non_blocking=False) :noindex: .. function:: to(tensor, non_blocking=False) :noindex: .. function:: to(memory_format=torch.channels_last) :noindex: Its signature is similar to :meth: torch.Tensor.to , but only accepts floating point or complex :attr: dtype \\ s. In addition, this method will only cast the floating point or complex parameters and buffers to :attr: dtype (if given). The integral parameters and buffers will be moved :attr: device , if that is given, but with dtypes unchanged. When :attr: non_blocking is set, it tries to convert/move asynchronously with respect to the host if possible, e.g., moving CPU Tensors with pinned memory to CUDA devices. See below for examples. .. note:: This method modifies the module in-place. Args: device (:class: torch.device ): the desired device of the parameters and buffers in this module dtype (:class: torch.dtype ): the desired floating point or complex dtype of the parameters and buffers in this module tensor (torch.Tensor): Tensor whose dtype and device are the desired dtype and device for all parameters and buffers in this module memory_format (:class: torch.memory_format ): the desired memory format for 4D parameters and buffers in this module (keyword only argument) Returns: Module: self Examples:: >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\") >>> linear = nn.Linear(2, 2) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]]) >>> linear.to(torch.double) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]], dtype=torch.float64) >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA1) >>> gpu1 = torch.device(\"cuda:1\") >>> linear.to(gpu1, dtype=torch.half, non_blocking=True) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1') >>> cpu = torch.device(\"cpu\") >>> linear.to(cpu) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16) >>> linear = nn.Linear(2, 2, bias=None).to(torch.cdouble) >>> linear.weight Parameter containing: tensor([[ 0.3741+0.j, 0.2382+0.j], [ 0.5593+0.j, -0.4443+0.j]], dtype=torch.complex128) >>> linear(torch.ones(3, 2, dtype=torch.cdouble)) tensor([[0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j]], dtype=torch.complex128) to(self, *args, **kwargs)","title":"to"},{"location":"src_model_transformer_block/#to_empty","text":"Move the parameters and buffers to the specified device without copying storage. Args: device (:class: torch.device ): The desired device of the parameters and buffers in this module. recurse (bool): Whether parameters and buffers of submodules should be recursively moved to the specified device. Returns: Module: self to_empty(self: ~T, *, device: Union[int, str, torch.device, NoneType], recurse: bool = True) -> ~T","title":"to_empty"},{"location":"src_model_transformer_block/#train","text":"Set the module in training mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e., whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. Args: mode (bool): whether to set training mode ( True ) or evaluation mode ( False ). Default: True . Returns: Module: self train(self: ~T, mode: bool = True) -> ~T","title":"train"},{"location":"src_model_transformer_block/#type","text":"Casts all parameters and buffers to :attr: dst_type . .. note:: This method modifies the module in-place. Args: dst_type (type or string): the desired type Returns: Module: self type(self: ~T, dst_type: Union[torch.dtype, str]) -> ~T","title":"type"},{"location":"src_model_transformer_block/#xpu","text":"Move all model parameters and buffers to the XPU. This also makes associated parameters and buffers different objects. So it should be called before constructing optimizer if the module will live on XPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self xpu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"xpu"},{"location":"src_model_transformer_block/#zero_grad","text":"Reset gradients of all model parameters. See similar function under :class: torch.optim.Optimizer for more context. Args: set_to_none (bool): instead of setting to zero, set the grads to None. See :meth: torch.optim.Optimizer.zero_grad for details. zero_grad(self, set_to_none: bool = True) -> None","title":"zero_grad"},{"location":"src_utils_data_augmentation/","text":"src.utils.data_augmentation Classes SlidingWindowDataset Dataset for sliding window sampling of long documents. Methods __init__ Args: documents: List of documents (strings or token lists) tokenizer: Tokenizer for tokenizing text block_size: Size of text blocks to return stride: Stride for sliding window apply_augmentation: Whether to apply augmentation p_augment: Probability of applying augmentation __init__(self, documents, tokenizer, block_size=128, stride=64, apply_augmentation=False, p_augment=0.5) create_examples Create examples using sliding window. create_examples(self) TemperatureBasedSampling Temperature-based sampling for more diverse training examples. Methods generate_diverse_samples Generate diverse samples using temperature-based sampling. generate_diverse_samples(model, input_ids, num_samples=4, max_length=128, temperature=1.2, top_k=50, top_p=0.95) sample_from_logits Sample from logits with temperature, top-k, and nucleus sampling. sample_from_logits(logits, temperature=1.0, top_k=0, top_p=0.0) TextAugmentation Text augmentation techniques for NLP training. Methods apply_augmentations Apply multiple augmentation techniques. apply_augmentations(tokens, vocab=None, p_del=0.1, p_swap=0.1, p_repl=0.1) random_deletion Randomly delete tokens with probability p. random_deletion(tokens, p=0.1) random_replacement Replace tokens with random tokens from vocabulary with probability p. random_replacement(tokens, vocab, p=0.1) random_swap Randomly swap n pairs of tokens. random_swap(tokens, n=1)","title":"src.utils.data_augmentation"},{"location":"src_utils_data_augmentation/#srcutilsdata_augmentation","text":"","title":"src.utils.data_augmentation"},{"location":"src_utils_data_augmentation/#classes","text":"","title":"Classes"},{"location":"src_utils_data_augmentation/#slidingwindowdataset","text":"Dataset for sliding window sampling of long documents.","title":"SlidingWindowDataset"},{"location":"src_utils_data_augmentation/#methods","text":"","title":"Methods"},{"location":"src_utils_data_augmentation/#__init__","text":"Args: documents: List of documents (strings or token lists) tokenizer: Tokenizer for tokenizing text block_size: Size of text blocks to return stride: Stride for sliding window apply_augmentation: Whether to apply augmentation p_augment: Probability of applying augmentation __init__(self, documents, tokenizer, block_size=128, stride=64, apply_augmentation=False, p_augment=0.5)","title":"__init__"},{"location":"src_utils_data_augmentation/#create_examples","text":"Create examples using sliding window. create_examples(self)","title":"create_examples"},{"location":"src_utils_data_augmentation/#temperaturebasedsampling","text":"Temperature-based sampling for more diverse training examples.","title":"TemperatureBasedSampling"},{"location":"src_utils_data_augmentation/#methods_1","text":"","title":"Methods"},{"location":"src_utils_data_augmentation/#generate_diverse_samples","text":"Generate diverse samples using temperature-based sampling. generate_diverse_samples(model, input_ids, num_samples=4, max_length=128, temperature=1.2, top_k=50, top_p=0.95)","title":"generate_diverse_samples"},{"location":"src_utils_data_augmentation/#sample_from_logits","text":"Sample from logits with temperature, top-k, and nucleus sampling. sample_from_logits(logits, temperature=1.0, top_k=0, top_p=0.0)","title":"sample_from_logits"},{"location":"src_utils_data_augmentation/#textaugmentation","text":"Text augmentation techniques for NLP training.","title":"TextAugmentation"},{"location":"src_utils_data_augmentation/#methods_2","text":"","title":"Methods"},{"location":"src_utils_data_augmentation/#apply_augmentations","text":"Apply multiple augmentation techniques. apply_augmentations(tokens, vocab=None, p_del=0.1, p_swap=0.1, p_repl=0.1)","title":"apply_augmentations"},{"location":"src_utils_data_augmentation/#random_deletion","text":"Randomly delete tokens with probability p. random_deletion(tokens, p=0.1)","title":"random_deletion"},{"location":"src_utils_data_augmentation/#random_replacement","text":"Replace tokens with random tokens from vocabulary with probability p. random_replacement(tokens, vocab, p=0.1)","title":"random_replacement"},{"location":"src_utils_data_augmentation/#random_swap","text":"Randomly swap n pairs of tokens. random_swap(tokens, n=1)","title":"random_swap"},{"location":"src_utils_device/","text":"src.utils.device Functions export_to_onnx Export PyTorch model to ONNX format optimized for DirectML. export_to_onnx(model, onnx_path, input_shape=(1, 512)) get_device Get the best available device, with special handling for AMD GPUs. Returns: torch.device: The best available device get_device() get_optimized_directml_session Create an optimized ONNX session with DirectML provider. get_optimized_directml_session(onnx_path) is_amd_gpu_available Check if an AMD GPU is available on the system. is_amd_gpu_available() optimize_for_amd Apply optimizations specific to AMD GPUs. optimize_for_amd(model) print_device_info Print detailed information about available compute devices. print_device_info() run_with_directml Run inference using DirectML provider. run_with_directml(session, input_ids, attention_mask)","title":"src.utils.device"},{"location":"src_utils_device/#srcutilsdevice","text":"","title":"src.utils.device"},{"location":"src_utils_device/#functions","text":"","title":"Functions"},{"location":"src_utils_device/#export_to_onnx","text":"Export PyTorch model to ONNX format optimized for DirectML. export_to_onnx(model, onnx_path, input_shape=(1, 512))","title":"export_to_onnx"},{"location":"src_utils_device/#get_device","text":"Get the best available device, with special handling for AMD GPUs. Returns: torch.device: The best available device get_device()","title":"get_device"},{"location":"src_utils_device/#get_optimized_directml_session","text":"Create an optimized ONNX session with DirectML provider. get_optimized_directml_session(onnx_path)","title":"get_optimized_directml_session"},{"location":"src_utils_device/#is_amd_gpu_available","text":"Check if an AMD GPU is available on the system. is_amd_gpu_available()","title":"is_amd_gpu_available"},{"location":"src_utils_device/#optimize_for_amd","text":"Apply optimizations specific to AMD GPUs. optimize_for_amd(model)","title":"optimize_for_amd"},{"location":"src_utils_device/#print_device_info","text":"Print detailed information about available compute devices. print_device_info()","title":"print_device_info"},{"location":"src_utils_device/#run_with_directml","text":"Run inference using DirectML provider. run_with_directml(session, input_ids, attention_mask)","title":"run_with_directml"},{"location":"src_utils_kv_cache_offload/","text":"src.utils.kv_cache_offload Functions kv_cache_offload Enable KV cache offloading to disk for a model. Args: model: The EdgeFormer model to enable offloading for offload_path: Path to store KV cache files (default: temporary directory) kv_cache_dtype: Data type for KV cache (default: same as model) Returns: Model with KV cache offloading enabled kv_cache_offload(model, offload_path=None, kv_cache_dtype=None) load_kv_cache_from_disk Load KV cache from disk. load_kv_cache_from_disk(model, offload_id) save_kv_cache_to_disk Save KV cache to disk. save_kv_cache_to_disk(model, past_key_values, offload_id)","title":"src.utils.kv_cache_offload"},{"location":"src_utils_kv_cache_offload/#srcutilskv_cache_offload","text":"","title":"src.utils.kv_cache_offload"},{"location":"src_utils_kv_cache_offload/#functions","text":"","title":"Functions"},{"location":"src_utils_kv_cache_offload/#kv_cache_offload","text":"Enable KV cache offloading to disk for a model. Args: model: The EdgeFormer model to enable offloading for offload_path: Path to store KV cache files (default: temporary directory) kv_cache_dtype: Data type for KV cache (default: same as model) Returns: Model with KV cache offloading enabled kv_cache_offload(model, offload_path=None, kv_cache_dtype=None)","title":"kv_cache_offload"},{"location":"src_utils_kv_cache_offload/#load_kv_cache_from_disk","text":"Load KV cache from disk. load_kv_cache_from_disk(model, offload_id)","title":"load_kv_cache_from_disk"},{"location":"src_utils_kv_cache_offload/#save_kv_cache_to_disk","text":"Save KV cache to disk. save_kv_cache_to_disk(model, past_key_values, offload_id)","title":"save_kv_cache_to_disk"},{"location":"src_utils_rdna3_optimizations/","text":"src.utils.rdna3_optimizations Functions create_directml_provider_options_for_rdna3 Create optimized DirectML provider options for RDNA3 GPUs. Returns: A list of provider options for DirectML and CPU providers create_directml_provider_options_for_rdna3() create_torch_directml_config_for_rdna3 Create optimized torch-directml configuration for RDNA3 GPUs. Returns: A dictionary with torch-directml configuration options create_torch_directml_config_for_rdna3() get_rdna3_device Get the best device for RDNA3 GPUs. Returns: torch.device: The device to use get_rdna3_device() is_rdna3_gpu Detect if the system has an AMD RDNA3 architecture GPU. Returns: bool: True if RDNA3 GPU is detected, False otherwise is_rdna3_gpu() optimize_for_rdna3 Apply RDNA3-specific optimizations to the model. Args: model: The EdgeFormer model to optimize Returns: The optimized model optimize_for_rdna3(model)","title":"src.utils.rdna3_optimizations"},{"location":"src_utils_rdna3_optimizations/#srcutilsrdna3_optimizations","text":"","title":"src.utils.rdna3_optimizations"},{"location":"src_utils_rdna3_optimizations/#functions","text":"","title":"Functions"},{"location":"src_utils_rdna3_optimizations/#create_directml_provider_options_for_rdna3","text":"Create optimized DirectML provider options for RDNA3 GPUs. Returns: A list of provider options for DirectML and CPU providers create_directml_provider_options_for_rdna3()","title":"create_directml_provider_options_for_rdna3"},{"location":"src_utils_rdna3_optimizations/#create_torch_directml_config_for_rdna3","text":"Create optimized torch-directml configuration for RDNA3 GPUs. Returns: A dictionary with torch-directml configuration options create_torch_directml_config_for_rdna3()","title":"create_torch_directml_config_for_rdna3"},{"location":"src_utils_rdna3_optimizations/#get_rdna3_device","text":"Get the best device for RDNA3 GPUs. Returns: torch.device: The device to use get_rdna3_device()","title":"get_rdna3_device"},{"location":"src_utils_rdna3_optimizations/#is_rdna3_gpu","text":"Detect if the system has an AMD RDNA3 architecture GPU. Returns: bool: True if RDNA3 GPU is detected, False otherwise is_rdna3_gpu()","title":"is_rdna3_gpu"},{"location":"src_utils_rdna3_optimizations/#optimize_for_rdna3","text":"Apply RDNA3-specific optimizations to the model. Args: model: The EdgeFormer model to optimize Returns: The optimized model optimize_for_rdna3(model)","title":"optimize_for_rdna3"},{"location":"src_utils_training_utils/","text":"src.utils.training_utils Classes TrainingConfig Configuration for optimized training pipeline. Methods __init__ __init__(self, learning_rate=5e-05, weight_decay=0.01, adam_epsilon=1e-08, warmup_steps=0, max_grad_norm=1.0, gradient_accumulation_steps=1, mixed_precision=False, num_train_epochs=3, per_device_train_batch_size=8, logging_steps=50, save_steps=500, eval_steps=100, output_dir='./output') Functions evaluate Evaluate the model. evaluate(model, eval_dataset, config, collate_fn=None) get_optimizer_and_scheduler Create optimizer and scheduler with appropriate settings. get_optimizer_and_scheduler(model, config, num_training_steps) train Train the model with optimized pipeline including gradient accumulation and mixed precision. train(model, train_dataset, config, eval_dataset=None, collate_fn=None)","title":"src.utils.training_utils"},{"location":"src_utils_training_utils/#srcutilstraining_utils","text":"","title":"src.utils.training_utils"},{"location":"src_utils_training_utils/#classes","text":"","title":"Classes"},{"location":"src_utils_training_utils/#trainingconfig","text":"Configuration for optimized training pipeline.","title":"TrainingConfig"},{"location":"src_utils_training_utils/#methods","text":"","title":"Methods"},{"location":"src_utils_training_utils/#__init__","text":"__init__(self, learning_rate=5e-05, weight_decay=0.01, adam_epsilon=1e-08, warmup_steps=0, max_grad_norm=1.0, gradient_accumulation_steps=1, mixed_precision=False, num_train_epochs=3, per_device_train_batch_size=8, logging_steps=50, save_steps=500, eval_steps=100, output_dir='./output')","title":"__init__"},{"location":"src_utils_training_utils/#functions","text":"","title":"Functions"},{"location":"src_utils_training_utils/#evaluate","text":"Evaluate the model. evaluate(model, eval_dataset, config, collate_fn=None)","title":"evaluate"},{"location":"src_utils_training_utils/#get_optimizer_and_scheduler","text":"Create optimizer and scheduler with appropriate settings. get_optimizer_and_scheduler(model, config, num_training_steps)","title":"get_optimizer_and_scheduler"},{"location":"src_utils_training_utils/#train","text":"Train the model with optimized pipeline including gradient accumulation and mixed precision. train(model, train_dataset, config, eval_dataset=None, collate_fn=None)","title":"train"},{"location":"src_utils_weight_quantization/","text":"src.utils.weight_quantization Classes WeightOnlyQuantizedLinear Linear layer with weight-only quantization. Methods __init__ __init__(self, orig_layer, weight, scales, zeros, bits=4, group_size=128, symmetric=True) add_module Add a child module to the current module. The module can be accessed as an attribute using the given name. Args: name (str): name of the child module. The child module can be accessed from this module using the given name module (Module): child module to be added to the module. add_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None apply Apply fn recursively to every submodule (as returned by .children() ) as well as self. Typical use includes initializing the parameters of a model (see also :ref: nn-init-doc ). Args: fn (:class: Module -> None): function to be applied to each submodule Returns: Module: self Example:: >>> @torch.no_grad() >>> def init_weights(m): >>> print(m) >>> if type(m) == nn.Linear: >>> m.weight.fill_(1.0) >>> print(m.weight) >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2)) >>> net.apply(init_weights) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) apply(self: ~T, fn: Callable[[ForwardRef('Module')], NoneType]) -> ~T bfloat16 Casts all floating point parameters and buffers to bfloat16 datatype. .. note:: This method modifies the module in-place. Returns: Module: self bfloat16(self: ~T) -> ~T buffers Return an iterator over module buffers. Args: recurse (bool): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Yields: torch.Tensor: module buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for buf in model.buffers(): >>> print(type(buf), buf.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) buffers(self, recurse: bool = True) -> Iterator[torch.Tensor] children Return an iterator over immediate children modules. Yields: Module: a child module children(self) -> Iterator[ForwardRef('Module')] compile Compile this Module's forward using :func: torch.compile . This Module's __call__ method is compiled and all arguments are passed as-is to :func: torch.compile . See :func: torch.compile for details on the arguments for this function. compile(self, *args, **kwargs) cpu Move all model parameters and buffers to the CPU. .. note:: This method modifies the module in-place. Returns: Module: self cpu(self: ~T) -> ~T cuda Move all model parameters and buffers to the GPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on GPU while being optimized. .. note:: This method modifies the module in-place. Args: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self cuda(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T double Casts all floating point parameters and buffers to double datatype. .. note:: This method modifies the module in-place. Returns: Module: self double(self: ~T) -> ~T eval Set the module in evaluation mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e. whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. This is equivalent with :meth: self.train(False) <torch.nn.Module.train> . See :ref: locally-disable-grad-doc for a comparison between .eval() and several similar mechanisms that may be confused with it. Returns: Module: self eval(self: ~T) -> ~T extra_repr Return the extra representation of the module. To print customized extra information, you should re-implement this method in your own modules. Both single-line and multi-line strings are acceptable. extra_repr(self) -> str float Casts all floating point parameters and buffers to float datatype. .. note:: This method modifies the module in-place. Returns: Module: self float(self: ~T) -> ~T forward forward(self, input) get_buffer Return the buffer given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the buffer to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.Tensor: The buffer referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not a buffer get_buffer(self, target: str) -> 'Tensor' get_extra_state Return any extra state to include in the module's state_dict. Implement this and a corresponding :func: set_extra_state for your module if you need to store extra state. This function is called when building the module's state_dict() . Note that extra state should be picklable to ensure working serialization of the state_dict. We only provide backwards compatibility guarantees for serializing Tensors; other objects may break backwards compatibility if their serialized pickled form changes. Returns: object: Any extra state to store in the module's state_dict get_extra_state(self) -> Any get_parameter Return the parameter given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the Parameter to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.nn.Parameter: The Parameter referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Parameter get_parameter(self, target: str) -> 'Parameter' get_submodule Return the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A which has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To check whether or not we have the linear submodule, we would call get_submodule(\"net_b.linear\") . To check whether we have the conv submodule, we would call get_submodule(\"net_b.net_c.conv\") . The runtime of get_submodule is bounded by the degree of module nesting in target . A query against named_modules achieves the same result, but it is O(N) in the number of transitive modules. So, for a simple check to see if some submodule exists, get_submodule should always be used. Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) Returns: torch.nn.Module: The submodule referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module get_submodule(self, target: str) -> 'Module' half Casts all floating point parameters and buffers to half datatype. .. note:: This method modifies the module in-place. Returns: Module: self half(self: ~T) -> ~T ipu Move all model parameters and buffers to the IPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on IPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self ipu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T load_state_dict Copy parameters and buffers from :attr: state_dict into this module and its descendants. If :attr: strict is True , then the keys of :attr: state_dict must exactly match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. .. warning:: If :attr: assign is True the optimizer must be created after the call to :attr: load_state_dict unless :func: ~torch.__future__.get_swap_module_params_on_conversion is True . Args: state_dict (dict): a dict containing parameters and persistent buffers. strict (bool, optional): whether to strictly enforce that the keys in :attr: state_dict match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. Default: True assign (bool, optional): When set to False , the properties of the tensors in the current module are preserved whereas setting it to True preserves properties of the Tensors in the state dict. The only exception is the requires_grad field of :class: ~torch.nn.Parameter s for which the value from the module is preserved. Default: False Returns: NamedTuple with missing_keys and unexpected_keys fields: * missing_keys is a list of str containing any keys that are expected by this module but missing from the provided state_dict . * unexpected_keys is a list of str containing the keys that are not expected by this module but present in the provided state_dict . Note: If a parameter or buffer is registered as None and its corresponding key exists in :attr: state_dict , :meth: load_state_dict will raise a RuntimeError . load_state_dict(self, state_dict: Mapping[str, Any], strict: bool = True, assign: bool = False) modules Return an iterator over all modules in the network. Yields: Module: a module in the network Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.modules()): ... print(idx, '->', m) 0 -> Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) 1 -> Linear(in_features=2, out_features=2, bias=True) modules(self) -> Iterator[ForwardRef('Module')] mtia Move all model parameters and buffers to the MTIA. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on MTIA while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self mtia(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T named_buffers Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself. Args: prefix (str): prefix to prepend to all buffer names. recurse (bool, optional): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Defaults to True. remove_duplicate (bool, optional): whether to remove the duplicated buffers in the result. Defaults to True. Yields: (str, torch.Tensor): Tuple containing the name and buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, buf in self.named_buffers(): >>> if name in ['running_var']: >>> print(buf.size()) named_buffers(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.Tensor]] named_children Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself. Yields: (str, Module): Tuple containing a name and child module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, module in model.named_children(): >>> if name in ['conv4', 'conv5']: >>> print(module) named_children(self) -> Iterator[Tuple[str, ForwardRef('Module')]] named_modules Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself. Args: memo: a memo to store the set of modules already added to the result prefix: a prefix that will be added to the name of the module remove_duplicate: whether to remove the duplicated module instances in the result or not Yields: (str, Module): Tuple of name and module Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.named_modules()): ... print(idx, '->', m) 0 -> ('', Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) )) 1 -> ('0', Linear(in_features=2, out_features=2, bias=True)) named_modules(self, memo: Optional[Set[ForwardRef('Module')]] = None, prefix: str = '', remove_duplicate: bool = True) named_parameters Return an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself. Args: prefix (str): prefix to prepend to all parameter names. recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. remove_duplicate (bool, optional): whether to remove the duplicated parameters in the result. Defaults to True. Yields: (str, Parameter): Tuple containing the name and parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, param in self.named_parameters(): >>> if name in ['bias']: >>> print(param.size()) named_parameters(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.nn.parameter.Parameter]] parameters Return an iterator over module parameters. This is typically passed to an optimizer. Args: recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. Yields: Parameter: module parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for param in model.parameters(): >>> print(type(param), param.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) parameters(self, recurse: bool = True) -> Iterator[torch.nn.parameter.Parameter] register_backward_hook Register a backward hook on the module. This function is deprecated in favor of :meth: ~torch.nn.Module.register_full_backward_hook and the behavior of this function will change in future versions. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]]) -> torch.utils.hooks.RemovableHandle register_buffer Add a buffer to the module. This is typically used to register a buffer that should not to be considered a model parameter. For example, BatchNorm's running_mean is not a parameter, but is part of the module's state. Buffers, by default, are persistent and will be saved alongside parameters. This behavior can be changed by setting :attr: persistent to False . The only difference between a persistent buffer and a non-persistent buffer is that the latter will not be a part of this module's :attr: state_dict . Buffers can be accessed as attributes using given names. Args: name (str): name of the buffer. The buffer can be accessed from this module using the given name tensor (Tensor or None): buffer to be registered. If None , then operations that run on buffers, such as :attr: cuda , are ignored. If None , the buffer is not included in the module's :attr: state_dict . persistent (bool): whether the buffer is part of this module's :attr: state_dict . Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> self.register_buffer('running_mean', torch.zeros(num_features)) register_buffer(self, name: str, tensor: Optional[torch.Tensor], persistent: bool = True) -> None register_forward_hook Register a forward hook on the module. The hook will be called every time after :func: forward has computed an output. If with_kwargs is False or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the output. It can modify the input inplace but it will not have effect on forward since this is called after :func: forward is called. The hook should have the following signature:: hook(module, args, output) -> None or modified output If with_kwargs is True , the forward hook will be passed the kwargs given to the forward function and be expected to return the output possibly modified. The hook should have the following signature:: hook(module, args, kwargs, output) -> None or modified output Args: hook (Callable): The user defined hook to be registered. prepend (bool): If True , the provided hook will be fired before all existing forward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward hooks on this :class: torch.nn.modules.Module . Note that global forward hooks registered with :func: register_module_forward_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If True , the hook will be passed the kwargs given to the forward function. Default: False always_call (bool): If True the hook will be run regardless of whether an exception is raised while calling the Module. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...], Any], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any], Any], Optional[Any]]], *, prepend: bool = False, with_kwargs: bool = False, always_call: bool = False) -> torch.utils.hooks.RemovableHandle register_forward_pre_hook Register a forward pre-hook on the module. The hook will be called every time before :func: forward is invoked. If with_kwargs is false or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the input. User can either return a tuple or a single modified value in the hook. We will wrap the value into a tuple if a single value is returned (unless that value is already a tuple). The hook should have the following signature:: hook(module, args) -> None or modified input If with_kwargs is true, the forward pre-hook will be passed the kwargs given to the forward function. And if the hook modifies the input, both the args and kwargs should be returned. The hook should have the following signature:: hook(module, args, kwargs) -> None or a tuple of modified input and kwargs Args: hook (Callable): The user defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing forward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward_pre hooks on this :class: torch.nn.modules.Module . Note that global forward_pre hooks registered with :func: register_module_forward_pre_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If true, the hook will be passed the kwargs given to the forward function. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_pre_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...]], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any]], Optional[Tuple[Any, Dict[str, Any]]]]], *, prepend: bool = False, with_kwargs: bool = False) -> torch.utils.hooks.RemovableHandle register_full_backward_hook Register a backward hook on the module. The hook will be called every time the gradients with respect to a module are computed, i.e. the hook will execute if and only if the gradients with respect to module outputs are computed. The hook should have the following signature:: hook(module, grad_input, grad_output) -> tuple(Tensor) or None The :attr: grad_input and :attr: grad_output are tuples that contain the gradients with respect to the inputs and outputs respectively. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the input that will be used in place of :attr: grad_input in subsequent computations. :attr: grad_input will only correspond to the inputs given as positional arguments and all kwarg arguments are ignored. Entries in :attr: grad_input and :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs or outputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward hooks on this :class: torch.nn.modules.Module . Note that global backward hooks registered with :func: register_module_full_backward_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle register_full_backward_pre_hook Register a backward pre-hook on the module. The hook will be called every time the gradients for the module are computed. The hook should have the following signature:: hook(module, grad_output) -> tuple[Tensor] or None The :attr: grad_output is a tuple. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the output that will be used in place of :attr: grad_output in subsequent computations. Entries in :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward_pre hooks on this :class: torch.nn.modules.Module . Note that global backward_pre hooks registered with :func: register_module_full_backward_pre_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_pre_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle register_load_state_dict_post_hook Register a post-hook to be run after module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, incompatible_keys) -> None The module argument is the current module that this hook is registered on, and the incompatible_keys argument is a NamedTuple consisting of attributes missing_keys and unexpected_keys . missing_keys is a list of str containing the missing keys and unexpected_keys is a list of str containing the unexpected keys. The given incompatible_keys can be modified inplace if needed. Note that the checks performed when calling :func: load_state_dict with strict=True are affected by modifications the hook makes to missing_keys or unexpected_keys , as expected. Additions to either set of keys will result in an error being thrown when strict=True , and clearing out both missing and unexpected keys will avoid an error. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_load_state_dict_post_hook(self, hook) register_load_state_dict_pre_hook Register a pre-hook to be run before module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs) -> None # noqa: B950 Arguments: hook (Callable): Callable hook that will be invoked before loading the state dict. register_load_state_dict_pre_hook(self, hook) register_module Alias for :func: add_module . register_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None register_parameter Add a parameter to the module. The parameter can be accessed as an attribute using given name. Args: name (str): name of the parameter. The parameter can be accessed from this module using the given name param (Parameter or None): parameter to be added to the module. If None , then operations that run on parameters, such as :attr: cuda , are ignored. If None , the parameter is not included in the module's :attr: state_dict . register_parameter(self, name: str, param: Optional[torch.nn.parameter.Parameter]) -> None register_state_dict_post_hook Register a post-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, state_dict, prefix, local_metadata) -> None The registered hooks can modify the state_dict inplace. register_state_dict_post_hook(self, hook) register_state_dict_pre_hook Register a pre-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, prefix, keep_vars) -> None The registered hooks can be used to perform pre-processing before the state_dict call is made. register_state_dict_pre_hook(self, hook) requires_grad_ Change if autograd should record operations on parameters in this module. This method sets the parameters' :attr: requires_grad attributes in-place. This method is helpful for freezing part of the module for finetuning or training parts of a model individually (e.g., GAN training). See :ref: locally-disable-grad-doc for a comparison between .requires_grad_() and several similar mechanisms that may be confused with it. Args: requires_grad (bool): whether autograd should record operations on parameters in this module. Default: True . Returns: Module: self requires_grad_(self: ~T, requires_grad: bool = True) -> ~T set_extra_state Set extra state contained in the loaded state_dict . This function is called from :func: load_state_dict to handle any extra state found within the state_dict . Implement this function and a corresponding :func: get_extra_state for your module if you need to store extra state within its state_dict . Args: state (dict): Extra state from the state_dict set_extra_state(self, state: Any) -> None set_submodule Set the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To overide the Conv2d with a new submodule Linear , you would call set_submodule(\"net_b.net_c.conv\", nn.Linear(33, 16)) . Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) module: The module to set the submodule to. Raises: ValueError: If the target string is empty AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module set_submodule(self, target: str, module: 'Module') -> None share_memory See :meth: torch.Tensor.share_memory_ . share_memory(self: ~T) -> ~T state_dict Return a dictionary containing references to the whole state of the module. Both parameters and persistent buffers (e.g. running averages) are included. Keys are corresponding parameter and buffer names. Parameters and buffers set to None are not included. .. note:: The returned object is a shallow copy. It contains references to the module's parameters and buffers. .. warning:: Currently state_dict() also accepts positional arguments for destination , prefix and keep_vars in order. However, this is being deprecated and keyword arguments will be enforced in future releases. .. warning:: Please avoid the use of argument destination as it is not designed for end-users. Args: destination (dict, optional): If provided, the state of module will be updated into the dict and the same object is returned. Otherwise, an OrderedDict will be created and returned. Default: None . prefix (str, optional): a prefix added to parameter and buffer names to compose the keys in state_dict. Default: '' . keep_vars (bool, optional): by default the :class: ~torch.Tensor s returned in the state dict are detached from autograd. If it's set to True , detaching will not be performed. Default: False . Returns: dict: a dictionary containing a whole state of the module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> module.state_dict().keys() ['bias', 'weight'] state_dict(self, *args, destination=None, prefix='', keep_vars=False) to Move and/or cast the parameters and buffers. This can be called as .. function:: to(device=None, dtype=None, non_blocking=False) :noindex: .. function:: to(dtype, non_blocking=False) :noindex: .. function:: to(tensor, non_blocking=False) :noindex: .. function:: to(memory_format=torch.channels_last) :noindex: Its signature is similar to :meth: torch.Tensor.to , but only accepts floating point or complex :attr: dtype \\ s. In addition, this method will only cast the floating point or complex parameters and buffers to :attr: dtype (if given). The integral parameters and buffers will be moved :attr: device , if that is given, but with dtypes unchanged. When :attr: non_blocking is set, it tries to convert/move asynchronously with respect to the host if possible, e.g., moving CPU Tensors with pinned memory to CUDA devices. See below for examples. .. note:: This method modifies the module in-place. Args: device (:class: torch.device ): the desired device of the parameters and buffers in this module dtype (:class: torch.dtype ): the desired floating point or complex dtype of the parameters and buffers in this module tensor (torch.Tensor): Tensor whose dtype and device are the desired dtype and device for all parameters and buffers in this module memory_format (:class: torch.memory_format ): the desired memory format for 4D parameters and buffers in this module (keyword only argument) Returns: Module: self Examples:: >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\") >>> linear = nn.Linear(2, 2) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]]) >>> linear.to(torch.double) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]], dtype=torch.float64) >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA1) >>> gpu1 = torch.device(\"cuda:1\") >>> linear.to(gpu1, dtype=torch.half, non_blocking=True) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1') >>> cpu = torch.device(\"cpu\") >>> linear.to(cpu) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16) >>> linear = nn.Linear(2, 2, bias=None).to(torch.cdouble) >>> linear.weight Parameter containing: tensor([[ 0.3741+0.j, 0.2382+0.j], [ 0.5593+0.j, -0.4443+0.j]], dtype=torch.complex128) >>> linear(torch.ones(3, 2, dtype=torch.cdouble)) tensor([[0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j]], dtype=torch.complex128) to(self, *args, **kwargs) to_empty Move the parameters and buffers to the specified device without copying storage. Args: device (:class: torch.device ): The desired device of the parameters and buffers in this module. recurse (bool): Whether parameters and buffers of submodules should be recursively moved to the specified device. Returns: Module: self to_empty(self: ~T, *, device: Union[int, str, torch.device, NoneType], recurse: bool = True) -> ~T train Set the module in training mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e., whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. Args: mode (bool): whether to set training mode ( True ) or evaluation mode ( False ). Default: True . Returns: Module: self train(self: ~T, mode: bool = True) -> ~T type Casts all parameters and buffers to :attr: dst_type . .. note:: This method modifies the module in-place. Args: dst_type (type or string): the desired type Returns: Module: self type(self: ~T, dst_type: Union[torch.dtype, str]) -> ~T xpu Move all model parameters and buffers to the XPU. This also makes associated parameters and buffers different objects. So it should be called before constructing optimizer if the module will live on XPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self xpu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T zero_grad Reset gradients of all model parameters. See similar function under :class: torch.optim.Optimizer for more context. Args: set_to_none (bool): instead of setting to zero, set the grads to None. See :meth: torch.optim.Optimizer.zero_grad for details. zero_grad(self, set_to_none: bool = True) -> None Functions compare_quantization_configs Compare different quantization configurations and visualize results. Args: model: The original model inputs: Input tensors configs: List of quantization configs to test output_dir: Directory to save results Returns: Dict with comparison results compare_quantization_configs(model, inputs, configs=None, output_dir=None) kv_cache_offload Enable KV cache offloading to disk for the given model. Args: model: The EdgeFormer model offload_path: Directory to store KV cache files (default: temporary directory) kv_cache_dtype: Data type for stored KV cache (default: float16 for memory efficiency) Returns: Modified model with KV cache offloading enabled kv_cache_offload(model, offload_path=None, kv_cache_dtype=torch.float16) quantize_weight_only Quantize only the weights of a linear layer. Args: module: The linear layer to quantize bits: Bit width for quantization (4 or 8) group_size: Size of quantization groups symmetric: Whether to use symmetric quantization Returns: A weight-only quantized linear layer quantize_weight_only(module, bits=4, group_size=128, symmetric=True) test_weight_only_quantization Test weight-only quantization by comparing outputs with the original model. Args: model: The original model inputs: Input tensors bits: Bit width for quantization (4 or 8) group_size: Size of quantization groups symmetric: Whether to use symmetric quantization Returns: Dict with comparison metrics test_weight_only_quantization(model, inputs, bits=4, group_size=128, symmetric=True) weight_only_quantize_model Apply weight-only quantization to a model's linear layers. Args: model: The model to quantize bits: Bit width for quantization (4 or 8) group_size: Size of quantization groups symmetric: Whether to use symmetric quantization modules_to_exclude: List of module names to exclude from quantization Returns: A weight-only quantized model weight_only_quantize_model(model, bits=4, group_size=128, symmetric=True, modules_to_exclude=None)","title":"src.utils.weight_quantization"},{"location":"src_utils_weight_quantization/#srcutilsweight_quantization","text":"","title":"src.utils.weight_quantization"},{"location":"src_utils_weight_quantization/#classes","text":"","title":"Classes"},{"location":"src_utils_weight_quantization/#weightonlyquantizedlinear","text":"Linear layer with weight-only quantization.","title":"WeightOnlyQuantizedLinear"},{"location":"src_utils_weight_quantization/#methods","text":"","title":"Methods"},{"location":"src_utils_weight_quantization/#__init__","text":"__init__(self, orig_layer, weight, scales, zeros, bits=4, group_size=128, symmetric=True)","title":"__init__"},{"location":"src_utils_weight_quantization/#add_module","text":"Add a child module to the current module. The module can be accessed as an attribute using the given name. Args: name (str): name of the child module. The child module can be accessed from this module using the given name module (Module): child module to be added to the module. add_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None","title":"add_module"},{"location":"src_utils_weight_quantization/#apply","text":"Apply fn recursively to every submodule (as returned by .children() ) as well as self. Typical use includes initializing the parameters of a model (see also :ref: nn-init-doc ). Args: fn (:class: Module -> None): function to be applied to each submodule Returns: Module: self Example:: >>> @torch.no_grad() >>> def init_weights(m): >>> print(m) >>> if type(m) == nn.Linear: >>> m.weight.fill_(1.0) >>> print(m.weight) >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2)) >>> net.apply(init_weights) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Linear(in_features=2, out_features=2, bias=True) Parameter containing: tensor([[1., 1.], [1., 1.]], requires_grad=True) Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) apply(self: ~T, fn: Callable[[ForwardRef('Module')], NoneType]) -> ~T","title":"apply"},{"location":"src_utils_weight_quantization/#bfloat16","text":"Casts all floating point parameters and buffers to bfloat16 datatype. .. note:: This method modifies the module in-place. Returns: Module: self bfloat16(self: ~T) -> ~T","title":"bfloat16"},{"location":"src_utils_weight_quantization/#buffers","text":"Return an iterator over module buffers. Args: recurse (bool): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Yields: torch.Tensor: module buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for buf in model.buffers(): >>> print(type(buf), buf.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) buffers(self, recurse: bool = True) -> Iterator[torch.Tensor]","title":"buffers"},{"location":"src_utils_weight_quantization/#children","text":"Return an iterator over immediate children modules. Yields: Module: a child module children(self) -> Iterator[ForwardRef('Module')]","title":"children"},{"location":"src_utils_weight_quantization/#compile","text":"Compile this Module's forward using :func: torch.compile . This Module's __call__ method is compiled and all arguments are passed as-is to :func: torch.compile . See :func: torch.compile for details on the arguments for this function. compile(self, *args, **kwargs)","title":"compile"},{"location":"src_utils_weight_quantization/#cpu","text":"Move all model parameters and buffers to the CPU. .. note:: This method modifies the module in-place. Returns: Module: self cpu(self: ~T) -> ~T","title":"cpu"},{"location":"src_utils_weight_quantization/#cuda","text":"Move all model parameters and buffers to the GPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on GPU while being optimized. .. note:: This method modifies the module in-place. Args: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self cuda(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"cuda"},{"location":"src_utils_weight_quantization/#double","text":"Casts all floating point parameters and buffers to double datatype. .. note:: This method modifies the module in-place. Returns: Module: self double(self: ~T) -> ~T","title":"double"},{"location":"src_utils_weight_quantization/#eval","text":"Set the module in evaluation mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e. whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. This is equivalent with :meth: self.train(False) <torch.nn.Module.train> . See :ref: locally-disable-grad-doc for a comparison between .eval() and several similar mechanisms that may be confused with it. Returns: Module: self eval(self: ~T) -> ~T","title":"eval"},{"location":"src_utils_weight_quantization/#extra_repr","text":"Return the extra representation of the module. To print customized extra information, you should re-implement this method in your own modules. Both single-line and multi-line strings are acceptable. extra_repr(self) -> str","title":"extra_repr"},{"location":"src_utils_weight_quantization/#float","text":"Casts all floating point parameters and buffers to float datatype. .. note:: This method modifies the module in-place. Returns: Module: self float(self: ~T) -> ~T","title":"float"},{"location":"src_utils_weight_quantization/#forward","text":"forward(self, input)","title":"forward"},{"location":"src_utils_weight_quantization/#get_buffer","text":"Return the buffer given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the buffer to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.Tensor: The buffer referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not a buffer get_buffer(self, target: str) -> 'Tensor'","title":"get_buffer"},{"location":"src_utils_weight_quantization/#get_extra_state","text":"Return any extra state to include in the module's state_dict. Implement this and a corresponding :func: set_extra_state for your module if you need to store extra state. This function is called when building the module's state_dict() . Note that extra state should be picklable to ensure working serialization of the state_dict. We only provide backwards compatibility guarantees for serializing Tensors; other objects may break backwards compatibility if their serialized pickled form changes. Returns: object: Any extra state to store in the module's state_dict get_extra_state(self) -> Any","title":"get_extra_state"},{"location":"src_utils_weight_quantization/#get_parameter","text":"Return the parameter given by target if it exists, otherwise throw an error. See the docstring for get_submodule for a more detailed explanation of this method's functionality as well as how to correctly specify target . Args: target: The fully-qualified string name of the Parameter to look for. (See get_submodule for how to specify a fully-qualified string.) Returns: torch.nn.Parameter: The Parameter referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Parameter get_parameter(self, target: str) -> 'Parameter'","title":"get_parameter"},{"location":"src_utils_weight_quantization/#get_submodule","text":"Return the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A which has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To check whether or not we have the linear submodule, we would call get_submodule(\"net_b.linear\") . To check whether we have the conv submodule, we would call get_submodule(\"net_b.net_c.conv\") . The runtime of get_submodule is bounded by the degree of module nesting in target . A query against named_modules achieves the same result, but it is O(N) in the number of transitive modules. So, for a simple check to see if some submodule exists, get_submodule should always be used. Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) Returns: torch.nn.Module: The submodule referenced by target Raises: AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module get_submodule(self, target: str) -> 'Module'","title":"get_submodule"},{"location":"src_utils_weight_quantization/#half","text":"Casts all floating point parameters and buffers to half datatype. .. note:: This method modifies the module in-place. Returns: Module: self half(self: ~T) -> ~T","title":"half"},{"location":"src_utils_weight_quantization/#ipu","text":"Move all model parameters and buffers to the IPU. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on IPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self ipu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"ipu"},{"location":"src_utils_weight_quantization/#load_state_dict","text":"Copy parameters and buffers from :attr: state_dict into this module and its descendants. If :attr: strict is True , then the keys of :attr: state_dict must exactly match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. .. warning:: If :attr: assign is True the optimizer must be created after the call to :attr: load_state_dict unless :func: ~torch.__future__.get_swap_module_params_on_conversion is True . Args: state_dict (dict): a dict containing parameters and persistent buffers. strict (bool, optional): whether to strictly enforce that the keys in :attr: state_dict match the keys returned by this module's :meth: ~torch.nn.Module.state_dict function. Default: True assign (bool, optional): When set to False , the properties of the tensors in the current module are preserved whereas setting it to True preserves properties of the Tensors in the state dict. The only exception is the requires_grad field of :class: ~torch.nn.Parameter s for which the value from the module is preserved. Default: False Returns: NamedTuple with missing_keys and unexpected_keys fields: * missing_keys is a list of str containing any keys that are expected by this module but missing from the provided state_dict . * unexpected_keys is a list of str containing the keys that are not expected by this module but present in the provided state_dict . Note: If a parameter or buffer is registered as None and its corresponding key exists in :attr: state_dict , :meth: load_state_dict will raise a RuntimeError . load_state_dict(self, state_dict: Mapping[str, Any], strict: bool = True, assign: bool = False)","title":"load_state_dict"},{"location":"src_utils_weight_quantization/#modules","text":"Return an iterator over all modules in the network. Yields: Module: a module in the network Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.modules()): ... print(idx, '->', m) 0 -> Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) ) 1 -> Linear(in_features=2, out_features=2, bias=True) modules(self) -> Iterator[ForwardRef('Module')]","title":"modules"},{"location":"src_utils_weight_quantization/#mtia","text":"Move all model parameters and buffers to the MTIA. This also makes associated parameters and buffers different objects. So it should be called before constructing the optimizer if the module will live on MTIA while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self mtia(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"mtia"},{"location":"src_utils_weight_quantization/#named_buffers","text":"Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself. Args: prefix (str): prefix to prepend to all buffer names. recurse (bool, optional): if True, then yields buffers of this module and all submodules. Otherwise, yields only buffers that are direct members of this module. Defaults to True. remove_duplicate (bool, optional): whether to remove the duplicated buffers in the result. Defaults to True. Yields: (str, torch.Tensor): Tuple containing the name and buffer Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, buf in self.named_buffers(): >>> if name in ['running_var']: >>> print(buf.size()) named_buffers(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.Tensor]]","title":"named_buffers"},{"location":"src_utils_weight_quantization/#named_children","text":"Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself. Yields: (str, Module): Tuple containing a name and child module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, module in model.named_children(): >>> if name in ['conv4', 'conv5']: >>> print(module) named_children(self) -> Iterator[Tuple[str, ForwardRef('Module')]]","title":"named_children"},{"location":"src_utils_weight_quantization/#named_modules","text":"Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself. Args: memo: a memo to store the set of modules already added to the result prefix: a prefix that will be added to the name of the module remove_duplicate: whether to remove the duplicated module instances in the result or not Yields: (str, Module): Tuple of name and module Note: Duplicate modules are returned only once. In the following example, l will be returned only once. Example:: >>> l = nn.Linear(2, 2) >>> net = nn.Sequential(l, l) >>> for idx, m in enumerate(net.named_modules()): ... print(idx, '->', m) 0 -> ('', Sequential( (0): Linear(in_features=2, out_features=2, bias=True) (1): Linear(in_features=2, out_features=2, bias=True) )) 1 -> ('0', Linear(in_features=2, out_features=2, bias=True)) named_modules(self, memo: Optional[Set[ForwardRef('Module')]] = None, prefix: str = '', remove_duplicate: bool = True)","title":"named_modules"},{"location":"src_utils_weight_quantization/#named_parameters","text":"Return an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself. Args: prefix (str): prefix to prepend to all parameter names. recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. remove_duplicate (bool, optional): whether to remove the duplicated parameters in the result. Defaults to True. Yields: (str, Parameter): Tuple containing the name and parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for name, param in self.named_parameters(): >>> if name in ['bias']: >>> print(param.size()) named_parameters(self, prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.nn.parameter.Parameter]]","title":"named_parameters"},{"location":"src_utils_weight_quantization/#parameters","text":"Return an iterator over module parameters. This is typically passed to an optimizer. Args: recurse (bool): if True, then yields parameters of this module and all submodules. Otherwise, yields only parameters that are direct members of this module. Yields: Parameter: module parameter Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> for param in model.parameters(): >>> print(type(param), param.size()) <class 'torch.Tensor'> (20L,) <class 'torch.Tensor'> (20L, 1L, 5L, 5L) parameters(self, recurse: bool = True) -> Iterator[torch.nn.parameter.Parameter]","title":"parameters"},{"location":"src_utils_weight_quantization/#register_backward_hook","text":"Register a backward hook on the module. This function is deprecated in favor of :meth: ~torch.nn.Module.register_full_backward_hook and the behavior of this function will change in future versions. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]]) -> torch.utils.hooks.RemovableHandle","title":"register_backward_hook"},{"location":"src_utils_weight_quantization/#register_buffer","text":"Add a buffer to the module. This is typically used to register a buffer that should not to be considered a model parameter. For example, BatchNorm's running_mean is not a parameter, but is part of the module's state. Buffers, by default, are persistent and will be saved alongside parameters. This behavior can be changed by setting :attr: persistent to False . The only difference between a persistent buffer and a non-persistent buffer is that the latter will not be a part of this module's :attr: state_dict . Buffers can be accessed as attributes using given names. Args: name (str): name of the buffer. The buffer can be accessed from this module using the given name tensor (Tensor or None): buffer to be registered. If None , then operations that run on buffers, such as :attr: cuda , are ignored. If None , the buffer is not included in the module's :attr: state_dict . persistent (bool): whether the buffer is part of this module's :attr: state_dict . Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> self.register_buffer('running_mean', torch.zeros(num_features)) register_buffer(self, name: str, tensor: Optional[torch.Tensor], persistent: bool = True) -> None","title":"register_buffer"},{"location":"src_utils_weight_quantization/#register_forward_hook","text":"Register a forward hook on the module. The hook will be called every time after :func: forward has computed an output. If with_kwargs is False or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the output. It can modify the input inplace but it will not have effect on forward since this is called after :func: forward is called. The hook should have the following signature:: hook(module, args, output) -> None or modified output If with_kwargs is True , the forward hook will be passed the kwargs given to the forward function and be expected to return the output possibly modified. The hook should have the following signature:: hook(module, args, kwargs, output) -> None or modified output Args: hook (Callable): The user defined hook to be registered. prepend (bool): If True , the provided hook will be fired before all existing forward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward hooks on this :class: torch.nn.modules.Module . Note that global forward hooks registered with :func: register_module_forward_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If True , the hook will be passed the kwargs given to the forward function. Default: False always_call (bool): If True the hook will be run regardless of whether an exception is raised while calling the Module. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...], Any], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any], Any], Optional[Any]]], *, prepend: bool = False, with_kwargs: bool = False, always_call: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_forward_hook"},{"location":"src_utils_weight_quantization/#register_forward_pre_hook","text":"Register a forward pre-hook on the module. The hook will be called every time before :func: forward is invoked. If with_kwargs is false or not specified, the input contains only the positional arguments given to the module. Keyword arguments won't be passed to the hooks and only to the forward . The hook can modify the input. User can either return a tuple or a single modified value in the hook. We will wrap the value into a tuple if a single value is returned (unless that value is already a tuple). The hook should have the following signature:: hook(module, args) -> None or modified input If with_kwargs is true, the forward pre-hook will be passed the kwargs given to the forward function. And if the hook modifies the input, both the args and kwargs should be returned. The hook should have the following signature:: hook(module, args, kwargs) -> None or a tuple of modified input and kwargs Args: hook (Callable): The user defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing forward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing forward_pre hooks on this :class: torch.nn.modules.Module . Note that global forward_pre hooks registered with :func: register_module_forward_pre_hook will fire before all hooks registered by this method. Default: False with_kwargs (bool): If true, the hook will be passed the kwargs given to the forward function. Default: False Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_forward_pre_hook(self, hook: Union[Callable[[~T, Tuple[Any, ...]], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any]], Optional[Tuple[Any, Dict[str, Any]]]]], *, prepend: bool = False, with_kwargs: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_forward_pre_hook"},{"location":"src_utils_weight_quantization/#register_full_backward_hook","text":"Register a backward hook on the module. The hook will be called every time the gradients with respect to a module are computed, i.e. the hook will execute if and only if the gradients with respect to module outputs are computed. The hook should have the following signature:: hook(module, grad_input, grad_output) -> tuple(Tensor) or None The :attr: grad_input and :attr: grad_output are tuples that contain the gradients with respect to the inputs and outputs respectively. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the input that will be used in place of :attr: grad_input in subsequent computations. :attr: grad_input will only correspond to the inputs given as positional arguments and all kwarg arguments are ignored. Entries in :attr: grad_input and :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs or outputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward hooks on this :class: torch.nn.modules.Module . Note that global backward hooks registered with :func: register_module_full_backward_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_full_backward_hook"},{"location":"src_utils_weight_quantization/#register_full_backward_pre_hook","text":"Register a backward pre-hook on the module. The hook will be called every time the gradients for the module are computed. The hook should have the following signature:: hook(module, grad_output) -> tuple[Tensor] or None The :attr: grad_output is a tuple. The hook should not modify its arguments, but it can optionally return a new gradient with respect to the output that will be used in place of :attr: grad_output in subsequent computations. Entries in :attr: grad_output will be None for all non-Tensor arguments. For technical reasons, when this hook is applied to a Module, its forward function will receive a view of each Tensor passed to the Module. Similarly the caller will receive a view of each Tensor returned by the Module's forward function. .. warning :: Modifying inputs inplace is not allowed when using backward hooks and will raise an error. Args: hook (Callable): The user-defined hook to be registered. prepend (bool): If true, the provided hook will be fired before all existing backward_pre hooks on this :class: torch.nn.modules.Module . Otherwise, the provided hook will be fired after all existing backward_pre hooks on this :class: torch.nn.modules.Module . Note that global backward_pre hooks registered with :func: register_module_full_backward_pre_hook will fire before all hooks registered by this method. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_full_backward_pre_hook(self, hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle","title":"register_full_backward_pre_hook"},{"location":"src_utils_weight_quantization/#register_load_state_dict_post_hook","text":"Register a post-hook to be run after module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, incompatible_keys) -> None The module argument is the current module that this hook is registered on, and the incompatible_keys argument is a NamedTuple consisting of attributes missing_keys and unexpected_keys . missing_keys is a list of str containing the missing keys and unexpected_keys is a list of str containing the unexpected keys. The given incompatible_keys can be modified inplace if needed. Note that the checks performed when calling :func: load_state_dict with strict=True are affected by modifications the hook makes to missing_keys or unexpected_keys , as expected. Additions to either set of keys will result in an error being thrown when strict=True , and clearing out both missing and unexpected keys will avoid an error. Returns: :class: torch.utils.hooks.RemovableHandle : a handle that can be used to remove the added hook by calling handle.remove() register_load_state_dict_post_hook(self, hook)","title":"register_load_state_dict_post_hook"},{"location":"src_utils_weight_quantization/#register_load_state_dict_pre_hook","text":"Register a pre-hook to be run before module's :meth: ~nn.Module.load_state_dict is called. It should have the following signature:: hook(module, state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs) -> None # noqa: B950 Arguments: hook (Callable): Callable hook that will be invoked before loading the state dict. register_load_state_dict_pre_hook(self, hook)","title":"register_load_state_dict_pre_hook"},{"location":"src_utils_weight_quantization/#register_module","text":"Alias for :func: add_module . register_module(self, name: str, module: Optional[ForwardRef('Module')]) -> None","title":"register_module"},{"location":"src_utils_weight_quantization/#register_parameter","text":"Add a parameter to the module. The parameter can be accessed as an attribute using given name. Args: name (str): name of the parameter. The parameter can be accessed from this module using the given name param (Parameter or None): parameter to be added to the module. If None , then operations that run on parameters, such as :attr: cuda , are ignored. If None , the parameter is not included in the module's :attr: state_dict . register_parameter(self, name: str, param: Optional[torch.nn.parameter.Parameter]) -> None","title":"register_parameter"},{"location":"src_utils_weight_quantization/#register_state_dict_post_hook","text":"Register a post-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, state_dict, prefix, local_metadata) -> None The registered hooks can modify the state_dict inplace. register_state_dict_post_hook(self, hook)","title":"register_state_dict_post_hook"},{"location":"src_utils_weight_quantization/#register_state_dict_pre_hook","text":"Register a pre-hook for the :meth: ~torch.nn.Module.state_dict method. It should have the following signature:: hook(module, prefix, keep_vars) -> None The registered hooks can be used to perform pre-processing before the state_dict call is made. register_state_dict_pre_hook(self, hook)","title":"register_state_dict_pre_hook"},{"location":"src_utils_weight_quantization/#requires_grad_","text":"Change if autograd should record operations on parameters in this module. This method sets the parameters' :attr: requires_grad attributes in-place. This method is helpful for freezing part of the module for finetuning or training parts of a model individually (e.g., GAN training). See :ref: locally-disable-grad-doc for a comparison between .requires_grad_() and several similar mechanisms that may be confused with it. Args: requires_grad (bool): whether autograd should record operations on parameters in this module. Default: True . Returns: Module: self requires_grad_(self: ~T, requires_grad: bool = True) -> ~T","title":"requires_grad_"},{"location":"src_utils_weight_quantization/#set_extra_state","text":"Set extra state contained in the loaded state_dict . This function is called from :func: load_state_dict to handle any extra state found within the state_dict . Implement this function and a corresponding :func: get_extra_state for your module if you need to store extra state within its state_dict . Args: state (dict): Extra state from the state_dict set_extra_state(self, state: Any) -> None","title":"set_extra_state"},{"location":"src_utils_weight_quantization/#set_submodule","text":"Set the submodule given by target if it exists, otherwise throw an error. For example, let's say you have an nn.Module A that looks like this: .. code-block:: text A( (net_b): Module( (net_c): Module( (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2)) ) (linear): Linear(in_features=100, out_features=200, bias=True) ) ) (The diagram shows an nn.Module A . A has a nested submodule net_b , which itself has two submodules net_c and linear . net_c then has a submodule conv .) To overide the Conv2d with a new submodule Linear , you would call set_submodule(\"net_b.net_c.conv\", nn.Linear(33, 16)) . Args: target: The fully-qualified string name of the submodule to look for. (See above example for how to specify a fully-qualified string.) module: The module to set the submodule to. Raises: ValueError: If the target string is empty AttributeError: If the target string references an invalid path or resolves to something that is not an nn.Module set_submodule(self, target: str, module: 'Module') -> None","title":"set_submodule"},{"location":"src_utils_weight_quantization/#share_memory","text":"See :meth: torch.Tensor.share_memory_ . share_memory(self: ~T) -> ~T","title":"share_memory"},{"location":"src_utils_weight_quantization/#state_dict","text":"Return a dictionary containing references to the whole state of the module. Both parameters and persistent buffers (e.g. running averages) are included. Keys are corresponding parameter and buffer names. Parameters and buffers set to None are not included. .. note:: The returned object is a shallow copy. It contains references to the module's parameters and buffers. .. warning:: Currently state_dict() also accepts positional arguments for destination , prefix and keep_vars in order. However, this is being deprecated and keyword arguments will be enforced in future releases. .. warning:: Please avoid the use of argument destination as it is not designed for end-users. Args: destination (dict, optional): If provided, the state of module will be updated into the dict and the same object is returned. Otherwise, an OrderedDict will be created and returned. Default: None . prefix (str, optional): a prefix added to parameter and buffer names to compose the keys in state_dict. Default: '' . keep_vars (bool, optional): by default the :class: ~torch.Tensor s returned in the state dict are detached from autograd. If it's set to True , detaching will not be performed. Default: False . Returns: dict: a dictionary containing a whole state of the module Example:: >>> # xdoctest: +SKIP(\"undefined vars\") >>> module.state_dict().keys() ['bias', 'weight'] state_dict(self, *args, destination=None, prefix='', keep_vars=False)","title":"state_dict"},{"location":"src_utils_weight_quantization/#to","text":"Move and/or cast the parameters and buffers. This can be called as .. function:: to(device=None, dtype=None, non_blocking=False) :noindex: .. function:: to(dtype, non_blocking=False) :noindex: .. function:: to(tensor, non_blocking=False) :noindex: .. function:: to(memory_format=torch.channels_last) :noindex: Its signature is similar to :meth: torch.Tensor.to , but only accepts floating point or complex :attr: dtype \\ s. In addition, this method will only cast the floating point or complex parameters and buffers to :attr: dtype (if given). The integral parameters and buffers will be moved :attr: device , if that is given, but with dtypes unchanged. When :attr: non_blocking is set, it tries to convert/move asynchronously with respect to the host if possible, e.g., moving CPU Tensors with pinned memory to CUDA devices. See below for examples. .. note:: This method modifies the module in-place. Args: device (:class: torch.device ): the desired device of the parameters and buffers in this module dtype (:class: torch.dtype ): the desired floating point or complex dtype of the parameters and buffers in this module tensor (torch.Tensor): Tensor whose dtype and device are the desired dtype and device for all parameters and buffers in this module memory_format (:class: torch.memory_format ): the desired memory format for 4D parameters and buffers in this module (keyword only argument) Returns: Module: self Examples:: >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\") >>> linear = nn.Linear(2, 2) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]]) >>> linear.to(torch.double) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1913, -0.3420], [-0.5113, -0.2325]], dtype=torch.float64) >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA1) >>> gpu1 = torch.device(\"cuda:1\") >>> linear.to(gpu1, dtype=torch.half, non_blocking=True) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1') >>> cpu = torch.device(\"cpu\") >>> linear.to(cpu) Linear(in_features=2, out_features=2, bias=True) >>> linear.weight Parameter containing: tensor([[ 0.1914, -0.3420], [-0.5112, -0.2324]], dtype=torch.float16) >>> linear = nn.Linear(2, 2, bias=None).to(torch.cdouble) >>> linear.weight Parameter containing: tensor([[ 0.3741+0.j, 0.2382+0.j], [ 0.5593+0.j, -0.4443+0.j]], dtype=torch.complex128) >>> linear(torch.ones(3, 2, dtype=torch.cdouble)) tensor([[0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j], [0.6122+0.j, 0.1150+0.j]], dtype=torch.complex128) to(self, *args, **kwargs)","title":"to"},{"location":"src_utils_weight_quantization/#to_empty","text":"Move the parameters and buffers to the specified device without copying storage. Args: device (:class: torch.device ): The desired device of the parameters and buffers in this module. recurse (bool): Whether parameters and buffers of submodules should be recursively moved to the specified device. Returns: Module: self to_empty(self: ~T, *, device: Union[int, str, torch.device, NoneType], recurse: bool = True) -> ~T","title":"to_empty"},{"location":"src_utils_weight_quantization/#train","text":"Set the module in training mode. This has an effect only on certain modules. See the documentation of particular modules for details of their behaviors in training/evaluation mode, i.e., whether they are affected, e.g. :class: Dropout , :class: BatchNorm , etc. Args: mode (bool): whether to set training mode ( True ) or evaluation mode ( False ). Default: True . Returns: Module: self train(self: ~T, mode: bool = True) -> ~T","title":"train"},{"location":"src_utils_weight_quantization/#type","text":"Casts all parameters and buffers to :attr: dst_type . .. note:: This method modifies the module in-place. Args: dst_type (type or string): the desired type Returns: Module: self type(self: ~T, dst_type: Union[torch.dtype, str]) -> ~T","title":"type"},{"location":"src_utils_weight_quantization/#xpu","text":"Move all model parameters and buffers to the XPU. This also makes associated parameters and buffers different objects. So it should be called before constructing optimizer if the module will live on XPU while being optimized. .. note:: This method modifies the module in-place. Arguments: device (int, optional): if specified, all parameters will be copied to that device Returns: Module: self xpu(self: ~T, device: Union[int, torch.device, NoneType] = None) -> ~T","title":"xpu"},{"location":"src_utils_weight_quantization/#zero_grad","text":"Reset gradients of all model parameters. See similar function under :class: torch.optim.Optimizer for more context. Args: set_to_none (bool): instead of setting to zero, set the grads to None. See :meth: torch.optim.Optimizer.zero_grad for details. zero_grad(self, set_to_none: bool = True) -> None","title":"zero_grad"},{"location":"src_utils_weight_quantization/#functions","text":"","title":"Functions"},{"location":"src_utils_weight_quantization/#compare_quantization_configs","text":"Compare different quantization configurations and visualize results. Args: model: The original model inputs: Input tensors configs: List of quantization configs to test output_dir: Directory to save results Returns: Dict with comparison results compare_quantization_configs(model, inputs, configs=None, output_dir=None)","title":"compare_quantization_configs"},{"location":"src_utils_weight_quantization/#kv_cache_offload","text":"Enable KV cache offloading to disk for the given model. Args: model: The EdgeFormer model offload_path: Directory to store KV cache files (default: temporary directory) kv_cache_dtype: Data type for stored KV cache (default: float16 for memory efficiency) Returns: Modified model with KV cache offloading enabled kv_cache_offload(model, offload_path=None, kv_cache_dtype=torch.float16)","title":"kv_cache_offload"},{"location":"src_utils_weight_quantization/#quantize_weight_only","text":"Quantize only the weights of a linear layer. Args: module: The linear layer to quantize bits: Bit width for quantization (4 or 8) group_size: Size of quantization groups symmetric: Whether to use symmetric quantization Returns: A weight-only quantized linear layer quantize_weight_only(module, bits=4, group_size=128, symmetric=True)","title":"quantize_weight_only"},{"location":"src_utils_weight_quantization/#test_weight_only_quantization","text":"Test weight-only quantization by comparing outputs with the original model. Args: model: The original model inputs: Input tensors bits: Bit width for quantization (4 or 8) group_size: Size of quantization groups symmetric: Whether to use symmetric quantization Returns: Dict with comparison metrics test_weight_only_quantization(model, inputs, bits=4, group_size=128, symmetric=True)","title":"test_weight_only_quantization"},{"location":"src_utils_weight_quantization/#weight_only_quantize_model","text":"Apply weight-only quantization to a model's linear layers. Args: model: The model to quantize bits: Bit width for quantization (4 or 8) group_size: Size of quantization groups symmetric: Whether to use symmetric quantization modules_to_exclude: List of module names to exclude from quantization Returns: A weight-only quantized model weight_only_quantize_model(model, bits=4, group_size=128, symmetric=True, modules_to_exclude=None)","title":"weight_only_quantize_model"}]}